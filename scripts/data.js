const dsaData = {
  "Array": [
    {
      "fileName": "Add Two Numbers Represented By Two Arrays.cpp",
      "name": "Add Two Numbers Represented By Two Arrays",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nExample 1:\nInput:\n\nnums1 = [2, 4, 3]\nnums2 = [5, 6, 4]\nOutput:\n\n[7, 0, 8]\nExplaination:\nThe number represented by nums1 is 342. The number represented by nums2 is 465. 342+465=807. The sum, 807, in reverse order is [7,0,8].\n\nExample 2:\nInput:\n\nnums1 = [0]\nnums2 = [0]\nOutput:\n\n[0]\nExplaination:\n0+0=0. The sum, 0, in reverse order is [0].\n\nExample 1:\n\nInput:\n\nnums1=[2,4,3] nums2=[5,6,4]\n\nOutput:\n\n7 0 8\nExplanation:342 + 465 = 807 \u2192 reversed digits [7,0,8]\n\nExample 2:\n\nInput:\n\nnums1=[0] nums2=[0]\n\nOutput:\n\n0\nExplanation:0 + 0 = 0 \u2192 [0]\n\nExample 3:\n\nInput:\n\nnums1=[9,9,9,9,9] nums2=[1]\n\nOutput:\n\n0 0 0 0 0 1\nExplanation:99 999 + 1 = 100 000 \u2192 reversed [0,0,0,0,0,1]\n\n*/\n\nclass Solution\n{\npublic:\n    vector<int> addTwoNumbers(vector<int> &nums1, vector<int> &nums2)\n    {\n        vector<int> answer;\n        int x = 0, y = 0;\n        int size1 = nums1.size(), size2 = nums2.size();\n        int carry = 0;\n\n        while (x < size1 || y < size2)\n        {\n            int digit1 = x < size1 ? nums1[x] : 0;\n            int digit2 = y < size2 ? nums2[y] : 0;\n\n            int sum = digit1 + digit2 + carry;\n            carry = sum / 10;\n\n            answer.push_back(sum % 10);\n\n            x < size1 ? x++ : x;\n            y < size2 ? y++ : y;\n        }\n\n        if (carry)\n            answer.push_back(carry);\n\n        return answer;\n    }\n};\n",
      "output": "[7, 0, 8]\nExplaination:\nThe number represented by nums1 is 342. The number represented by nums2 is 465. 342+465=807. The sum, 807, in reverse order is [7,0,8].\n[0]\nExplaination:\n0+0=0. The sum, 0, in reverse order is [0].\n7 0 8\nExplanation:342 + 465 = 807 \u2192 reversed digits [7,0,8]\n0\nExplanation:0 + 0 = 0 \u2192 [0]\n0 0 0 0 0 1\nExplanation:99 999 + 1 = 100 000 \u2192 reversed [0,0,0,0,0,1]",
      "language": "cpp"
    },
    {
      "fileName": "Common Elements In 3 Sorted Array.cpp",
      "name": "Common Elements In 3 Sorted Array",
      "code": "#include <vector>\nusing namespace std;\n\n/*\n\nExample 1:\nInput:\n\narray1 = [1, 5, 10, 20, 40, 80]\narray2 = [6, 7, 20, 80, 100]\narray3 = [3, 4, 15, 20, 30, 70, 80, 120]\nOutput:\n\n[20, 80]\nExplaination:\nThe number 20 is present in all three arrays. The number 80 is also present in all three arrays. No other number is common to all three.\n\nExample 2:\nInput:\n\narray1 = [1, 2, 3, 4, 5]\narray2 = [1, 2, 3, 4, 5]\narray3 = [1, 2, 3, 4, 5]\nOutput:\n\n[1, 2, 3, 4, 5]\nExplaination:\nAll elements from 1 to 5 are common to all three arrays.\n\nFollow-up: Could you solve this problem with a time complexity of O(n1 + n2 + n3) where n1, n2, and n3 are the lengths of arrays array1, array2, and array3 respectively, and with minimal additional space?\n\nExample 1:\n\nInput:\n\narray1=[1,5,10,20,40,80] array2=[6,7,20,80,100] array3=[3,4,15,20,30,70,80,120]\n\nOutput:\n\n20 80\nExplanation:Only 20 and 80 appear in all three arrays; duplicates are removed.\n\nExample 2:\n\nInput:\n\narray1=[1,2,3] array2=[1,2,3] array3=[1,2,3]\n\nOutput:\n\n1 2 3\nExplanation:Every element is common, output keeps sorted order without duplicates.\n\nExample 3:\n\nInput:\n\narray1=[1,2,3] array2=[4,5,6] array3=[7,8,9]\n\nExplanation:The three arrays share no values; result list is empty.\n\n*/\n\n// first best way to sovle it\n\nclass Solution\n{\npublic:\n    vector<int> removeDup(vector<int> &arr)\n    {\n\n        vector<int> temp;\n        if (arr.size() == 0)\n            return temp;\n\n        temp.push_back(arr[0]);\n\n        for (int i = 1; i < arr.size(); i++)\n        {\n            if (arr[i] != arr[i - 1])\n                temp.push_back(arr[i]);\n        }\n        return temp;\n    }\n\n    vector<int> commonElements(vector<int> &array1, vector<int> &array2,\n                               vector<int> &array3)\n    {\n\n        vector<int> a = removeDup(array1);\n        vector<int> b = removeDup(array2);\n        vector<int> c = removeDup(array3);\n\n        vector<int> ans;\n        int i = 0, j = 0, k = 0;\n\n        while (i < a.size() && j < b.size() && k < c.size())\n        {\n\n            if (a[i] == b[j] && b[j] == c[k])\n            {\n                ans.push_back(a[i]);\n                i++;\n                j++;\n                k++;\n            }\n            else if (a[i] < b[j])\n                i++;\n            else if (b[j] < c[k])\n                j++;\n            else\n                k++;\n        }\n        return ans;\n    }\n};\n\n// second best way to solve it\n\nclass Solution\n{\npublic:\n    vector<int> commonElements(vector<int> &array1, vector<int> &array2,\n                               vector<int> &array3)\n    {\n\n        vector<int> ans;\n        int i = 0, j = 0, k = 0;\n\n        while (i < array1.size() && j < array2.size() && k < array3.size())\n        {\n\n            if (array1[i] == array2[j] && array2[j] == array3[k])\n            {\n\n                if (ans.size() == 0 || ans.back() != array1[i])\n                    ans.push_back(array1[i]);\n\n                i++;\n                j++;\n                k++;\n            }\n            else if (array1[i] < array2[j])\n                i++;\n            else if (array2[j] < array3[k])\n                j++;\n            else\n                k++;\n        }\n        return ans;\n    }\n};\n\n// third best way to solve it\n#include <set>\nclass Solution\n{\npublic:\n    vector<int> commonElements(vector<int> &array1, vector<int> &array2,\n                               vector<int> &array3)\n    {\n\n        vector<int> ans;\n        int i, j, k;\n        i = j = k = 0;\n        set<int> s;\n\n        while (i < array1.size() && j < array2.size() && k < array3.size())\n        {\n            if (array1[i] == array2[j] && array2[j] == array3[k])\n            {\n                s.insert(array1[i]);\n                i++, j++, k++;\n            }\n            else if (array1[i] < array2[j])\n                i++;\n            else if (array2[j] < array3[k])\n                j++;\n            else\n                k++;\n        }\n        for (auto x : s)\n        {\n            ans.push_back(x);\n        }\n        return ans;\n    }\n};",
      "output": "[20, 80]\nExplaination:\nThe number 20 is present in all three arrays. The number 80 is also present in all three arrays. No other number is common to all three.\n[1, 2, 3, 4, 5]\nExplaination:\nAll elements from 1 to 5 are common to all three arrays.\nFollow-up: Could you solve this problem with a time complexity of O(n1 + n2 + n3) where n1, n2, and n3 are the lengths of arrays array1, array2, and array3 respectively, and with minimal additional space?\n20 80\nExplanation:Only 20 and 80 appear in all three arrays; duplicates are removed.\n1 2 3\nExplanation:Every element is common, output keeps sorted order without duplicates.",
      "language": "cpp"
    },
    {
      "fileName": "Count the Number of Zeros and Ones in an Array.cpp",
      "name": "Count the Number of Zeros and Ones in an Array",
      "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\n/*\n\nExample 1:\n\nInput:\n\nInput: nums = [0, 1, 0, 1, 1, 0]\n\nOutput:\n\nzeros: 3, ones: 3\nExplanation:Equal number of zeros and ones, count of each is 3.\n\nExample 2:\n\nInput:\n\nInput: nums = [1, 1, 1, 1, 1]\n\nOutput:\n\nzeros: 0, ones: 5\nExplanation:All elements are ones, so zero count is 0 and one count is 5.\n\nExample 3:\n\nInput:\n\nInput: nums = [0, 0, 0, 0, 0, 0]\n\nOutput:\n\nzeros: 6, ones: 0\nExplanation:All elements are zeros, so zero count is 6 and one count is 0.\n\n*/\n\n\n\nclass Solution {\npublic:\n  std::pair<int, int> countZerosAndOnes(const std::vector<int> &nums) {\n    // Implement this method\n    int totalOnes = 0;\n    int totalZeros = 0;\n    int size = nums.size();\n    for (int i = 0; i < size; i++) {\n      if (nums[i] == 0) {\n        totalZeros++;\n      }\n      if (nums[i] == 1) {\n        totalOnes++;\n      }\n    }\n    // return {totalZeros, totalOnes};\n    pair<int, int> ans;\n    ans.first = totalZeros;\n    ans.second = totalOnes;\n    return ans;\n  }\n};",
      "output": "zeros: 3, ones: 3\nExplanation:Equal number of zeros and ones, count of each is 3.\nzeros: 0, ones: 5\nExplanation:All elements are ones, so zero count is 0 and one count is 5.\nzeros: 6, ones: 0\nExplanation:All elements are zeros, so zero count is 6 and one count is 0.",
      "language": "cpp"
    },
    {
      "fileName": "Find Duplicate Number.cpp",
      "name": "Find Duplicate Number",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nYou are given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\n\nThere is only one duplicate number in nums, return this duplicate number.\n\nNote:\nYou must solve the problem without modifying the array nums and use only constant extra space.\nChallenge:\nCan you solve the problem in linear time, O(n)?\n\nExample 1:\n\nInput:\n\nn=5 nums=[1,3,4,2,2]\n\nOutput:\n\n2\nExplanation:Among numbers 1\u20124, the value 2 is repeated.\n\nExample 2:\n\nInput:\n\nn=5 nums=[3,1,3,4,2]\n\nOutput:\n\n3\nExplanation:3 occurs at indices 0 and 2 \u2192 duplicate = 3.\n\nExample 3:\n\nInput:\n\nn=5 nums=[1,1,2,3,4]\n\nOutput:\n\n1\nExplanation:The value 1 appears twice; all others are unique.\n\n*/\n\nclass Solution\n{\npublic:\n    int findDuplicate(vector<int> &nums)\n    {\n\n        while (nums[0] != nums[nums[0]])\n        {\n            swap(nums[0], nums[nums[0]]);\n        }\n\n        return nums[0];\n    }\n};\n",
      "output": "2\nExplanation:Among numbers 1\u20124, the value 2 is repeated.\n3\nExplanation:3 occurs at indices 0 and 2 \u2192 duplicate = 3.\n1\nExplanation:The value 1 appears twice; all others are unique.",
      "language": "cpp"
    },
    {
      "fileName": "Find First Unsorted Element in Array.cpp",
      "name": "Find First Unsorted Element in Array",
      "code": "\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nExample\nInput: [1, 2, 3, 4, 6, 5, 7, 8]\nOutput: 4\nIn the given input, elements from index 0 to 3 (1, 2, 3, 4) are in non-decreasing order. The element at index 4 is 6, which is followed by 5 at index 5, violating the non-decreasing order since 6 is greater than 5. Hence, index 4 is the first unsorted element.\n\nTry to identify this pattern and apply the logic to solve the problem for any given input array.\n\nExample 1:\n\nInput:\n\nInput: arr = [1, 2, 3, 4, 5]\n\nOutput:\n\n-1\nExplanation:The array is already sorted.\n\nExample 2:\n\nInput:\n\nInput: arr = [10, 20, 30, 25, 40]\n\nOutput:\n\n2\nExplanation:First unsorted element is at index 2 (30 > 25).\n\nExample 3:\n\nInput:\n\nInput: arr = [5, 4, 3, 2, 1]\n\nOutput:\n\n0\nExplanation:First unsorted element is at index 0 (5 > 4).\n\n*/\n\nclass Solution\n{\npublic:\n    int findFirstUnsortedIndex(const vector<int> &arr)\n    {\n        // Implement logic to find first unsorted index\n\n        for (int i = 0; i < arr.size() - 1; i++)\n        {\n            if (arr[i] > arr[i + 1])\n            {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n};",
      "output": "In the given input, elements from index 0 to 3 (1, 2, 3, 4) are in non-decreasing order. The element at index 4 is 6, which is followed by 5 at index 5, violating the non-decreasing order since 6 is greater than 5. Hence, index 4 is the first unsorted element.\nTry to identify this pattern and apply the logic to solve the problem for any given input array.\n-1\nExplanation:The array is already sorted.\n2\nExplanation:First unsorted element is at index 2 (30 > 25).\n0\nExplanation:First unsorted element is at index 0 (5 > 4).",
      "language": "cpp"
    },
    {
      "fileName": "Find Pivot Index-best.cpp",
      "name": "Find Pivot Index-best",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int prefixSumApproach(vector<int> &nums)\n    {\n\n        int n = nums.size();\n        vector<int> lsum(n, 0);\n        vector<int> rsum(n, 0);\n\n        // Left prefix sum\n        for (int i = 1; i < n; i++)\n        {\n            lsum[i] = lsum[i - 1] + nums[i - 1];\n        }\n\n        // Right prefix sum\n        for (int i = n - 2; i >= 0; i--)\n        {\n            rsum[i] = rsum[i + 1] + nums[i + 1];\n        }\n\n        // Check pivot index\n        for (int i = 0; i < n; i++)\n        {\n            if (lsum[i] == rsum[i])\n                return i;\n        }\n\n        return -1;\n    }\n\n    int pivotIndex(vector<int> &nums)\n    {\n        return prefixSumApproach(nums);\n    }\n};\n",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Find Pivot Index.cpp",
      "name": "Find Pivot Index",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nGiven an integer array nums, find the pivot index of this array.\n\nThe pivot index is defined as the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the right of the index.\n\nIf no such index exists, return -1. If there are multiple pivot indices, you should return the left-most pivot index.\n\nNotes:\nThe array may contain negative numbers and be either large or small.\nExample 1:\n\nInput:\n\nn=6 nums=[1,7,3,6,5,6]\n\nOutput:\n\n3\nExplanation:Left-sum (1 + 7 + 3) = 11 and right-sum (5 + 6) = 11 at index 3.\n\nExample 2:\n\nInput:\n\nn=3 nums=[2,1,-1]\n\nOutput:\n\n0\nExplanation:Left-sum = 0 and right-sum (1 + \u20131) = 0, so index 0 is the pivot.\n\nExample 3:\n\nInput:\n\nn=3 nums=[1,-1,0]\n\nOutput:\n\n2\nExplanation:Left-sum (1 + \u20131) = 0 and right-sum = 0 after index 2.\n\n*/\n\nclass Solution\n{\npublic:\n    int bruteforce(vector<int> &nums)\n    {\n        int n = nums.size();\n\n        for (int i = 0; i < n; i++)\n        {\n\n            int lsum = 0;\n            int rsum = 0;\n\n            // Left sum\n            for (int j = 0; j < i; j++)\n            {\n                lsum += nums[j];\n            }\n\n            // Right sum\n            for (int j = i + 1; j < n; j++)\n            {\n                rsum += nums[j];\n            }\n\n            // Compare\n            if (lsum == rsum)\n                return i;\n        }\n\n        return -1;\n    }\n\n    int pivotIndex(vector<int> &nums)\n    {\n        return bruteforce(nums);\n    }\n};\n\n// uper bale ki time complexity o(n2) hai jo ki jaida time legi ab hum new code likhnge jisme time complexity o(n) hogi\n\nclass PivotIndex\n{\npublic:\n    int pivotIndex(vector<int> &arr)\n    {\n        int totalSum = 0;\n\n        // Step 1: calculate total sum\n        for (int x : arr)\n            totalSum += x;\n\n        int leftSum = 0;\n\n        // Step 2: check pivot index\n        for (int i = 0; i < arr.size(); i++)\n        {\n            int rightSum = totalSum - leftSum - arr[i];\n\n            if (leftSum == rightSum)\n                return i;\n\n            leftSum += arr[i];\n        }\n\n        return -1;\n    }\n};\n\n// iski time complexity o(n) hai\n//  int rightSum = totalSum - leftSum - arr[i]; formula to find right sum\n// isse formule se  humara right sum nikalne ka loop bach gaya jisse humari time compelxtiy kam ho gayi",
      "output": "3\nExplanation:Left-sum (1 + 7 + 3) = 11 and right-sum (5 + 6) = 11 at index 3.\n0\nExplanation:Left-sum = 0 and right-sum (1 + \u20131) = 0, so index 0 is the pivot.\n2\nExplanation:Left-sum (1 + \u20131) = 0 and right-sum = 0 after index 2.",
      "language": "cpp"
    },
    {
      "fileName": "Find the Average of Array Elements.cpp",
      "name": "Find the Average of Array Elements",
      "code": "\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\nExample:\nSuppose you have an array: [2, 4, 6, 8]\n\nThe sum of the array elements is 2 + 4 + 6 + 8 = 20.\nThe number of elements in the array is 4.\nTherefore, the average is 20 / 4 = 5.0.\nYour task is to implement a function that calculates this average for any given array of integers.\n\nExample 1:\n\nInput:\n\nInput: arr = [2, 4, 6, 8, 10]\n\nOutput:\n\n6\nExplanation:Average of [2, 4, 6, 8, 10] is 6.\n\nExample 2:\n\nInput:\n\nInput: arr = [1, -1, 1, -1]\n\nOutput:\n\n0\nExplanation:Average of [1, -1, 1, -1] is 0.\n\nExample 3:\n\nInput:\n\nInput: arr = [5, 10, 15]\n\nOutput:\n\n10\nExplanation:Average of [5, 10, 15] is 10.\n\n*/\n\nclass Solution\n{\npublic:\n    double findAverage(const vector<int> &arr)\n    {\n        // Implement logic to find the average\n        double sum = 0;\n        int length = arr.size();\n        for (int i = 0; i < length; i++)\n        {\n            sum = sum + arr[i];\n        }\n\n        double avg = sum / length;\n        return avg;\n    }\n};",
      "output": "6\nExplanation:Average of [2, 4, 6, 8, 10] is 6.\n0\nExplanation:Average of [1, -1, 1, -1] is 0.\n10\nExplanation:Average of [5, 10, 15] is 10.",
      "language": "cpp"
    },
    {
      "fileName": "Find the Maximum Element in an Array.cpp",
      "name": "Find the Maximum Element in an Array",
      "code": "#include <limits.h>\n\n\n\n\n/*\n\nExample\nExample 1:\n\nInput:\n\n\narr = [1, 2, 3, 4, 5]\nOutput:\n\n\n5\nExplanation: The largest number in the array [1, 2, 3, 4, 5] is 5.\n\nExample 2:\n\nInput:\n\n\narr = [-1, -2, -3, -4, -5]\nOutput:\n\n\n-1\nExplanation: Even though all numbers are negative, -1 is the highest value in the array.\n\nApproach\nWhile handling the problem, ensure you iterate through the array and keep track of the current maximum element. It is necessary to update this maximum as you progress through the array.\n\nExample 1:\n\nInput:\n\nInput: arr = [1, 2, 3, 4, 5]\n\nOutput:\n\n5\nExplanation:The maximum element in the array is 5.\n\nExample 2:\n\nInput:\n\nInput: arr = [5, 4, 3, 2, 1]\n\nOutput:\n\n5\nExplanation:The maximum element is at the beginning.\n\nExample 3:\n\nInput:\n\nInput: arr = [10, 20, 5, 40, 30, 50]\n\nOutput:\n\n50\nExplanation:The maximum element is 50, appearing last.\n\n*/\n\n\n\n\n\nclass Solution {\npublic:\n  int findMaximum(vector<int> &arr) {\n    // Your code here\n    int size = arr.size();\n    int maximum = INT_MIN;\n    for (int i = 0; i < size; i++) {\n      maximum = max(maximum, arr[i]);\n    }\n    return maximum;\n  }\n};",
      "output": "5\nExplanation: The largest number in the array [1, 2, 3, 4, 5] is 5.\n-1\nExplanation: Even though all numbers are negative, -1 is the highest value in the array.\nApproach\nWhile handling the problem, ensure you iterate through the array and keep track of the current maximum element. It is necessary to update this maximum as you progress through the array.\n5\nExplanation:The maximum element in the array is 5.\n5\nExplanation:The maximum element is at the beginning.\n50\nExplanation:The maximum element is 50, appearing last.",
      "language": "cpp"
    },
    {
      "fileName": "Find the Mode of the Array.cpp",
      "name": "Find the Mode of the Array",
      "code": "\n#include<iostream>\n#include<vector>\n#include <algorithm>\n\nusing namespace std;\n\n\n/*\n\nExample\nExample 1:\nInput: [3, 3, 2, 1, 5, 1]\nOutput: 1\nExplanation: The numbers 3 and 1 both appear twice, but 1 is smaller than 3, so 1 is the mode.\n\nExample 2:\nInput: [7, 7, 7, 7, 8, 8]\nOutput: 7\nExplanation: The number 7 appears four times while 8 appears twice, making 7 the mode.\n\nExample 3:\nInput: [-1, -1, -2, -2, -3]\nOutput: -2\nExplanation: The numbers -1 and -2 both appear twice, but -2 is smaller than -1, so -2 is the mode.\n\nExample 1:\n\nInput:\n\nInput: arr = [1, 2, 2, 3, 3, 3]\n\nOutput:\n\n3\nExplanation:3 is the mode with the highest frequency.\n\nExample 2:\n\nInput:\n\nInput: arr = [4, 5, 5, 6, 6]\n\nOutput:\n\n5\nExplanation:5 and 6 have the same frequency, but 5 is smaller.\n\nExample 3:\n\nInput:\n\nInput: arr = [10, 10, 10, 20, 20]\n\nOutput:\n\n10\nExplanation:10 is the mode with the highest frequency.\n\n*/\n\n\n\n\nclass Solution {\npublic:\n  int findMode(const vector<int> &arr) {\n    // Implement logic to find mode\n    vector<int> v = arr;\n    sort(v.begin(), v.end());\n    int maxfreq = 1;\n    int mode = v[0];\n    int cf = 1;\n    int n = v.size();\n    for (int i = 1; i < n; i++) {\n      if (v[i] == v[i - 1]) {\n        cf++;\n      } else\n        cf = 1;\n      if (cf > maxfreq) {\n        // i got new winner\n        maxfreq = cf;\n        mode = v[i];\n      }\n    }\n    return mode;\n  }\n};",
      "output": "Explanation: The numbers 3 and 1 both appear twice, but 1 is smaller than 3, so 1 is the mode.\nExplanation: The number 7 appears four times while 8 appears twice, making 7 the mode.\nExplanation: The numbers -1 and -2 both appear twice, but -2 is smaller than -1, so -2 is the mode.\n3\nExplanation:3 is the mode with the highest frequency.\n5\nExplanation:5 and 6 have the same frequency, but 5 is smaller.\n10\nExplanation:10 is the mode with the highest frequency.",
      "language": "cpp"
    },
    {
      "fileName": "Find the Unique Element in an Array.cpp",
      "name": "Find the Unique Element in an Array",
      "code": "\n#include<iostream>\n#include<vector>\nusing namespace std;\n\n\n/*\n\nExample\nInput:\n\n\nnums = [2, 3, 5, 4, 5, 3, 4]\nOutput:\n\n\n2\nExplanation:\n\nIn the given array, every element appears twice except for the number 2. Thus, the output is 2, as it is the unique element.\n\nYour goal is to find this single non-repeating element effectively.\n\nExample 1:\n\nInput:\n\nInput: nums = [2, 3, 5, 3, 2]\n\nOutput:\n\n5\nExplanation:\n\nExample 2:\n\nInput:\n\nInput: nums = [1, 1, 2, 2, 3]\n\nOutput:\n\n3\nExplanation:\n\nExample 3:\n\nInput:\n\nInput: nums = [7]\n\nOutput:\n\n7\nExplanation:\n\n*/\n\n\n\nclass Solution {\npublic:\n  int findUniqueElement(vector<int> &nums) {\n    vector<int> n = nums;\n    int count = n.size();\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n      ans = ans ^ n[i];\n    }\n    return ans;\n  }\n};",
      "output": "2\nExplanation:\nIn the given array, every element appears twice except for the number 2. Thus, the output is 2, as it is the unique element.\nYour goal is to find this single non-repeating element effectively.\n5\nExplanation:\n3\nExplanation:\n7\nExplanation:",
      "language": "cpp"
    },
    {
      "fileName": "First Repeating Element.cpp",
      "name": "First Repeating Element",
      "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\n// gfg -> https://www.geeksforgeeks.org/problems/first-repeating-element4018/1\n\n/*\n\nGiven an array arr[], find the first repeating element. The element should occur more than once and the index of its first occurrence should be the smallest.\n\nNote:- The position you return should be according to 1-based indexing.\n\nExamples:\n\nInput: arr[] = [1, 5, 3, 4, 3, 5, 6]\nOutput: 2\nExplanation: 5 appears twice and its first appearance is at index 2 which is less than 3 whose first the occurring index is 3.\nInput: arr[] = [1, 2, 3, 4]\nOutput: -1\nExplanation: All elements appear only once so answer is -1.\n\n*/\n\nclass Solution\n{\npublic:\n    int firstRepeated(vector<int> &arr)\n    {\n        unordered_map<int, int> hash;\n        int n = arr.size();\n        for (int i = 0; i < n; i++)\n        {\n            hash[arr[i]]++;\n        }\n        for (int i = 0; i < n; i++)\n        {\n            if (hash[arr[i]] > 1)\n            {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n};\n\n// second solution without using unordered_map\n\nclass Solution\n{\npublic:\n    int firstRepeated(vector<int> &arr)\n    {\n        int n = arr.size();\n\n        int hash[100000] = {0}; // hash array (size as per constraint)\n\n        // frequency count\n        for (int i = 0; i < n; i++)\n        {\n            hash[arr[i]]++;\n        }\n\n        // first repeating element (1-based index)\n        for (int i = 0; i < n; i++)\n        {\n            if (hash[arr[i]] > 1)\n            {\n                return i + 1;\n            }\n        }\n\n        return -1;\n    }\n};\n",
      "output": "Explanation: 5 appears twice and its first appearance is at index 2 which is less than 3 whose first the occurring index is 3.\nExplanation: All elements appear only once so answer is -1.",
      "language": "cpp"
    },
    {
      "fileName": "Identify Elements with Highest and Lowest Frequency Separately.cpp",
      "name": "Identify Elements with Highest and Lowest Frequency Separately",
      "code": "\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n/*\n\nExample:\nInput:\n\n\n[4, 4, 1, 2, 2, 2, 3, 3, 3, 3]\nOutput:\n\n\nHighest Frequency Element: 3\nLowest Frequency Element: 1\nExplanation:\n\nIn the given array, the number 3 appears 4 times, which is the highest frequency. On the other hand, the number 1 appears only once, which is the lowest frequency. Even though 2 appears 3 times, 3 is the element with the highest frequency due to the higher count. When dealing with ties, choose the smallest number amongst the tied elements.\n\nExample 1:\n\nInput:\n\nInput: arr = [1, 2, 2, 3, 3, 3]\n\nOutput:\n\n{3,1}\nExplanation:3 is the mode with the highest frequency.\n\nExample 2:\n\nInput:\n\nInput: arr = [4, 5, 5,5, 6, 6]\n\nOutput:\n\n{5,4}\nExplanation:5 and 6 have the same frequency, but 5 is smaller.\n\nExample 3:\n\nInput:\n\nInput: arr = [10, 10, 10, 20, 20]\n\nOutput:\n\n{10,20}\nExplanation:10 is the mode with the highest frequency.\n\n\n\n*/\n\n#include <climits>\nclass Solution\n{\npublic:\n    int findMode(vector<int> &v)\n    {\n        // Implement logic to find mode\n        // vector<int> v = arr;\n        sort(v.begin(), v.end());\n        int maxfreq = 1;\n        int mode = v[0];\n        int cf = 1;\n        int n = v.size();\n        for (int i = 1; i < n; i++)\n        {\n            if (v[i] == v[i - 1])\n            {\n                cf++;\n            }\n            else\n                cf = 1;\n            if (cf > maxfreq)\n            {\n                // i got new winner\n                maxfreq = cf;\n                mode = v[i];\n            }\n        }\n        return mode;\n    }\n\n    int findlf(vector<int> &v)\n    {\n        // already sorted because by reference\n        int minFre = INT_MAX;\n        int least = v[0];\n        int cf = 1;\n\n        for (int i = 1; i < v.size(); i++)\n        {\n            if (v[i] == v[i - 1])\n                cf++;\n            else\n            {\n                if (cf < minFre)\n                {\n                    minFre = cf;\n                    least = v[i - 1];\n                }\n                cf = 1;\n            }\n        }\n\n        // do'not forget that last element could be the least\n        if (cf < minFre)\n        {\n            minFre = cf;\n            least = v[v.size() - 1];\n        }\n        return least;\n    }\n\n    pair<int, int> highestAndLowestFrequency(vector<int> &arr)\n    {\n        // Implement logic to find elements with highest and lowest frequency\n        int hf = findMode(arr);\n        int lf = findlf(arr);\n        return {hf, lf}; // Placeholder return; user will complete the logic\n    }\n};",
      "output": "Highest Frequency Element: 3\nLowest Frequency Element: 1\nExplanation:\nIn the given array, the number 3 appears 4 times, which is the highest frequency. On the other hand, the number 1 appears only once, which is the lowest frequency. Even though 2 appears 3 times, 3 is the element with the highest frequency due to the higher count. When dealing with ties, choose the smallest number amongst the tied elements.\n{3,1}\nExplanation:3 is the mode with the highest frequency.\n{5,4}\nExplanation:5 and 6 have the same frequency, but 5 is smaller.\n{10,20}\nExplanation:10 is the mode with the highest frequency.",
      "language": "cpp"
    },
    {
      "fileName": "Kth Smallest.cpp",
      "name": "Kth Smallest",
      "code": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// gfg->  https://www.geeksforgeeks.org/problems/kth-smallest-element5635/1\n\n/*\n\nExamples :\n\nInput: arr[] = [10, 5, 4, 3, 48, 6, 2, 33, 53, 10], k = 4\nOutput: 5\nExplanation: 4th smallest element in the given array is 5.\nInput: arr[] = [7, 10, 4, 3, 20, 15], k = 3\nOutput: 7\nExplanation: 3rd smallest element in the given array is 7.\n\n*/\n\nclass Solution\n{\npublic:\n    int kthSmallest(vector<int> &arr, int k)\n    {\n\n        sort(arr.begin(), arr.end());\n\n        return arr[k - 1];\n    }\n};",
      "output": "Explanation: 4th smallest element in the given array is 5.\nExplanation: 3rd smallest element in the given array is 7.",
      "language": "cpp"
    },
    {
      "fileName": "Max Sum Subarray of size K.cpp",
      "name": "Max Sum Subarray of size K",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nExamples:\n\nInput: arr[] = [100, 200, 300, 400], k = 2\nOutput: 700\nExplanation: arr2 + arr3 = 700, which is maximum.\nInput: arr[] = [1, 4, 2, 10, 23, 3, 1, 0, 20], k = 4\nOutput: 39\nExplanation: arr1 + arr2 + arr3 + arr4 = 39, which is maximum.\nInput: arr[] = [100, 200, 300, 400], k = 1\nOutput: 400\nExplanation: arr3 = 400, which is maximum.\n\n*/\n\nclass Solution\n{\npublic:\n    int maxSubarraySum(vector<int> &arr, int k)\n    {\n        // use sliding window technique\n        int n = arr.size();\n        int windowSum = 0;\n\n        for (int i = 0; i < k; i++)\n        {\n            windowSum += arr[i];\n        }\n\n        int maxSum = windowSum;\n\n        for (int i = k; i < n; i++)\n        {\n            windowSum = windowSum + arr[i] - arr[i - k];\n            maxSum = max(maxSum, windowSum);\n        }\n\n        return maxSum;\n    }\n};\n\n// notes->\n\n/*\n\n\ud83d\udd39 What is Sliding Window?\n\nSliding Window is a technique used on arrays/strings to handle continuous (contiguous) elements efficiently.\nInstead of recalculating again and again, we reuse previous results while moving the window step by step.\n\n\ud83d\udd39 Why do we need it?\n\n\u274c Brute Force \u2192 same work repeated \u2192 slow\n\u2705 Sliding Window \u2192 reuse sum/result \u2192 fast (O(n))\n\n\ud83d\udd39 Types of Sliding Window (VERY IMPORTANT)\n1\ufe0f\u20e3 Fixed Size Sliding Window\n\nWhen window size is already given (k fixed)\n\nExamples:\n\nMaximum sum of subarray of size k\n\nAverage of elements of size k\n\nCount of subarrays of size k\n\nCore Rule (Golden Formula):\n\nnew_window = old_window\n             + new_element\n             - removed_element\n\n\nSteps:\n\nFind sum of first k elements\n\nStore it as answer\n\nSlide window:\n\nAdd next element\n\nRemove first element\n\nUpdate answer\n\nTime: O(n)\nSpace: O(1)\n\n2\ufe0f\u20e3 Variable Size Sliding Window\n\nWhen size is NOT fixed, only condition is given\n\nExamples:\n\nSmallest subarray with sum \u2265 X\n\nLongest substring without repeating characters\n\nCore Idea:\n\nExpand window (right pointer \u27a1\ufe0f)\n\nIf condition breaks \u2192 shrink window (left pointer \u2b05\ufe0f)\n\n\ud83d\udd0d How to IDENTIFY Sliding Window Questions (EXAM TRICK)\n\u2705 Use Sliding Window when you see:\n\n\u2714 Array or String\n\u2714 Continuous / Contiguous words\n\u2714 Words like:\n\nsubarray\n\nsubstring\n\nwindow\n\nconsecutive\n\nsize k\n\nmaximum / minimum / longest / shortest\n\n\u274c Do NOT use Sliding Window when:\n\n\u2716 Elements are NOT continuous\n\u2716 Order doesn\u2019t matter\n\u2716 Question asks for pairs (\u2192 Two Sum / Hashing)\n\n*/",
      "output": "Explanation: arr2 + arr3 = 700, which is maximum.\nExplanation: arr1 + arr2 + arr3 + arr4 = 39, which is maximum.\nExplanation: arr3 = 400, which is maximum.",
      "language": "cpp"
    },
    {
      "fileName": "Maximum Average Subarray-Method-1.cpp",
      "name": "Maximum Average Subarray-Method-1",
      "code": "\n#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n/*\n\nExample 1:\n\nInput:\n\nnums=[1,12,-5,-6,50,3] k=4\n\nOutput:\n\n12.75\nExplanation:The subarray [12,-5,-6,50] has the maximum average 12.75.\n\nExample 2:\n\nInput:\n\nnums=[5] k=1\n\nOutput:\n\n5\nExplanation:Only one subarray possible; average is 5.0.\n\nExample 3:\n\nInput:\n\nnums=[-1,-12,-5,-6,-50] k=2\n\nOutput:\n\n-5.5\nExplanation:Subarray [-5,-6] gives average \u20135.5, highest among all pairs.\n\n*/\n\n#include <climits>\nclass Solution\n{\npublic:\n    double bruteForce(vector<int> &nums, int k)\n    {\n\n        int maxSum = INT_MIN;\n\n        for (int i = 0; i <= nums.size() - k; i++)\n        {\n            int sum = 0;\n            for (int j = i; j < i + k; j++)\n            {\n                sum += nums[j];\n            }\n            maxSum = max(maxSum, sum);\n        }\n\n        return maxSum / (double)k;\n    }\n\n    double findMaxAverage(vector<int> &nums, int k)\n    {\n        return bruteForce(nums, k);\n    }\n};\n",
      "output": "12.75\nExplanation:The subarray [12,-5,-6,50] has the maximum average 12.75.\n5\nExplanation:Only one subarray possible; average is 5.0.\n-5.5\nExplanation:Subarray [-5,-6] gives average \u20135.5, highest among all pairs.",
      "language": "cpp"
    },
    {
      "fileName": "Maximum Average Subarray-method-2.cpp",
      "name": "Maximum Average Subarray-method-2",
      "code": "#include<iostream>\n#include<vector>\n#include<climits>\nusing namespace std;\n",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Missing Elements From An Array With Duplicates.cpp",
      "name": "Missing Elements From An Array With Duplicates",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nGiven an array nums containing n integers where some elements may be duplicated and the integers are supposed to be in the range 1 to n, your task is to return the list of integers that are missing from the array.\n\nThe size of the array is n, and each integer in the array is between 1 and n inclusive.\n\nNote\nThe algorithm should ideally run in O(n) time and use O(1) additional space.\nExample 1:\n\nInput:\n\nn=8 nums=[4,3,2,7,8,2,3,1]\n\nOutput:\n\n5 6\nExplanation:Numbers 1\u20128 should all appear; 5 and 6 are absent while 2 and 3 are duplicated.\n\nExample 2:\n\nInput:\n\nn=4 nums=[1,2,3,4]\n\nExplanation:Array already contains each value 1\u20264 exactly once, so the result list is empty.\n\nExample 3:\n\nInput:\n\nn=4 nums=[2,2,2,2]\n\nOutput:\n\n1 3 4\nExplanation:Only 2 is present (four times); 1, 3, 4 are missing.\n\n*/\n\nclass Solution\n{\npublic:\n    vector<int> findDisappearedNumbers(vector<int> &nums)\n    {\n        vector<int> ans;\n        int n = nums.size();\n        for (int i = 0; i < n; i++)\n        {\n            int index = abs(nums[i]) - 1;\n            nums[index] = -abs(nums[index]);\n        }\n\n        for (int i = 0; i < n; i++)\n        {\n            if (nums[i] > 0)\n            {\n                ans.push_back(i + 1);\n            }\n        }\n\n        return ans;\n    }\n};",
      "output": "5 6\nExplanation:Numbers 1\u20128 should all appear; 5 and 6 are absent while 2 and 3 are duplicated.\n1 3 4\nExplanation:Only 2 is present (four times); 1, 3, 4 are missing.",
      "language": "cpp"
    },
    {
      "fileName": "Missing Number.cpp",
      "name": "Missing Number",
      "code": "\n#include<iostream>\n#include<vector>\nusing namespace std;\n\n/*\n\nNote:\nTry to implement an algorithm with a linear runtime complexity.\n\nExample 1:\n\nInput:\n\nn=3 nums=[3,0,1]\n\nOutput:\n\n2\nExplanation:The range should contain {0,1,2,3}. Only 2 is absent.\n\nExample 2:\n\nInput:\n\nn=4 nums=[1,2,3,4]\n\nOutput:\n\n0\nExplanation:Numbers present are {1,2,3,4}; 0 is missing.\n\nExample 3:\n\nInput:\n\nn=4 nums=[0,1,2,3]\n\nOutput:\n\n4\nExplanation:Expected range is {0,1,2,3,4}; 4 is not present.\n\n\n*/\n\n\nclass Solution {\npublic:\n  int missingNumber(vector<int> &nums) {\n    int n = nums.size();\n    int total = n * (n + 1) / 2;\n    int sum = 0;\n\n    for (int i = 0; i < n; i++) {\n      sum += nums[i];\n    }\n\n    return total - sum;\n  }\n};\n",
      "output": "2\nExplanation:The range should contain {0,1,2,3}. Only 2 is absent.\n0\nExplanation:Numbers present are {1,2,3,4}; 0 is missing.\n4\nExplanation:Expected range is {0,1,2,3,4}; 4 is not present.",
      "language": "cpp"
    },
    {
      "fileName": "Multiply Each Element of an Array by 10.cpp",
      "name": "Multiply Each Element of an Array by 10",
      "code": "\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\n/*\n\nExample\nExample 1:\nInput: arr = [1, 2, 3, 4, 5]\nOutput: [10, 20, 30, 40, 50]\nExplanation: Each element of the array [1, 2, 3, 4, 5] is multiplied by 10, resulting in the array [10, 20, 30, 40, 50].\n\nExample 2:\nInput: arr = [0, -1, -100]\nOutput: [0, -10, -1000]\nExplanation: The elements of the array [0, -1, -100] are multiplied by 10, resulting in [0, -10, -1000].\n\nTask\nWrite a function that takes an integer array and returns a new array with each element multiplied by 10.\n\nExample 1:\n\nInput:\n\nInput: arr = [1, 2, 3, 4, 5]\n\nOutput:\n\n[10, 20, 30, 40, 50]\nExplanation:Each element is multiplied by 10.\n\nExample 2:\n\nInput:\n\nInput: arr = [0, -1, -2, 3, 4]\n\nOutput:\n\n[0, -10, -20, 30, 40]\nExplanation:Negative and zero values also get multiplied correctly.\n\nExample 3:\n\nInput:\n\nInput: arr = [10, 20, 30]\n\nOutput:\n\n[100, 200, 300]\nExplanation:All numbers are multiplied by 10.\n\n*/\n\n\n\nvector<int> multiplyByTen(const vector<int> &arr) {\n  // Start completing the function\n  vector<int> arrCopy = arr;\n  int size = arrCopy.size();\n\n  for (int i = 0; i < size; i++) {\n\n    arrCopy[i] = arrCopy[i] * 10;\n  }\n  return arrCopy;\n}",
      "output": "Explanation: Each element of the array [1, 2, 3, 4, 5] is multiplied by 10, resulting in the array [10, 20, 30, 40, 50].\nExplanation: The elements of the array [0, -1, -100] are multiplied by 10, resulting in [0, -10, -1000].\nTask\nWrite a function that takes an integer array and returns a new array with each element multiplied by 10.\n[10, 20, 30, 40, 50]\nExplanation:Each element is multiplied by 10.\n[0, -10, -20, 30, 40]\nExplanation:Negative and zero values also get multiplied correctly.\n[100, 200, 300]\nExplanation:All numbers are multiplied by 10.",
      "language": "cpp"
    },
    {
      "fileName": "Print Extreme Elements Alternately.cpp",
      "name": "Print Extreme Elements Alternately",
      "code": "\n#include<iostream>\n#include<vector>\n#include <algorithm>\nusing namespace std;\n\n/*\n\nExample\nInput:\n\n\n[1, 3, 2, 4, 5]\nOutput:\n\n\n1 5 2 4 3\nExplanation:\n\nSorting the array gives: [1, 2, 3, 4, 5].\nStart by picking the smallest element (1), then the largest element (5).\nContinue by picking the next smallest (2) and the next largest (4).\nFinally, pick the remaining element (3).\nYour goal is to implement this alternating order display in a function that operates efficiently even for larger arrays.\n\nExample 1:\n\nInput:\n\nInput: arr = [1, 2, 3, 4, 5]\n\nOutput:\n\n1 5 2 4 3\nExplanation:Sorted array: [1,2,3,4,5]. Start with smallest (1), then largest (5), then second smallest (2), second largest (4), and finally the middle element (3).\n\nExample 2:\n\nInput:\n\nInput: arr = [5, 4, 3, 2, 1]\n\nOutput:\n\n1 5 2 4 3\nExplanation:The array gets sorted first to [1,2,3,4,5], then processed in the same manner.\n\nExample 3:\n\nInput:\n\nInput: arr = [10, 20, 30, 40, 50, 60]\n\nOutput:\n\n10 60 20 50 30 40\nExplanation:Start from smallest (10), largest (60), second smallest (20), second largest (50), etc.\n\n*/\n\n\n\nclass Solution {\npublic:\n  vector<int> printExtremeElementsAlternately(vector<int> &arr) {\n    sort(arr.begin(), arr.end());\n    int n = arr.size();\n    vector<int> ans;\n    int i = 0;\n    int j = n - 1;\n    while (i <= j) {\n      ans.push_back(arr[i]);\n      ans.push_back(arr[j]);\n      i++;\n      j--;\n    }\n    return ans;\n  }\n};",
      "output": "1 5 2 4 3\nExplanation:\nSorting the array gives: [1, 2, 3, 4, 5].\nStart by picking the smallest element (1), then the largest element (5).\nContinue by picking the next smallest (2) and the next largest (4).\nFinally, pick the remaining element (3).\nYour goal is to implement this alternating order display in a function that operates efficiently even for larger arrays.\n1 5 2 4 3\nExplanation:Sorted array: [1,2,3,4,5]. Start with smallest (1), then largest (5), then second smallest (2), second largest (4), and finally the middle element (3).\n1 5 2 4 3\nExplanation:The array gets sorted first to [1,2,3,4,5], then processed in the same manner.\n10 60 20 50 30 40\nExplanation:Start from smallest (10), largest (60), second smallest (20), second largest (50), etc.",
      "language": "cpp"
    },
    {
      "fileName": "Print the Sum of Each Column in a 2D Array.cpp",
      "name": "Print the Sum of Each Column in a 2D Array",
      "code": "\n#include<iostream>\n#include<vector>\nusing namespace std;\n\n/*\n\nInput:\n\n\nMatrix: [[1, 2, 3],\n         [4, 5, 6],\n         [7, 8, 9]]\nOutput:\n\n\n[12, 15, 18]\nExplanation:\n\nSum of 1st column: 1 + 4 + 7 = 12\nSum of 2nd column: 2 + 5 + 8 = 15\nSum of 3rd column: 3 + 6 + 9 = 18\nThe function should be versatile enough to handle matrices of different sizes, with restrictions given in the constraints.\n\nAdditional Example\nInput:\n\n\nMatrix: [[1, 2],\n         [3, 4],\n         [5, 6]]\nOutput:\n\n\n[9, 12]\nExplanation:\n\nSum of 1st column: 1 + 3 + 5 = 9\nSum of 2nd column: 2 + 4 + 6 = 12\nExample 1:\n\nInput:\n\nInput: matrix = [[1, 2, 3], [4, 5, 6]]\n\nOutput:\n\n5,7,9\nExplanation:\n\nExample 2:\n\nInput:\n\nInput: matrix = [[7, 8], [9, 10], [11, 12]]\n\nOutput:\n\n27,30\nExplanation:\n\nExample 3:\n\nInput:\n\nInput: matrix = [[1, 2], [3, 4]]\n\nOutput:\n\n4,6\nExplanation:\n\n\n*/\n\n\nstd::vector<int> columnSums(const std::vector<std::vector<int>>& matrix) {\n    // Implement the logic to compute the sum of each column here\n    vector<int>ans;\n    int n=matrix.size();\n    int m=matrix[0].size();\n    for(int i=0;i<m;i++){\n        int sum=0;\n        for(int j=0;j<n;j++){\n                 sum=sum+matrix[j][i];\n        }\n     ans.push_back(sum);\n    }\n    return ans;\n}",
      "output": "[12, 15, 18]\nExplanation:\nSum of 1st column: 1 + 4 + 7 = 12\nSum of 2nd column: 2 + 5 + 8 = 15\nSum of 3rd column: 3 + 6 + 9 = 18\nThe function should be versatile enough to handle matrices of different sizes, with restrictions given in the constraints.\n[9, 12]\nExplanation:\nSum of 1st column: 1 + 3 + 5 = 9\nSum of 2nd column: 2 + 4 + 6 = 12\n5,7,9\nExplanation:\n27,30\nExplanation:\n4,6\nExplanation:",
      "language": "cpp"
    },
    {
      "fileName": "Print the Sum of Each Row in a 2D Array.cpp",
      "name": "Print the Sum of Each Row in a 2D Array",
      "code": "\n\n\n\n/*\n\n\nExample\nInput:\n\narr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nOutput:\n\n[6, 15, 24]\n\nExplanation:\n\nThe sum of the first row is 1 + 2 + 3 = 6.\nThe sum of the second row is 4 + 5 + 6 = 15.\nThe sum of the third row is 7 + 8 + 9 = 24.\nTherefore, the output is [6, 15, 24].\n\nAdditional Example\nInput:\n\narr = [[1], [2, 2], [3, 3, 3]]\n\nOutput:\n\n[1, 4, 9]\n\nExplanation:\n\nThe sum of the first row is 1.\nThe sum of the second row is 2 + 2 = 4.\nThe sum of the third row is 3 + 3 + 3 = 9.\nThus, the resulting output is [1, 4, 9].\n\nExample 1:\n\nInput:\n\nInput: arr = [[1, 2, 3], [4, 5, 6]]\n\nOutput:\n\n6,15\nExplanation:\n\nExample 2:\n\nInput:\n\nInput: arr = [[7, 8], [9, 10], [11, 12]]\n\nOutput:\n\n15,19,23\nExplanation:\n\nExample 3:\n\nInput:\n\nInput: arr = [[1, 2], [3, 4]]\n\nOutput:\n\n3,7\nExplanation:\n\n\n\n*/\n\n\n#include <vector>\n\nstd::vector<int> rowSums(const std::vector<std::vector<int>>& arr) {\n    std::vector<int> ans;\n    int n = arr.size(); \n    for (int i = 0; i < n; i++) {\n        int sum = 0;\n        for (int j = 0; j < arr[i].size(); j++) { // columns of row i\n            sum += arr[i][j];\n        }\n        ans.push_back(sum);\n    }\n    return ans;\n}\n",
      "output": "[6, 15, 24]\nExplanation:\nThe sum of the first row is 1 + 2 + 3 = 6.\nThe sum of the second row is 4 + 5 + 6 = 15.\nThe sum of the third row is 7 + 8 + 9 = 24.\nTherefore, the output is [6, 15, 24].\n[1, 4, 9]\nExplanation:\nThe sum of the first row is 1.\nThe sum of the second row is 2 + 2 = 4.\nThe sum of the third row is 3 + 3 + 3 = 9.\nThus, the resulting output is [1, 4, 9].\n6,15\nExplanation:\n15,19,23\nExplanation:\n3,7\nExplanation:",
      "language": "cpp"
    },
    {
      "fileName": "Print-All-SubArrays-of-a-Array-Using-Recursion.cpp",
      "name": "Print-All-SubArrays-of-a-Array-Using-Recursion",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid printSubarray_util(vector<int> &nums, int start, int end) {\n    // base case\n    if (end == nums.size()) {\n        return;\n    }\n\n    \n    // 1 case solution\n    for (int i = start; i <= end; i++) {\n        cout << nums[i] << \" \";\n    }\n    cout << endl;\n\n    // recursive call\n    printSubarray_util(nums, start, end + 1);\n}\n\nvoid printSubarray(vector<int> &nums) {\n    for (int start = 0; start < nums.size(); start++) {\n        int end = start;\n        printSubarray_util(nums, start, end);\n    }\n}\n\nint main() {\n    vector<int> nums {1, 2, 3, 4, 5};\n    printSubarray(nums);\n    return 0;\n}",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Remove Duplicates From Sorted Array.cpp",
      "name": "Remove Duplicates From Sorted Array",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nProblem Description\nGiven a sorted array of integers nums, remove the duplicates in-place such that each unique element appears only once. The order of elements should be maintained, and you must do this using O(1) extra memory, meaning the input array itself should be modified to store the results. You may consider that the function should return the new length of the array after duplicates have been removed.\n\nNote:\nDo not allocate extra space for another array; you must do this by modifying the input array in-place with O(1) extra memory.\nExample 1:\n\nInput:\n\nn=1 nums=[10]\n\nOutput:\n\n1\nExplanation:Only one element remains; length is 1.\n\nExample 2:\n\nInput:\n\nn=4 nums=[0,0,0,0]\n\nOutput:\n\n1\nExplanation:After removing duplicates only one 0 stays \u2192 length 1.\n\nExample 3:\n\nInput:\n\nn=5 nums=[1,2,3,4,5]\n\nOutput:\n\n5\nExplanation:No duplicates removed \u2192 length 5.\n\n*/\n\nclass Solution\n{\npublic:\n    int removeDuplicates(vector<int> &nums)\n    {\n        // Implement logic here\n        int i = 1, j = 0;\n        // two pointers approach\n        while (i < nums.size())\n        {\n            if (nums[i] == nums[j])\n            {\n                i++;\n            }\n            else\n            {\n                j++;\n                nums[j] = nums[i];\n                i++;\n            }\n        }\n        return j + 1;\n    }\n};",
      "output": "1\nExplanation:Only one element remains; length is 1.\n1\nExplanation:After removing duplicates only one 0 stays \u2192 length 1.\n5\nExplanation:No duplicates removed \u2192 length 5.",
      "language": "cpp"
    },
    {
      "fileName": "Reverse a Vector.cpp",
      "name": "Reverse a Vector",
      "code": "\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n/*\n\nExample 1:\n\nInput:\n\nInput: arr = [1, 2, 3, 4, 5]\n\nOutput:\n\n[5, 4, 3, 2, 1]\nExplanation:The array is reversed to [5, 4, 3, 2, 1].\n\nExample 2:\n\nInput:\n\nInput: arr = [10, 20, 30]\n\nOutput:\n\n[30, 20, 10]\nExplanation:The array is reversed to [30, 20, 10].\n\nExample 3:\n\nInput:\n\nInput: arr = [-1, -2, -3]\n\nOutput:\n\n[-3, -2, -1]\nExplanation:The array is reversed to [-3, -2, -1].\n\n*/\n\nclass Solution\n{\npublic:\n  vector<int> reverseArray(const vector<int> &arr)\n  {\n    // Implement logic to reverse the array\n    vector<int> rev = arr;\n    int n = arr.size();\n    int i = 0;\n    int j = n - 1;\n\n    while (i <= j)\n    {\n      swap(rev[i], rev[j]);\n      i++;\n      j--;\n    }\n    return rev;\n  }\n};",
      "output": "[5, 4, 3, 2, 1]\nExplanation:The array is reversed to [5, 4, 3, 2, 1].\n[30, 20, 10]\nExplanation:The array is reversed to [30, 20, 10].\n[-3, -2, -1]\nExplanation:The array is reversed to [-3, -2, -1].",
      "language": "cpp"
    },
    {
      "fileName": "Rotate an Array.cpp",
      "name": "Rotate an Array",
      "code": "\n\n\n\n/*\n\nExample\nExample 1:\nInput:\n\nnums = [1, 2, 3, 4, 5, 6, 7], k = 3\n\nOutput:\n\n[5, 6, 7, 1, 2, 3, 4]\n\nExplanation:\n\nRotating the array to the right by 3 steps produces the array [5, 6, 7, 1, 2, 3, 4]. Elements are moved to the right, and the trailing elements are repositioned at the beginning of the array.\nExample 2:\nInput:\n\nnums = [-1, -100, 3, 99], k = 2\n\nOutput:\n\n[3, 99, -1, -100]\n\nExplanation:\n\nRotating the array to the right by 2 steps results in [3, 99, -1, -100]. The elements at the end wrap around to the start of the array.\nNote\nThe number of rotations exceeds the array length in some cases. Take into consideration that rotating the array n times results in the same arrangement as rotating it n % length of array times, thus simplifying the problem.\nExample 1:\n\nInput:\n\nInput: nums = [1, 2, 3, 4, 5, 6, 7], k = 3\n\nOutput:\n\n[5, 6, 7, 1, 2, 3, 4]\nExplanation:\n\nExample 2:\n\nInput:\n\nInput: nums = [-1, -100, 3, 99], k = 2\n\nOutput:\n\n[3, 99, -1, -100]\nExplanation:\n\nExample 3:\n\nInput:\n\nInput: nums = [1, 2, 3, 4, 5], k = 1\n\nOutput:\n\n[5, 1, 2, 3, 4]\nExplanation:\n\n*/\n\nclass Solution {\npublic:\n  void rotate(vector<int> &nums, int k) {\n    // step1- temp me array ko store kr lo\n\n    int n = nums.size();\n    k = k % n;\n    vector<int> temp;\n    for (int i = n - k; i <= n - 1; i++) {\n      int value = nums[i];\n      temp.push_back(value);\n    }\n    // step 2 me shift loop\n    for (int i = n - 1; i >= 0; i--) {\n      if (i - k >= 0) {\n        nums[i] = nums[i - k];\n      }\n    }\n    // step 3 me copy form temp array\n    for (int i = 0; i < k; i++) {\n      nums[i] = temp[i];\n    }\n  }\n};",
      "output": "[5, 6, 7, 1, 2, 3, 4]\nExplanation:\nRotating the array to the right by 3 steps produces the array [5, 6, 7, 1, 2, 3, 4]. Elements are moved to the right, and the trailing elements are repositioned at the beginning of the array.\n[3, 99, -1, -100]\nExplanation:\nRotating the array to the right by 2 steps results in [3, 99, -1, -100]. The elements at the end wrap around to the start of the array.\nNote\nThe number of rotations exceeds the array length in some cases. Take into consideration that rotating the array n times results in the same arrangement as rotating it n % length of array times, thus simplifying the problem.\n[5, 6, 7, 1, 2, 3, 4]\nExplanation:\n[3, 99, -1, -100]\nExplanation:\n[5, 1, 2, 3, 4]\nExplanation:",
      "language": "cpp"
    },
    {
      "fileName": "Rotate by 90 degree.cpp",
      "name": "Rotate by 90 degree",
      "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n/*\n\nGiven a square matrix mat[][] of size n x n. The task is to rotate it by 90 degrees in an anti-clockwise direction without using any extra space.\n\nExamples:\n\nInput: mat[][] = [[0, 1, 2],\n                [3, 4, 5],\n                [6, 7, 8]]\nOutput: [[2, 5, 8],\n        [1, 4, 7],\n        [0, 3, 6]]\nInput: mat[][] = [[1, 2],\n                [3, 4]]\nOutput: [[2, 4],\n        [1, 3]]\n\n*/\n\n// rotate by 90 degree   anticlock wise\nclass Solution\n{\npublic:\n    void rotateMatrix(vector<vector<int>> &matrix)\n    {\n        int n = matrix.size();\n\n        // Transepose of a matrix\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = i; j < n; j++)\n            {\n                swap(matrix[i][j], matrix[j][i]);\n            }\n        }\n\n        // Matrix ko 90 degree anticlockwise rotate karne ke liye column-wise swap kar rahe hain\n\n        for (int j = 0; j < n; j++)\n        {\n            int top = 0, bottom = n - 1;\n            while (top < bottom)\n            {\n                swap(matrix[top][j], matrix[bottom][j]);\n                top++;\n                bottom--;\n            }\n        }\n    }\n};\n",
      "output": "[1, 4, 7],\n[0, 3, 6]]\n[1, 3]]",
      "language": "cpp"
    },
    {
      "fileName": "Rotate image.cpp",
      "name": "Rotate image",
      "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n/*\n\nExample 1:\n\nInput: N=4, matrix=[[7263,3483,9154,62], [5944,8721,5154,9591], [9752,1696,6616,3170], [5287,7014,7885,2554]]\n\nOutput: 5287 9752 5944 7263 7014 1696 8721 3483 7885 6616 5154 9154 2554 3170 9591 62\n\nExample 2:\n\nInput: N=3, matrix=[[1,2,3], [4,5,6], [7,8,9]]\n\nOutput: 7 4 1 8 5 2 9 6 3\n\nExample 3:\n\nInput: N=2, matrix=[[5745,3299], [3381,5838]]\n\nOutput: 3381 5745 5838 3299\n\n*/\n\n// rotate matrix clock wise\n\nclass Solution\n{\npublic:\n    void rotate90Clockwise(vector<vector<int>> &matrix, int N)\n    {\n        int n = matrix.size();\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = i; j < n; j++)\n            {\n                swap(matrix[i][j], matrix[j][i]);\n            }\n        }\n        // reverse of code\n        for (int i = 0; i < n; i++)\n        {\n            reverse(matrix[i].begin(), matrix[i].end());\n        }\n    }\n};\n",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Search for an Element in an Array.cpp",
      "name": "Search for an Element in an Array",
      "code": "\n\n/*\n\nExample:\nInput:\n\nnums = [4, 2, 7, 1, 9, 3]\ntarget = 7\n\nOutput:\n\n2\n\nExplanation: The target 7 is located at index 2 in the array.\n\nInput:\n\nnums = [5, 8, 6, 3]\ntarget = 2\n\nOutput:\n\n-1\n\nExplanation: The target 2 is not present in the array, hence the output is -1.\n\nExample 1:\n\nInput:\n\nInput: nums = [1, 2, 3, 4, 5], target = 3\n\nOutput:\n\n2\nExplanation:Element 3 is found at index 2.\n\nExample 2:\n\nInput:\n\nInput: nums = [10, 20, 30, 40, 50], target = 50\n\nOutput:\n\n4\nExplanation:Element 50 is found at index 4.\n\nExample 3:\n\nInput:\n\nInput: nums = [7, 8, 9, 10, 11], target = 5\n\nOutput:\n\n-1\nExplanation:Element 5 is not present in the array.\n\n*/\n\nint searchElementInArray(vector<int> &nums, int target) {\n  // Implement the logic to search for an element in the array\n  // Placeholder return\n\n  int size = nums.size();\n\n  for (int i = 0; i < size; i++) {\n    int value = nums[i];\n    if (value == target) {\n      return i;\n    }\n  }\n  return -1;\n}\n",
      "output": "2\nExplanation: The target 7 is located at index 2 in the array.\n-1\nExplanation: The target 2 is not present in the array, hence the output is -1.\n2\nExplanation:Element 3 is found at index 2.\n4\nExplanation:Element 50 is found at index 4.\n-1\nExplanation:Element 5 is not present in the array.",
      "language": "cpp"
    },
    {
      "fileName": "Second Largest.cpp",
      "name": "Second Largest",
      "code": "\n#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n/*\n\nExamples:\n\nInput: arr[] = [12, 35, 1, 10, 34, 1]\nOutput: 34\nExplanation: The largest element of the array is 35 and the second largest element is 34.\nInput: arr[] = [10, 5, 10]\nOutput: 5\nExplanation: The largest element of the array is 10 and the second largest element is 5.\nInput: arr[] = [10, 10, 10]\nOutput: -1\nExplanation: The largest element of the array is 10 and the second largest element does not exist.\n\n\n*/\n\nclass Solution\n{\npublic:\n    int getSecondLargest(vector<int> &arr)\n    {\n\n        int n = arr.size();\n        int largest = INT_MIN;\n        int secondLargest = INT_MIN;\n        for (int i = 0; i < n; i++)\n        {\n            if (arr[i] > largest)\n            {\n                largest = arr[i];\n            }\n        }\n        for (int i = 0; i < n; i++)\n        {\n            if (arr[i] != largest)\n            {\n                if (arr[i] > secondLargest)\n                {\n                    secondLargest = arr[i];\n                }\n            }\n        }\n        if (secondLargest == INT_MIN)\n        {\n            return -1;\n        }\n\n        return secondLargest;\n    }\n};",
      "output": "Explanation: The largest element of the array is 35 and the second largest element is 34.\nExplanation: The largest element of the array is 10 and the second largest element is 5.\nExplanation: The largest element of the array is 10 and the second largest element does not exist.",
      "language": "cpp"
    },
    {
      "fileName": "Shift Array Elements by One Position.cpp",
      "name": "Shift Array Elements by One Position",
      "code": "\n\n/*\n\nExample 1:\n\nInput:\n\nInput: arr = [1]\n\nOutput:\n\n[1]\nExplanation:A single-element array remains the same after shifting.\n\nExample 2:\n\nInput:\n\nInput: arr = [1, 2]\n\nOutput:\n\n[2, 1]\nExplanation:Array with two elements shifted by one position.\n\nExample 3:\n\nInput:\n\nInput: arr = [1, 2, 3]\n\nOutput:\n\n[3, 1, 2]\nExplanation:Array shifted by one position.\n\n\n*/\n\n\nclass Solution {\npublic:\n  vector<int> shiftRight(const vector<int> &arr) {\n    // Implement logic to shift array elements by one position\n    vector<int> arr2 = arr;\n    int n = arr2.size();\n    int lastelement = arr2[n - 1];\n\n    for (int i = n - 1; i >= 0; i--) {\n      if (i != 0) {\n        arr2[i] = arr2[i - 1];\n      } else {\n        arr2[0] = lastelement;\n      }\n    }\n    return arr2;\n  }\n};\n\n",
      "output": "[1]\nExplanation:A single-element array remains the same after shifting.\n[2, 1]\nExplanation:Array with two elements shifted by one position.\n[3, 1, 2]\nExplanation:Array shifted by one position.",
      "language": "cpp"
    },
    {
      "fileName": "Sort an Array of 0s and 1s.cpp",
      "name": "Sort an Array of 0s and 1s",
      "code": "\n\n/*\n\nExample\nExample 1:\nInput:\n\nn = 6\narr = [0, 1, 0, 1, 0, 1]\n\nOutput:\n\n[0, 0, 0, 1, 1, 1]\n\nExplanation: The input array [0, 1, 0, 1, 0, 1] is rearranged such that all 0s appear before all 1s, resulting in the array [0, 0, 0, 1, 1, 1].\n\nInstructions\nImplement a function that takes an integer array containing only 0s and 1s, and returns a new sorted array where all 0s appear before all 1s.\nThe function should operate in linear time, making it suitable for handling very large arrays.\nExample 1:\n\nInput:\n\nInput: nums = [0, 1, 0, 1, 0, 1]\n\nOutput:\n\n[0, 0, 0, 1, 1, 1]\nExplanation:\n\nExample 2:\n\nInput:\n\nInput: nums = [1, 1, 1, 0, 0, 0]\n\nOutput:\n\n[0, 0, 0, 1, 1, 1]\nExplanation:\n\nExample 3:\n\nInput:\n\nInput: nums = [0, 0, 0, 0, 0]\n\nOutput:\n\n[0, 0, 0, 0, 0]\nExplanation:\n\n*/\n\n\n\n\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n  vector<int> sortArray(vector<int> &nums) {\n    int totalzero = 0;\n    int totalones = 0;\n    vector<int> copy = nums;\n    int n = nums.size();\n    for (int i = 0; i < n; i++) {\n      if (nums[i] == 0) {\n        totalzero++;\n      } else {\n        totalones++;\n      }\n    }\n    fill(copy.begin(), copy.begin() + totalzero, 0);\n    fill(copy.begin() + totalzero, copy.end(), 1);\n\n\n    return copy; \n  }\n};\n",
      "output": "[0, 0, 0, 1, 1, 1]\nExplanation: The input array [0, 1, 0, 1, 0, 1] is rearranged such that all 0s appear before all 1s, resulting in the array [0, 0, 0, 1, 1, 1].\nInstructions\nImplement a function that takes an integer array containing only 0s and 1s, and returns a new sorted array where all 0s appear before all 1s.\nThe function should operate in linear time, making it suitable for handling very large arrays.\n[0, 0, 0, 1, 1, 1]\nExplanation:\n[0, 0, 0, 1, 1, 1]\nExplanation:\n[0, 0, 0, 0, 0]\nExplanation:",
      "language": "cpp"
    },
    {
      "fileName": "Spirally traversing a matrix.cpp",
      "name": "Spirally traversing a matrix",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nExample 1:\n\nInput:\n\nm=3 n=3 matrix=[[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n\n1 4 7 8 5 2 3 6 9\nExplanation:Wave order (col-wise): 1 4 7 \u2193, then 8 5 2 \u2191, then 3 6 9 \u2193.\n\nExample 2:\n\nInput:\n\nm=3 n=4 matrix=[[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n\nOutput:\n\n1 5 9 10 6 2 3 7 11 12 8 4\nExplanation:Even columns top\u2192bottom, odd columns bottom\u2192top.\n\nExample 3:\n\nInput:\n\nm=1 n=5 matrix=[[1,2,3,4,5]]\n\nOutput:\n\n1 2 3 4 5\nExplanation:Only one row, so wave is left-to-right.\n\n*/\n\nclass Solution\n{\npublic:\n    vector<int> spiralOrder(vector<vector<int>> &matrix)\n    {\n        int n = matrix.size();\n        int m = matrix[0].size();\n\n        int startingrow = 0, startingcolm = 0;\n        int endingrow = n - 1, endingcolm = m - 1;\n\n        vector<int> ans;\n\n        while (startingrow <= endingrow && startingcolm <= endingcolm)\n        {\n            // startingrow print\n            if (startingrow <= endingrow)\n            {\n                for (int col = startingcolm; col <= endingcolm; col++)\n                {\n                    ans.push_back(matrix[startingrow][col]);\n                }\n                startingrow++;\n            }\n\n            // endingcolm print\n            if (startingcolm <= endingcolm)\n            {\n                for (int row = startingrow; row <= endingrow; row++)\n                {\n                    ans.push_back(matrix[row][endingcolm]);\n                }\n                endingcolm--;\n            }\n\n            // endingrow print\n            if (startingrow <= endingrow)\n            {\n                for (int col = endingcolm; col >= startingcolm; col--)\n                {\n                    ans.push_back(matrix[endingrow][col]);\n                }\n                endingrow--;\n            }\n\n            // startingcolm print\n            if (startingcolm <= endingcolm)\n            {\n                for (int row = endingrow; row >= startingrow; row--)\n                {\n                    ans.push_back(matrix[row][startingcolm]);\n                }\n                startingcolm++;\n            }\n        }\n        return ans;\n    }\n};",
      "output": "1 4 7 8 5 2 3 6 9\nExplanation:Wave order (col-wise): 1 4 7 \u2193, then 8 5 2 \u2191, then 3 6 9 \u2193.\n1 5 9 10 6 2 3 7 11 12 8 4\nExplanation:Even columns top\u2192bottom, odd columns bottom\u2192top.\n1 2 3 4 5\nExplanation:Only one row, so wave is left-to-right.",
      "language": "cpp"
    },
    {
      "fileName": "Three Sum.cpp",
      "name": "Three Sum",
      "code": "\n#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n\n/*\n\nExample 1:\n\nInput:\n\nInput: nums = [-1, 0, 1, 2, -1, -4]\n\nOutput:\n\n[[-1, -1, 2], [-1, 0, 1]]\nExplanation:\n\nExample 2:\n\nInput:\n\nInput: nums = [0, 1, 1]\n\nOutput:\n\n[]\nExplanation:\n\nExample 3:\n\nInput:\n\nInput: nums = [0, 0, 0]\n\nOutput:\n\n[[0, 0, 0]]\nExplanation:\n\n\n\n*/\n\nclass Solution {\npublic:\n  vector<vector<int>> threeSum(vector<int> &nums) {\n    // Implementation will go here\n    vector<vector<int>> ans;\n    int n = nums.size();\n\n    // do sort before hand\n    sort(nums.begin(), nums.end());\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && nums[i] == nums[i - 1]) {\n        continue;\n      }\n      for (int j = i + 1; j < n; j++) {\n        if (j > i + 1 && nums[j] == nums[j - 1]) {\n          continue;\n        }\n        for (int k = j + 1; k < n; k++) {\n          if (k > j + 1 && nums[k] == nums[k - 1]) {\n            continue;\n          }\n          int first = nums[i];\n          int second = nums[j];\n          int third = nums[k];\n          int sum = first + second + third;\n          if (sum == 0) {\n            vector<int> temp;\n            temp.push_back(first);\n            temp.push_back(second);\n            temp.push_back(third);\n            ans.push_back(temp);\n          }\n        }\n      }\n    }\n    return ans;\n  }\n};",
      "output": "[[-1, -1, 2], [-1, 0, 1]]\nExplanation:\n[]\nExplanation:\n[[0, 0, 0]]\nExplanation:",
      "language": "cpp"
    },
    {
      "fileName": "Transpose of a Matrix.cpp",
      "name": "Transpose of a Matrix",
      "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n/*\n\nExample\nInput:\n\n2 3\n1 2 3\n4 5 6\nOutput:\n\n1 4\n2 5\n3 6\nExplanation:\nThe given matrix A:\n\n\nA = [\n  [1, 2, 3],\n  [4, 5, 6]\n]\nThe transpose of the matrix A, denoted by A^T, becomes:\n\n\nA^T = [\n  [1, 4],\n  [2, 5],\n  [3, 6]\n]\nNotice how element A[i][j] in the original matrix becomes A[j][i] in the transposed matrix. You need to construct and return this transposed matrix as the result.\n\nExample 1:\n\nInput:\n\nInput: n = 1, m = 1, matrix = [[5]]\n\nOutput:\n\n5\nExplanation:A 1x1 matrix remains the same after transposition.\n\nExample 2:\n\nInput:\n\nInput: n = 2, m = 2, matrix = [[1, 2], [3, 4]]\n\nOutput:\n\n1 3\n2 4\nExplanation:Transposing a 2x2 matrix swaps rows and columns.\n\nExample 3:\n\nInput:\n\nInput: n = 2, m = 3, matrix = [[1, 2, 3], [4, 5, 6]]\n\nOutput:\n\n1 4\n2 5\n3 6\nExplanation:Transposing a 2x3 matrix results in a 3x2 matrix.\n\n*/\n\nclass Matrix\n{\npublic:\n    vector<vector<int>> transpose(const vector<vector<int>> &matrix)\n    {\n        if (matrix.empty())\n            return {};\n        int n = matrix.size();\n        int m = matrix[0].size();\n        vector<vector<int>> transposed(m, vector<int>(n));\n        for (int i = 0; i < n; ++i)\n        {\n            for (int j = 0; j < m; ++j)\n            {\n                transposed[j][i] = matrix[i][j];\n            }\n        }\n        return transposed;\n    }\n};",
      "output": "1 4\n2 5\n3 6\nExplanation:\nThe given matrix A:\nA = [\n[1, 2, 3],\n[4, 5, 6]\n]\nThe transpose of the matrix A, denoted by A^T, becomes:\nA^T = [\n[1, 4],\n[2, 5],\n[3, 6]\n]\nNotice how element A[i][j] in the original matrix becomes A[j][i] in the transposed matrix. You need to construct and return this transposed matrix as the result.\n5\nExplanation:A 1x1 matrix remains the same after transposition.\n1 3\n2 4\nExplanation:Transposing a 2x2 matrix swaps rows and columns.\n1 4\n2 5\n3 6\nExplanation:Transposing a 2x3 matrix results in a 3x2 matrix.",
      "language": "cpp"
    },
    {
      "fileName": "Two Sum.cpp",
      "name": "Two Sum",
      "code": "\n\n#include<iostream>\n#include<vector>\nusing namespace std;\n\n/*\n\nNote:\nConsider scenarios where the array is of size 2 or contains negative numbers as potential edge cases.\nExample 1:\n\nInput:\n\nnums=[2,7,11,15] target=9\n\nOutput:\n\n0, 1\nExplanation:2 + 7 = 9, and their indices are 0 and 1\n\nExample 2:\n\nInput:\n\nnums=[3,2,4] target=6\n\nOutput:\n\n1, 2\nExplanation:2 + 4 = 6, hence indices 1 and 2\n\nExample 3:\n\nInput:\n\nnums=[3,3] target=6\n\nOutput:\n\n0, 1\nExplanation:3 + 3 = 6, so the pair is 0 and 1\n\n*/\n\n\n\nclass Solution {\npublic:\n  vector<int> twoSum(vector<int> &nums, int target) {\n    // Your logic will go here.\n    int n = nums.size();\n\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        int first = nums[i];\n        int second = nums[j];\n        int sum = first + second;\n\n        if (sum == target) {\n          return {i, j};\n        }\n      }\n    }\n\n    return {};\n  }\n};",
      "output": "0, 1\nExplanation:2 + 7 = 9, and their indices are 0 and 1\n1, 2\nExplanation:2 + 4 = 6, hence indices 1 and 2\n0, 1\nExplanation:3 + 3 = 6, so the pair is 0 and 1",
      "language": "cpp"
    },
    {
      "fileName": "Wave Array.cpp",
      "name": "Wave Array",
      "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// gfg -> https://www.geeksforgeeks.org/problems/wave-array-1587115621/1\n\n/*\n\nExamples:\n\nInput: arr[] = [1, 2, 3, 4, 5]\nOutput: [2, 1, 4, 3, 5]\nExplanation: Array elements after sorting it in the waveform are 2, 1, 4, 3, 5.\nInput: arr[] = [2, 4, 7, 8, 9, 10]\nOutput: [4, 2, 8, 7, 10, 9]\nExplanation: Array elements after sorting it in the waveform are 4, 2, 8, 7, 10, 9.\nInput: arr[] = [1]\nOutput: [1]\n\n*/\n\nclass Solution\n{\npublic:\n    void sortInWave(vector<int> &arr)\n    {\n\n        int n = arr.size();\n\n        for (int i = 0; i + 1 < n; i += 2)\n        {\n            int temp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n        }\n    }\n};",
      "output": "Explanation: Array elements after sorting it in the waveform are 2, 1, 4, 3, 5.\nExplanation: Array elements after sorting it in the waveform are 4, 2, 8, 7, 10, 9.",
      "language": "cpp"
    },
    {
      "fileName": "Wave Print A Matrix.cpp",
      "name": "Wave Print A Matrix",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nExample 1:\n\nInput:\n\nm=3 n=3 matrix=[[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n\n1 4 7 8 5 2 3 6 9\nExplanation:Wave order (col-wise): 1 4 7 \u2193, then 8 5 2 \u2191, then 3 6 9 \u2193.\n\nExample 2:\n\nInput:\n\nm=3 n=4 matrix=[[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n\nOutput:\n\n1 5 9 10 6 2 3 7 11 12 8 4\nExplanation:Even columns top\u2192bottom, odd columns bottom\u2192top.\n\nExample 3:\n\nInput:\n\nm=1 n=5 matrix=[[1,2,3,4,5]]\n\nOutput:\n\n1 2 3 4 5\nExplanation:Only one row, so wave is left-to-right.\n\n*/\n\nclass Solution\n{\npublic:\n    vector<int> wavePrintMatrix(vector<vector<int>> &matrix, int m, int n)\n    {\n        vector<int> result;\n        for (int j = 0; j < n; ++j)\n        {\n            if (j % 2 == 0)\n            {\n                for (int i = 0; i < m; ++i)\n                {\n                    result.push_back(matrix[i][j]);\n                }\n            }\n            else\n            {\n                for (int i = m - 1; i >= 0; --i)\n                {\n                    result.push_back(matrix[i][j]);\n                }\n            }\n        }\n        return result;\n    }\n};",
      "output": "1 4 7 8 5 2 3 6 9\nExplanation:Wave order (col-wise): 1 4 7 \u2193, then 8 5 2 \u2191, then 3 6 9 \u2193.\n1 5 9 10 6 2 3 7 11 12 8 4\nExplanation:Even columns top\u2192bottom, odd columns bottom\u2192top.\n1 2 3 4 5\nExplanation:Only one row, so wave is left-to-right.",
      "language": "cpp"
    },
    {
      "fileName": "k largest elements.cpp",
      "name": "k largest elements",
      "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n/*  gfg-> https://www.geeksforgeeks.org/problems/k-largest-elements4206/1\n\nExamples:\n\nInput: arr[] = [12, 5, 787, 1, 23], k = 2\nOutput: [787, 23]\nExplanation: 1st largest element in the array is 787 and second largest is 23.\nInput: arr[] = [1, 23, 12, 9, 30, 2, 50], k = 3\nOutput: [50, 30, 23]\nExplanation: Three Largest elements in the array are 50, 30 and 23.\nInput: arr[] = [12, 23], k = 1\nOutput: [23]\nExplanation: 1st Largest element in the array is 23.\n\n*/\n\nclass Solution\n{\npublic:\n    vector<int> kLargest(vector<int> &arr, int k)\n    {\n        int n = arr.size();\n        vector<int> ans;\n\n        sort(arr.begin(), arr.end());\n\n        for (int i = n - 1; i >= n - k; i--)\n        {\n            ans.push_back(arr[i]);\n        }\n        return ans;\n    }\n};",
      "output": "Explanation: 1st largest element in the array is 787 and second largest is 23.\nExplanation: Three Largest elements in the array are 50, 30 and 23.\nExplanation: 1st Largest element in the array is 23.",
      "language": "cpp"
    },
    {
      "fileName": "return sum 0f positive and negative numbers in pairs.cpp",
      "name": "return sum 0f positive and negative numbers in pairs",
      "code": "\n#include<iostream>\nusing namespace std;\n#include<vector>\n#include <algorithm>\n\n/*\n\nExample:\nExample 1:\nInput: [-1, 2, 3, -4, 5]\n\nOutput: (10, -5)\n\nHere, the positive numbers are [2, 3, 5], whose sum is 10.\nThe negative numbers are [-1, -4], whose sum is -5.\nThis problem tests your ability to traverse an array and perform conditional aggregation based on the sign of each element.\n\nExample 1:\n\nInput:\n\nInput: arr = [1, 2, 3, -1, -2]\n\nOutput:\n\n(6, -3)\nExplanation:Sum of positives is 6 and negatives is -3.\n\nExample 2:\n\nInput:\n\nInput: arr = [0, 1, -1]\n\nOutput:\n\n(1, -1)\nExplanation:Sum of positives is 1 and negatives is -1.\n\nExample 3:\n\nInput:\n\nInput: arr = [-5, -10, -15]\n\nOutput:\n\n(0, -30)\nExplanation:Sum of positives is 0 and negatives is -30.\n\n\n\n*/\n\n\n\n\nclass Solution {\npublic:\n  pair<int, int> sumPositiveNegative(const vector<int> &arr) {\n    // Implement logic to calculate sums of positive and negative elements\n    vector<int> nums = arr;\n\n    int n = nums.size();\n    int i = 0;\n    int countpositive = 0;\n    int countnegative = 0;\n    while (i < n) {\n      if (nums[i] > 0) {\n        countpositive = countpositive + nums[i];\n      } else {\n        countnegative = countnegative + nums[i];\n      }\n      i++;\n    }\n    return {countpositive,countnegative};\n  }\n};",
      "output": "Here, the positive numbers are [2, 3, 5], whose sum is 10.\nThe negative numbers are [-1, -4], whose sum is -5.\nThis problem tests your ability to traverse an array and perform conditional aggregation based on the sign of each element.\n(6, -3)\nExplanation:Sum of positives is 6 and negatives is -3.\n(1, -1)\nExplanation:Sum of positives is 1 and negatives is -1.\n(0, -30)\nExplanation:Sum of positives is 0 and negatives is -30.",
      "language": "cpp"
    }
  ],
  "Comparison-Based Sorting Techniques": [
    {
      "fileName": "Bubble Sort.cpp",
      "name": "Bubble Sort",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nExamples :\n\nInput: arr[] = [4, 1, 3, 9, 7]\nOutput: [1, 3, 4, 7, 9]\nExplanation: After Sorting the array in ascending order of their values is [1, 3, 4, 7, 9].\nInput: arr[] = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\nOutput: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nExplanation: Sort the array in ascending order of their values.\nInput: arr[] = [1, 2, 3, 4, 5]\nOutput: [1, 2, 3, 4, 5]\nExplanation: An array that is already sorted should remain unchanged after applying bubble sort.\n\n*/\n\nclass Solution\n{\npublic:\n    void bubbleSort(vector<int> &arr)\n    {\n        // code here\n        int n = arr.size();\n        for (int i = 0; i < n - 1; i++)\n        {\n            for (int j = 0; j < n - 1 - i; j++)\n            {\n                if (arr[j] > arr[j + 1])\n                {\n                    int t = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = t;\n                }\n            }\n        }\n    }\n    \n};",
      "output": "Explanation: After Sorting the array in ascending order of their values is [1, 3, 4, 7, 9].\nExplanation: Sort the array in ascending order of their values.\nExplanation: An array that is already sorted should remain unchanged after applying bubble sort.",
      "language": "cpp"
    },
    {
      "fileName": "Insertion Sort.cpp",
      "name": "Insertion Sort",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nExamples:\n\nInput: arr[] = [4, 1, 3, 9, 7]\nOutput: [1, 3, 4, 7, 9]\nExplanation: The sorted array will be [1, 3, 4, 7, 9].\nInput: arr[] = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\nOutput: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nExplanation: The sorted array will be [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].\nInput: arr[] = [4, 1, 9]\nOutput: [1, 4, 9]\nExplanation: The sorted array will be [1, 4, 9].\n\n*/\n\nclass Solution\n{\npublic:\n    void insertionSort(vector<int> &arr)\n    {\n        // code here\n        int n = arr.size();\n        for (int i = 0; i < n; i++)\n        {\n            int pivot = arr[i];\n            int j = i - 1;\n\n            while (j >= 0 && arr[j] > pivot)\n            {\n                arr[j + 1] = arr[j];\n                j--;\n            }\n            arr[j + 1] = pivot;\n        }\n    }\n};\n",
      "output": "Explanation: The sorted array will be [1, 3, 4, 7, 9].\nExplanation: The sorted array will be [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].\nExplanation: The sorted array will be [1, 4, 9].",
      "language": "cpp"
    },
    {
      "fileName": "Selection Sort.cpp",
      "name": "Selection Sort",
      "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\n/*\n\nExamples :\n\nInput: arr[] = [4, 1, 3, 9, 7]\nOutput: [1, 3, 4, 7, 9]\nExplanation: Maintain sorted (in bold) and unsorted subarrays. Select 1. Array becomes 1 4 3 9 7. Select 3. Array becomes 1 3 4 9 7. Select 4. Array becomes 1 3 4 9 7. Select 7. Array becomes 1 3 4 7 9. Select 9. Array becomes 1 3 4 7 9.\nInput: arr[] = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\nOutput: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nInput: arr[] = [38, 31, 20, 14, 30]\nOutput: [14, 20, 30, 31, 38]\n\n*/\n\n\n\nclass Solution {\n  public:\n    // Function to perform selection sort on the given array.\n    void selectionSort(vector<int> &arr) {\n        // code here\n        int n=arr.size();\n        \n        for(int i=0;i<n-1;i++){\n            int minIndex=i; \n            \n            for(int j=i+1;j<n;j++){\n                if(arr[j]<arr[minIndex]){\n                    minIndex=j;\n                }\n            }\n            \n            //swap\n            \n            swap(arr[i],arr[minIndex]);\n            \n            \n        }\n        \n    }\n};\n\n",
      "output": "Explanation: Maintain sorted (in bold) and unsorted subarrays. Select 1. Array becomes 1 4 3 9 7. Select 3. Array becomes 1 3 4 9 7. Select 4. Array becomes 1 3 4 9 7. Select 7. Array becomes 1 3 4 7 9. Select 9. Array becomes 1 3 4 7 9.",
      "language": "cpp"
    }
  ],
  "Linked Lists": [
    {
      "fileName": "Find Length of Linked List.cpp",
      "name": "Find Length of Linked List",
      "code": "#include <iostream>\nusing namespace std;\n\n\n/*\n\nExamples :\n\nInput: head : 1->2->3->4->5\n\nOutput: 5\nExplanation: Length of the linked list is 5, as there\nare 5 nodes present in it.\nInput: head : 2->4->6->7->5->1->0\n\nOutput: 7\nExplanation: Length of the linked list is 7, as there\nare 7 nodes present in it.\n\n*/\n\nclass Node\n{\npublic:\n    int data;\n    Node *next;\n\n    Node(int x)\n    {\n        data = x;\n        next = NULL;\n    }\n};\n\nclass Solution\n{\npublic:\n    int getCount(Node *head)\n    {\n        // Code here\n        int c = 0;\n        while (head != NULL)\n        {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n};\n",
      "output": "Explanation: Length of the linked list is 5, as there\nare 5 nodes present in it.\nExplanation: Length of the linked list is 7, as there\nare 7 nodes present in it.",
      "language": "cpp"
    },
    {
      "fileName": "Linked List Insertion At End.cpp",
      "name": "Linked List Insertion At End",
      "code": "#include <iostream>\nusing namespace std;\n\n\n/*\n\nInput: x = 6,\n\nOutput: 1 -> 2 -> 3 -> 4 -> 5 -> 6\nExplanation: We can see that 6 is inserted at the end of the linkedlist.\n\nInput: x = 1,\n\nOutput: 4 -> 5 -> 1\nExplanation: We can see that 1 is inserted at the end of the linked list.\n\n\n*/\n\nclass Node\n{\npublic:\n    int data;\n    Node *next;\n\n    // Default constructor\n    Node()\n    {\n        data = 0;\n        next = NULL;\n    }\n\n    // Parameterised Constructor\n    Node(int data)\n    {\n        this->data = data;\n        this->next = NULL;\n    }\n};\n\nclass Solution\n{\npublic:\n    Node *insertAtEnd(Node *head, int x)\n    {\n        // Code here\n\n        Node *newNode = new Node(x);\n        if (head == NULL)\n            return newNode;\n        Node *tmp = head;\n\n        while (tmp->next != NULL)\n        {\n            tmp = tmp->next;\n        }\n        tmp->next = newNode;\n        return head;\n    }\n};",
      "output": "Explanation: We can see that 6 is inserted at the end of the linkedlist.\nExplanation: We can see that 1 is inserted at the end of the linked list.",
      "language": "cpp"
    },
    {
      "fileName": "Print Linked List.cpp",
      "name": "Print Linked List",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Node\n{\npublic:\n    int data;\n    Node *next;\n\n    // Default constructor\n    Node()\n    {\n        data = 0;\n        next = NULL;\n    }\n\n    // Parameterised Constructor\n    Node(int data)\n    {\n        this->data = data;\n        this->next = NULL;\n    }\n};\n\nclass Solution\n{\npublic:\n    vector<int> printList(Node *head)\n    {\n        // code here\n        vector<int> ans;\n        while (head != NULL)\n        {\n            ans.push_back(head->data);\n            head = head->next;\n        }\n\n        return ans;\n    }\n};\n",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Search In Linked List.cpp",
      "name": "Search In Linked List",
      "code": "#include <iostream>\nusing namespace std;\n\n/*\n\n\nInput: LinkedList: 1->2->3->4->5, x = 4\nOutput: 1\nInput: LinkedList: 2->4->6->7->5->1->0, x = 10\nOutput: 0\n\n*/\n\nstruct Node\n\n{\n    int data;\n    Node *next;\n    Node(int x)\n    {\n        data = x;\n        next = NULL;\n    }\n};\n\nclass Solution\n{\npublic:\n    bool searchLinkedList(Node *head, int x)\n    {\n        // Your code here\n        while (head != NULL)\n        {\n            if (head->data == x)\n            {\n                return true;\n            }\n            head = head->next;\n        }\n        return false;\n    }\n};",
      "output": "Output not specified in comments.",
      "language": "cpp"
    }
  ],
  "Maths-Practice-Problems": [
    {
      "fileName": "Area Of Circle.cpp",
      "name": "Area Of Circle",
      "code": "\n\n/*\n\nExample:\nInput:\n\n\nradius = 5\nOutput:\n\n\n78.54\nExplanation:\n\nGiven the radius of 5, the area ( A = \\pi \\times 5^2 = 78.53975 ) is rounded to 78.54.\n\nExample 1:\n\nInput:\n\nInput: radius = 1\n\nOutput:\n\n3\nExplanation:Area of a circle with radius 1 is approximately 3.\n\nExample 2:\n\nInput:\n\nInput: radius = 2\n\nOutput:\n\n12\nExplanation:Area of a circle with radius 2 is approximately 12.\n\nExample 3:\n\nInput:\n\nInput: radius = 3\n\nOutput:\n\n28\nExplanation:Area of a circle with radius 3 is approximately 28.\n\n*/\n\n\nclass Solution {\npublic:\n    int areaOfCircle(int radius) {\n       return 3.14*radius*radius;\n    }\n};",
      "output": "78.54\nExplanation:\nGiven the radius of 5, the area ( A = \\pi \\times 5^2 = 78.53975 ) is rounded to 78.54.\n3\nExplanation:Area of a circle with radius 1 is approximately 3.\n12\nExplanation:Area of a circle with radius 2 is approximately 12.\n28\nExplanation:Area of a circle with radius 3 is approximately 28.",
      "language": "cpp"
    },
    {
      "fileName": "Check Prime Number.cpp",
      "name": "Check Prime Number",
      "code": "\n#include<iostream>\nusing namespace std;\n\n/*\n\nExample\nInput: num = 29\n\nOutput: True\n\nExplanation: 29 is a prime number because it is only divisible by 1 and 29.\n\nInput: num = 35\n\nOutput: False\n\nExplanation: 35 is not a prime number because it has divisors 1, 5, 7, and 35.\n\nExample 1:\n\nInput:\n\nInput: num = 2\n\nOutput:\n\nYes\nExplanation:2 is prime.\n\nExample 2:\n\nInput:\n\nInput: num = 4\n\nOutput:\n\nNo\nExplanation:4 is not prime.\n\nExample 3:\n\nInput:\n\nInput: num = 5\n\nOutput:\n\nYes\nExplanation:5 is prime.\n\n\n*/\n\n\nclass Solution {\npublic:\n  string isPrime(int num) {\n    // Implement logic to check if num is prime\n    if (num == 1) {\n      return \"No\";\n      // check\n    }\n    if (num == 2 || num == 3) {\n      return \"Yes\";\n    }\n    int start = 2;\n    int end = num - 1;\n\n    for (int i = start; i <= end; i++) {\n      if (num % i == 0) {\n        return \"No\";\n      }\n    }\n    return \"Yes\";\n  }\n};",
      "output": "Explanation: 29 is a prime number because it is only divisible by 1 and 29.\nExplanation: 35 is not a prime number because it has divisors 1, 5, 7, and 35.\nYes\nExplanation:2 is prime.\nNo\nExplanation:4 is not prime.\nYes\nExplanation:5 is prime.",
      "language": "cpp"
    },
    {
      "fileName": "Check if a Given Number is Prime.cpp",
      "name": "Check if a Given Number is Prime",
      "code": "\n\n/*\n\nExample\nExample 1:\n\nInput: n = 5\n\nOutput: true\n\nExplanation:\n\nThe number 5 is a prime number because it has no divisors other than 1 and 5 itself.\nExample 2:\n\nInput: n = 4\n\nOutput: false\n\nExplanation:\n\nThe number 4 is not a prime number because it can be divided evenly by 2 (4 = 2 * 2).\nNote\nThe number 1 is not a prime number by definition.\nExample 1:\n\nInput:\n\nInput: n = 1\n\nOutput:\n\nfalse\nExplanation:1 is not a prime number.\n\nExample 2:\n\nInput:\n\nInput: n = 2\n\nOutput:\n\ntrue\nExplanation:2 is the smallest prime number.\n\nExample 3:\n\nInput:\n\nInput: n = 3\n\nOutput:\n\ntrue\nExplanation:3 is a prime number.\n\n*/\n\nbool isPrime(int n) {\n  // Your code here\n  if (n == 1) {\n    return false;\n  } else {\n    for (int i = 2; i <= (n - 1); i++) {\n      if (n % i == 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n}",
      "output": "Explanation:\nThe number 5 is a prime number because it has no divisors other than 1 and 5 itself.\nExplanation:\nThe number 4 is not a prime number because it can be divided evenly by 2 (4 = 2 * 2).\nNote\nThe number 1 is not a prime number by definition.\nfalse\nExplanation:1 is not a prime number.\ntrue\nExplanation:2 is the smallest prime number.\ntrue\nExplanation:3 is a prime number.",
      "language": "cpp"
    },
    {
      "fileName": "Check if a Number is Even or Odd.cpp",
      "name": "Check if a Number is Even or Odd",
      "code": "\n#include<iostream>\nusing namespace std;\n\n/*\n\nExamples\nExample 1\n\nInput: 4\n\nOutput: Even\n\nHere, the number 4 is divisible by 2 without a remainder, thus it is classified as an even number.\n\nExample 2\n\nInput: 7\n\nOutput: Odd\n\nHere, the number 7 leaves a remainder of 1 when divided by 2, thus it is classified as an odd number.\n\nThe challenge is straightforward and focuses on working with the modulus operator to determine the nature of the number.\n\nFunction Signature\ndef check_even_odd(num: int) -> str: pass\n\nExample 1:\n\nInput:\n\nInput: num = 4\n\nOutput:\n\nEven\nExplanation:4 is even.\n\nExample 2:\n\nInput:\n\nInput: num = 7\n\nOutput:\n\nOdd\nExplanation:7 is odd.\n\nExample 3:\n\nInput:\n\nInput: num = 0\n\nOutput:\n\nEven\nExplanation:0 is considered even.\n\n*/\n\n\nclass Solution {\npublic:\n  string checkEvenOdd(int num) {\n    // Implement logic to check if num is even or odd\n    if (num & 1) {\n      return \"Odd\";\n\n    } else {\n      return \"Even\";\n    }\n  }\n};",
      "output": "Here, the number 4 is divisible by 2 without a remainder, thus it is classified as an even number.\nHere, the number 7 leaves a remainder of 1 when divided by 2, thus it is classified as an odd number.\nThe challenge is straightforward and focuses on working with the modulus operator to determine the nature of the number.\nFunction Signature\ndef check_even_odd(num: int) -> str: pass\nEven\nExplanation:4 is even.\nOdd\nExplanation:7 is odd.\nEven\nExplanation:0 is considered even.",
      "language": "cpp"
    },
    {
      "fileName": "Check if a Number is Power of 2.cpp",
      "name": "Check if a Number is Power of 2",
      "code": "\n#include<iostream>\nusing namespace std;\n/*\n\nExample\nInput: num = 16\n\nOutput: true\n\nExplanation: 16 is 24, which is a power of 2.\n\nInput: num = 18\n\nOutput: false\n\nExplanation: 18 cannot be expressed as a power of 2.\n\nNote\nYou need to write an efficient solution; using properties of numbers and bit manipulation could be beneficial here.\nConsider edge cases and large values, within the given constraints.\nExample 1:\n\nInput:\n\nInput: num = 1\n\nOutput:\n\nYes\nExplanation:1 is 2^0, hence a power of 2.\n\nExample 2:\n\nInput:\n\nInput: num = 2\n\nOutput:\n\nYes\nExplanation:2 is 2^1, hence a power of 2.\n\nExample 3:\n\nInput:\n\nInput: num = 3\n\nOutput:\n\nNo\nExplanation:3 is not a power of 2.\n\n*/\n\n\n\nclass Solution {\npublic:\n    string isPowerOfTwo(int num) {\n        if (num <= 0) {\n            return \"No\";   // negative numbers and 0 are not powers of 2\n        }\n\n        if ((num & (num - 1)) == 0) {\n            return \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n};\n",
      "output": "Explanation: 16 is 24, which is a power of 2.\nExplanation: 18 cannot be expressed as a power of 2.\nNote\nYou need to write an efficient solution; using properties of numbers and bit manipulation could be beneficial here.\nConsider edge cases and large values, within the given constraints.\nYes\nExplanation:1 is 2^0, hence a power of 2.\nYes\nExplanation:2 is 2^1, hence a power of 2.\nNo\nExplanation:3 is not a power of 2.",
      "language": "cpp"
    },
    {
      "fileName": "Check if a Number is a Narcissistic Number.cpp",
      "name": "Check if a Number is a Narcissistic Number",
      "code": "\n#include<iostream>\n#include <cmath>\nusing namespace std;\n\n/*\n\nExample\nInput:\n\n\n153\nOutput:\n\n\ntrue\nNote\nCheck if the number that is inputted is a Narcissistic number by calculating the sum of its digits each raised to the power of the number of digits.\n\nExample 1:\n\nInput:\n\nInput: num = 153\n\nOutput:\n\nYes\nExplanation:153 is equal to 1^3 + 5^3 + 3^3, so it is Narcissistic.\n\nExample 2:\n\nInput:\n\nInput: num = 9474\n\nOutput:\n\nYes\nExplanation:9474 is equal to 9^4 + 4^4 + 7^4 + 4^4.\n\nExample 3:\n\nInput:\n\nInput: num = 123\n\nOutput:\n\nNo\nExplanation:123 is not Narcissistic.\n\n*/\n\n\nclass Solution {\npublic:\n  string isNarcissistic(int num) {\n    // Implement logic to check if num is Narcissistic\n    int original = num;\n    int sum = 0;\n    int count = 0;\n    int copy = num;\n\n    while (copy != 0) {\n      count++;\n      copy = copy / 10;\n    }\n    while (num != 0) {\n      int digit = num % 10;\n      sum = sum + pow(digit, count);\n      num = num / 10;\n    }\n    return (sum == original) ? \"Yes\" : \"No\";\n  }\n};\n",
      "output": "true\nNote\nCheck if the number that is inputted is a Narcissistic number by calculating the sum of its digits each raised to the power of the number of digits.\nYes\nExplanation:153 is equal to 1^3 + 5^3 + 3^3, so it is Narcissistic.\nYes\nExplanation:9474 is equal to 9^4 + 4^4 + 7^4 + 4^4.\nNo\nExplanation:123 is not Narcissistic.",
      "language": "cpp"
    },
    {
      "fileName": "Convert Temperature Between Celsius and Fahrenheit.cpp",
      "name": "Convert Temperature Between Celsius and Fahrenheit",
      "code": "\n#include<iostream>\nusing namespace std;\n\n/*\n\nConversion Formulas:\nCelsius to Fahrenheit:\n\n[ F = C \\times \\frac{9}{5} + 32 ]\n\nFahrenheit to Celsius:\n\n[ C = (F - 32) \\times \\frac{5}{9} ]\n\n\n Examples:\nExample 1:\nInput:\n\ntemp = 0, conversion = \"CtoF\"\n\nOutput:\n\n32.00\n\nExplanation: 0 degrees Celsius is equivalent to 32 degrees Fahrenheit.\n\nExample 2:\nInput:\n\ntemp = 32, conversion = \"FtoC\"\n\nOutput:\n\n0.00\n\nExplanation: 32 degrees Fahrenheit is equivalent to 0 degrees Celsius.\n\nNote:\nThe input will always be a floating-point number for temperature and a string for the conversion type, which will either be \"CtoF\" or \"FtoC\".\nExample 1:\n\nInput:\n\nInput: temperature = 0, conversionType = 'CtoF'\n\nOutput:\n\n32.00\nExplanation:0\u00b0C converted to Fahrenheit: (0 \u00d7 9/5) + 32 = 32.00\u00b0F.\n\nExample 2:\n\nInput:\n\nInput: temperature = 100, conversionType = 'CtoF'\n\nOutput:\n\n212.00\nExplanation:100\u00b0C converted to Fahrenheit: (100 \u00d7 9/5) + 32 = 212.00\u00b0F.\n\nExample 3:\n\nInput:\n\nInput: temperature = -40, conversionType = 'CtoF'\n\nOutput:\n\n-40.00\nExplanation:-40\u00b0C and -40\u00b0F are the same temperature.\n\n*/\n\nclass TemperatureConverter {\npublic:\n  double convertTemperature(double temp, string conversionType) {\n    // Implement the conversion here\n\n    if (conversionType == \"CtoF\") {\n    return  ((temp * 9) / 5) + 32;\n    }\n\n    return (temp - 32) * 5 / 9;\n  }\n};\n",
      "output": "32.00\nExplanation: 0 degrees Celsius is equivalent to 32 degrees Fahrenheit.\n0.00\nExplanation: 32 degrees Fahrenheit is equivalent to 0 degrees Celsius.\nNote:\nThe input will always be a floating-point number for temperature and a string for the conversion type, which will either be \"CtoF\" or \"FtoC\".\n32.00\nExplanation:0\u00b0C converted to Fahrenheit: (0 \u00d7 9/5) + 32 = 32.00\u00b0F.\n212.00\nExplanation:100\u00b0C converted to Fahrenheit: (100 \u00d7 9/5) + 32 = 212.00\u00b0F.\n-40.00\nExplanation:-40\u00b0C and -40\u00b0F are the same temperature.",
      "language": "cpp"
    },
    {
      "fileName": "Count Total Set Bits in a Number.cpp",
      "name": "Count Total Set Bits in a Number",
      "code": "\n\n\n/*\n\nExample\nExample 1:\nInput:\n\n\nn = 3\nOutput:\n\n\n4\nExplanation:\n\nThe binary representations of numbers from 1 to n are:\n\n1 (1): 1\n2 (2): 10\n3 (3): 11\nThe total number of set bits in these numbers is 1 + 1 + 2 = 4.\n\nExample 2:\nInput:\n\n\nn = 5\nOutput:\n\n\n7\nExplanation:\n\nThe binary representations are:\n\n1: 1\n2: 10\n3: 11\n4: 100\n5: 101\nThe total set bits = 1 + 1 + 2 + 1 + 2 = 7.\n\nYour goal is to find a more efficient solution than directly counting the bits of each individual number.\n\nExample 1:\n\nInput:\n\nInput: n = 1\n\nOutput:\n\n1\nExplanation:Binary representation: 1 \u2192 1 set bit. Total set bits: 1.\n\nExample 2:\n\nInput:\n\nInput: n = 2\n\nOutput:\n\n2\nExplanation:Binary: 1 (1 set bit), 10 (1 set bit). Total: 1+1 = 2.\n\nExample 3:\n\nInput:\n\nInput: n = 3\n\nOutput:\n\n4\nExplanation:Binary: 1 (1), 10 (1), 11 (2). Total: 1+1+2 = 4.\n\n*/\n\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int countTotalSetBits(int n) {\n        int total = 0;\n        for (int i = 1; i <= n; i++) {\n            int x = i;\n            while (x > 0) {\n                if (x % 2 == 1)  \n                    total++;\n                x = x / 2;       \n            }\n        }\n        return total;\n    }\n};",
      "output": "4\nExplanation:\nThe binary representations of numbers from 1 to n are:\n1 (1): 1\n2 (2): 10\n3 (3): 11\nThe total number of set bits in these numbers is 1 + 1 + 2 = 4.\n7\nExplanation:\nThe binary representations are:\n1: 1\n2: 10\n3: 11\n4: 100\n5: 101\nThe total set bits = 1 + 1 + 2 + 1 + 2 = 7.\nYour goal is to find a more efficient solution than directly counting the bits of each individual number.\n1\nExplanation:Binary representation: 1 \u2192 1 set bit. Total set bits: 1.\n2\nExplanation:Binary: 1 (1 set bit), 10 (1 set bit). Total: 1+1 = 2.\n4\nExplanation:Binary: 1 (1), 10 (1), 11 (2). Total: 1+1+2 = 4.",
      "language": "cpp"
    },
    {
      "fileName": "Count-number-of-divisors.cpp",
      "name": "Count-number-of-divisors",
      "code": "\n\n/*\n\nExample:\nInput:\n\n\nnum = 12\nOutput:\n\n\n6\nExplanation: Divisors of 12 are 1, 2, 3, 4, 6, and 12. Hence, the number of divisors is 6.\n\nExample 1:\n\nInput:\n\nInput: num = 1\n\nOutput:\n\n1\nExplanation:1 has only one divisor: itself.\n\nExample 2:\n\nInput:\n\nInput: num = 2\n\nOutput:\n\n2\nExplanation:2 has two divisors: 1 and 2.\n\nExample 3:\n\nInput:\n\nInput: num = 4\n\nOutput:\n\n3\nExplanation:4 has three divisors: 1, 2, 4.\n\n*/\n\nclass Solution {\npublic:\n  int countDivisors(int num) {\n    // Implement logic to count divisors of num\n    int count = 0;\n    for (int i = 1; i <= num; i++) {\n      if (num % i == 0) {\n        count++;\n      }\n    }\n    return count;\n  }\n};",
      "output": "6\nExplanation: Divisors of 12 are 1, 2, 3, 4, 6, and 12. Hence, the number of divisors is 6.\n1\nExplanation:1 has only one divisor: itself.\n2\nExplanation:2 has two divisors: 1 and 2.\n3\nExplanation:4 has three divisors: 1, 2, 4.",
      "language": "cpp"
    },
    {
      "fileName": "Create a Number Using Given Digits.cpp",
      "name": "Create a Number Using Given Digits",
      "code": "\n#include<iostream>\n#include<vector>\nusing namespace std;\n/*\n\nExample\nInput:\n\n\ndigits = [5, 8, 3, 2, 9]\nOutput:\n\n\n98532\nExplanation:\n\nTo achieve the largest possible number with the digits [5, 8, 3, 2, 9], they are rearranged in descending order resulting in the number 98532.\n\nExample 1:\n\nInput:\n\nInput: digits = [1, 2, 3]\n\nOutput:\n\n321\nExplanation:The digits are combined as 3 \u2192 2 \u2192 1 forming 321.\n\nExample 2:\n\nInput:\n\nInput: digits = [4, 5, 6, 7]\n\nOutput:\n\n7654\nExplanation:The digits are combined as 7 \u2192 6 \u2192 5 \u2192 4 forming 7654.\n\nExample 3:\n\nInput:\n\nInput: digits = [9, 8, 7, 6]\n\nOutput:\n\n9876\nExplanation:The digits are combined as 9 \u2192 8 \u2192 7 \u2192 6 forming 9876.\n\n\n\n*/\n\n\nclass Solution {\npublic:\n    int createLargestNumber(vector<int>& digits) {\n        int n = digits.size();\n\n        // Bubble sort style descending order\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < n - i - 1; j++) {\n                if (digits[j] < digits[j + 1]) {\n                    // Swap adjacent values\n                    int temp = digits[j];\n                    digits[j] = digits[j + 1];\n                    digits[j + 1] = temp;\n                }\n            }\n        }\n\n        // Combine digits to form number\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum = sum * 10 + digits[i];\n        }\n\n        return sum;\n    }\n};\n",
      "output": "98532\nExplanation:\nTo achieve the largest possible number with the digits [5, 8, 3, 2, 9], they are rearranged in descending order resulting in the number 98532.\n321\nExplanation:The digits are combined as 3 \u2192 2 \u2192 1 forming 321.\n7654\nExplanation:The digits are combined as 7 \u2192 6 \u2192 5 \u2192 4 forming 7654.\n9876\nExplanation:The digits are combined as 9 \u2192 8 \u2192 7 \u2192 6 forming 9876.",
      "language": "cpp"
    },
    {
      "fileName": "Find 2\u2019s Complement of a Number.cpp",
      "name": "Find 2\u2019s Complement of a Number",
      "code": "\n\n\n/*\n\nExample\nExample 1:\nInput:\n\n\nnum = 5\nOutput:\n\n\n-5\nExplanation:\n\n\nThe binary representation of 5 is `00000101`. Inverting the bits gives `11111010`. Adding 1 results in `11111011`, which is `-5` in decimal.\nExample 2:\nInput:\n\n\nnum = 1\nOutput:\n\n\n-1\nExplanation:\n\n\nThe binary representation of 1 is `1`. Inverting the bits gives `0`. Adding 1 results in `1`, which represents `-1` in 2's complement for a single bit.\nExample 1:\n\nInput:\n\nInput: num = 5\n\nOutput:\n\n-5\nExplanation:2's complement of 5 is -5.\n\nExample 2:\n\nInput:\n\nInput: num = 10\n\nOutput:\n\n-10\nExplanation:2's complement of 10 is -10.\n\nExample 3:\n\nInput:\n\nInput: num = 1\n\nOutput:\n\n-1\nExplanation:2's complement of 1 is -1.\n\n*/\n\nclass Solution {\npublic:\n  int twosComplement(int num) {\n    // Implement logic to find 2's complement of num\n    // 2` completement +1\n\n    int one_sComp = ~num;\n    int _2_Comp = one_sComp + 1;\n\n    return _2_Comp;\n  }\n};",
      "output": "-5\nExplanation:\nThe binary representation of 5 is `00000101`. Inverting the bits gives `11111010`. Adding 1 results in `11111011`, which is `-5` in decimal.\n-1\nExplanation:\nThe binary representation of 1 is `1`. Inverting the bits gives `0`. Adding 1 results in `1`, which represents `-1` in 2's complement for a single bit.\n-5\nExplanation:2's complement of 5 is -5.\n-10\nExplanation:2's complement of 10 is -10.\n-1\nExplanation:2's complement of 1 is -1.",
      "language": "cpp"
    },
    {
      "fileName": "Find Factorial of a Number.cpp",
      "name": "Find Factorial of a Number",
      "code": "\n\n/*\n\nExamples:\n\nExample 1:\n\nInput: 5\nOutput: 120\nExplanation: 5! = 5 \u00d7 4 \u00d7 3 \u00d7 2 \u00d7 1 = 120.\n\nExample 2:\n\nInput: 0\nOutput: 1\nExplanation: 0! is defined to be 1 by convention.\nFactorials grow very quickly, therefore, to avoid overflow issues, we limit the input number n to a maximum of 20. This ensures results fit within standard data type capacities in most programming languages.\n\nExample 1:\n\nInput:\n\nInput: num = 0\n\nOutput:\n\n1\nExplanation:Factorial of 0 is defined as 1.\n\nExample 2:\n\nInput:\n\nInput: num = 1\n\nOutput:\n\n1\nExplanation:Factorial of 1 is 1.\n\nExample 3:\n\nInput:\n\nInput: num = 5\n\nOutput:\n\n120\nExplanation:5! = 120.\n\n\n*/\n\nclass Solution {\npublic:\n  unsigned long long factorial(int num) {\n    unsigned long long fact = 1; // start with 1\n    if (num == 0 || num == 1) {\n      return 1;\n    }\n    for (int i = num; i > 1; i--) {\n      fact = fact * i;\n    }\n    return fact;\n  }\n};\n",
      "output": "Explanation: 5! = 5 \u00d7 4 \u00d7 3 \u00d7 2 \u00d7 1 = 120.\nExplanation: 0! is defined to be 1 by convention.\nFactorials grow very quickly, therefore, to avoid overflow issues, we limit the input number n to a maximum of 20. This ensures results fit within standard data type capacities in most programming languages.\n1\nExplanation:Factorial of 0 is defined as 1.\n1\nExplanation:Factorial of 1 is 1.\n120\nExplanation:5! = 120.",
      "language": "cpp"
    },
    {
      "fileName": "GCD of Two Numbers.cpp",
      "name": "GCD of Two Numbers",
      "code": "\n\n/*\n\nExample\nExample 1:\nInput:\na = 28, b = 35\n\nOutput:\n7\n\nExplanation:\n\nThe factors of 28 are 1, 2, 4, 7, 14, 28\nThe factors of 35 are 1, 5, 7, 35\nThe largest common factor is 7.\nExample 2:\nInput:\na = 18, b = 48\n\nOutput:\n6\n\nExplanation:\n\nThe factors of 18 are 1, 2, 3, 6, 9, 18.\nThe factors of 48 are 1, 2, 3, 4, 6, 8, 12, 16, 24, 48.\nThe largest common factor is 6.\nNote\nYou need to ensure that your solution handles values of a and b that are up to 10^6 efficiently.\n\nExample 1:\n\nInput:\n\nInput: a = 4, b = 5\n\nOutput:\n\n1\nExplanation:GCD of 4 and 5 is 1.\n\nExample 2:\n\nInput:\n\nInput: a = 6, b = 8\n\nOutput:\n\n2\nExplanation:GCD of 6 and 8 is 2.\n\nExample 3:\n\nInput:\n\nInput: a = 15, b = 20\n\nOutput:\n\n5\nExplanation:GCD of 15 and 20 is 5.\n\n*/\n\nclass Solution\n{\npublic:\n  int findGCD(int a, int b)\n  {\n    // Implement logic to find GCD of a and b\n    while (a != b)\n    {\n      if (a > b)\n      {\n        a = a - b;\n      }\n      else\n      {\n        b = b - a;\n      }\n    }\n  }\n};\n",
      "output": "7\nExplanation:\nThe factors of 28 are 1, 2, 4, 7, 14, 28\nThe factors of 35 are 1, 5, 7, 35\nThe largest common factor is 7.\n6\nExplanation:\nThe factors of 18 are 1, 2, 3, 6, 9, 18.\nThe factors of 48 are 1, 2, 3, 4, 6, 8, 12, 16, 24, 48.\nThe largest common factor is 6.\nNote\nYou need to ensure that your solution handles values of a and b that are up to 10^6 efficiently.\n1\nExplanation:GCD of 4 and 5 is 1.\n2\nExplanation:GCD of 6 and 8 is 2.\n5\nExplanation:GCD of 15 and 20 is 5.",
      "language": "cpp"
    },
    {
      "fileName": "KM to Miles.cpp",
      "name": "KM to Miles",
      "code": "\n\n/*\n\nExample:\n\nSuppose the input is: 5\n\nThe expected output would be: 3.106855\n\nNote:\n\nAlways ensure your output is a floating-point number. The resultant conversion should preserve the precision up to at least six decimal places.\nExample 1:\n\nInput:\n\nInput: Km = 1\n\nOutput:\n\n0.621371\nExplanation:Converting 1 KM gives 0.621371 Miles.\n\nExample 2:\n\nInput:\n\nInput: Km = 10\n\nOutput:\n\n6.21371\nExplanation:Converting 10 KM gives 6.21371 Miles.\n\nExample 3:\n\nInput:\n\nInput: Km = 50\n\nOutput:\n\n31.0686\nExplanation:Converting 50 KM gives 31.0686 Miles.\n\n*/\n\n\nclass Solution {\npublic:\n    double convertKmToMiles(int Km) {\n       return  (double)Km * 0.621371;\n    };\n};",
      "output": "0.621371\nExplanation:Converting 1 KM gives 0.621371 Miles.\n6.21371\nExplanation:Converting 10 KM gives 6.21371 Miles.\n31.0686\nExplanation:Converting 50 KM gives 31.0686 Miles.",
      "language": "cpp"
    },
    {
      "fileName": "LCM of Two Numbers.cpp",
      "name": "LCM of Two Numbers",
      "code": "\n\n\n/*\n\nExample\nInput:\n\n\n6 8  \nOutput:\n\n\n24  \nExplanation: The smallest number that both 6 and 8 divide without leaving a remainder is 24.\n\nMore Examples\nInput:\n\n\n15 20  \nOutput:\n\n\n60  \nExplanation: The smallest number that both 15 and 20 divide exactly is 60.\n\nExample 1:\n\nInput:\n\nInput: a = 4, b = 5\n\nOutput:\n\n20\nExplanation:LCM of 4 and 5 is 20.\n\nExample 2:\n\nInput:\n\nInput: a = 6, b = 8\n\nOutput:\n\n24\nExplanation:LCM of 6 and 8 is 24.\n\nExample 3:\n\nInput:\n\nInput: a = 15, b = 20\n\nOutput:\n\n60\nExplanation:LCM of 15 and 20 is 60.\n\n*/\n\nclass Solution {\npublic:\n  int findLCM(int a, int b) {\n    // Implement logic to find LCM of a and b\n    int l = (a > b) ? a : b;\n    int max = a * b;\n\n    for (int i = l; i <= max; i++) {\n      if (i % a == 0 && i % b == 0) {\n        return i;\n      }\n    }\n  }\n};",
      "output": "24\nExplanation: The smallest number that both 6 and 8 divide without leaving a remainder is 24.\n60\nExplanation: The smallest number that both 15 and 20 divide exactly is 60.\n20\nExplanation:LCM of 4 and 5 is 20.\n24\nExplanation:LCM of 6 and 8 is 24.\n60\nExplanation:LCM of 15 and 20 is 60.",
      "language": "cpp"
    },
    {
      "fileName": "Palindrome Number.cpp",
      "name": "Palindrome Number",
      "code": "#include<iostream>\nusing namespace std;\n/*\nExample:\nInput:\n\n\n121\nOutput:\n\n\ntrue\nExplanation: 121 reads the same forwards and backwards, hence it is a palindrome.\n\nInput:\n\n\n123\nOutput:\n\n\nfalse\nExplanation: 123 does not read the same forwards and backwards, so it is not a palindrome.\n\nExample 1:\n\nInput:\n\nInput: num = 121\n\nOutput:\n\nYes\nExplanation:121 is a palindrome.\n\nExample 2:\n\nInput:\n\nInput: num = 123\n\nOutput:\n\nNo\nExplanation:123 is not a palindrome.\n\nExample 3:\n\nInput:\n\nInput: num = 1221\n\nOutput:\n\nYes\nExplanation:1221 is a palindrome.\n\n*/\n\nclass Solution {\npublic:\n  string isPalindrome(int num) {\n    // Implement logic to check if num is a palindrome\n    // Placeholder return; user will complete the logic\n    int c = num;\n    int rev = 0;\n    while (num != 0) {\n      int digit = num % 10;\n      rev = rev * 10 + digit;\n      num = num / 10;\n    }\n\n    if (rev == c) {\n      return \"Yes\";\n    } else {\n      return \"No\";\n    }\n  }\n};",
      "output": "true\nExplanation: 121 reads the same forwards and backwards, hence it is a palindrome.\nfalse\nExplanation: 123 does not read the same forwards and backwards, so it is not a palindrome.\nYes\nExplanation:121 is a palindrome.\nNo\nExplanation:123 is not a palindrome.\nYes\nExplanation:1221 is a palindrome.",
      "language": "cpp"
    },
    {
      "fileName": "Print All Prime Numbers from 1 to N.cpp",
      "name": "Print All Prime Numbers from 1 to N",
      "code": "\n\n/*\n\nExample\nInput:\n\n\nN = 10\nOutput:\n\n\n[2, 3, 5, 7]\nExplanation:\n\nWhen 1 through 10 are evaluated, the numbers 2, 3, 5, and 7 meet the criteria of being prime numbers, as they cannot be divided evenly by any other numbers except for 1 and the number itself.\nYou need to ensure that your function effectively computes all the prime numbers for a given N, especially considering large values of N.\n\nExample 1:\n\nInput:\n\nInput: N = 10\n\nOutput:\n\n2 3 5 7\nExplanation:Prime numbers up to 10 are: 2, 3, 5, 7.\n\nExample 2:\n\nInput:\n\nInput: N = 20\n\nOutput:\n\n2 3 5 7 11 13 17 19\nExplanation:Prime numbers up to 20 are: 2, 3, 5, 7, 11, 13, 17, 19.\n\nExample 3:\n\nInput:\n\nInput: N = 1\n\nExplanation:There are no prime numbers up to 1.\n\n*/\n\n\n#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> printPrimes(int N) {\n        vector<int> primes;\n\n        for (int num = 2; num <= N; num++) {\n            bool isPrime = true;\n\n            for (int i = 2; i*i <= num; i++) {\n                if (num % i == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n\n            if (isPrime) {\n                primes.push_back(num);\n            }\n        }\n\n        return primes;\n    }\n};\n",
      "output": "[2, 3, 5, 7]\nExplanation:\nWhen 1 through 10 are evaluated, the numbers 2, 3, 5, and 7 meet the criteria of being prime numbers, as they cannot be divided evenly by any other numbers except for 1 and the number itself.\nYou need to ensure that your function effectively computes all the prime numbers for a given N, especially considering large values of N.\n2 3 5 7\nExplanation:Prime numbers up to 10 are: 2, 3, 5, 7.\n2 3 5 7 11 13 17 19\nExplanation:Prime numbers up to 20 are: 2, 3, 5, 7, 11, 13, 17, 19.",
      "language": "cpp"
    },
    {
      "fileName": "Reverse a Number.cpp",
      "name": "Reverse a Number",
      "code": "\n\n\n\n/*\n\nExample\nExample 1:\nInput: num = 12345\nOutput: 54321\nThe digits 12345 become 54321 when reversed.\n\nExample 2:\nInput: num = 100\nOutput: 1\nThe digits 100 become 001, but leading zeros are not part of the number, thus 1 is returned.\n\nExample 1:\n\nInput:\n\nInput: num = 123\n\nOutput:\n\n321\nExplanation:Reversing 123 gives 321.\n\nExample 2:\n\nInput:\n\nInput: num = 456\n\nOutput:\n\n654\nExplanation:Reversing 456 gives 654.\n\nExample 3:\n\nInput:\n\nInput: num = 78910\n\nOutput:\n\n1987\nExplanation:Reversing 78910 gives 1987.\n\n*/\n\nclass Solution {\npublic:\n  int reverseNumber(int num) {\n    // Implement logic to reverse the number\n    int ans = 0;\n    while (num != 0) {\n      int digit = num % 10;\n      ans = ans * 10 + digit;\n      num = num / 10;\n    }\n    return ans;\n  }\n};",
      "output": "The digits 12345 become 54321 when reversed.\nThe digits 100 become 001, but leading zeros are not part of the number, thus 1 is returned.\n321\nExplanation:Reversing 123 gives 321.\n654\nExplanation:Reversing 456 gives 654.\n1987\nExplanation:Reversing 78910 gives 1987.",
      "language": "cpp"
    },
    {
      "fileName": "Reverse an Integer.cpp",
      "name": "Reverse an Integer",
      "code": "\n\n#include<iostream>\n#include <climits>\n\nusing namespace std;\n\n/*\n\nExamples:\nExample 1:\nInput: x = 123\nOutput: 321\nExplanation: Reversing the digits of 123 gives 321.\nExample 2:\nInput: x = -123\nOutput: -321\nExplanation: Reversing the digits of -123 gives -321.\nExample 3:\nInput: x = 120\nOutput: 21\nExplanation: Reversing the digits of 120 gives 021, which is 21.\nNote:\nAssumptions about the environment restrict you from storing integers larger than 32 bits, which means you must handle overflow scenarios by returning 0.\n\nExample 1:\n\nInput:\n\nInput: x = 123\n\nOutput:\n\n321\nExplanation:Reversing 123 gives 321.\n\nExample 2:\n\nInput:\n\nInput: x = -456\n\nOutput:\n\n-654\nExplanation:Reversing -456 gives -654.\n\nExample 3:\n\nInput:\n\nInput: x = 100\n\nOutput:\n\n1\nExplanation:Reversing 100 removes leading zeros, giving 1.\n\n*/\n\nclass Solution {\npublic:\n    int reverse(int n) {\n       \n        if (n == 0) {\n            return 0;\n        }\n\n        bool flag;\n        if (n > 0) {\n            flag = 1;\n        } else {\n            flag = 0;\n        }\n\n        n = abs(n);\n\n        long long ans = 0;   \n        while (n != 0) {\n            int digit = n % 10;\n            ans = ans * 10 + digit;\n            n = n / 10;\n        }\n\n        if (ans > INT_MAX || ans < INT_MIN) {\n            return 0;\n        }\n\n        if (flag == 0) {\n            ans = -ans;\n        }\n        return (int)ans;\n    }\n};\n",
      "output": "Explanation: Reversing the digits of 123 gives 321.\nExplanation: Reversing the digits of -123 gives -321.\nExplanation: Reversing the digits of 120 gives 021, which is 21.\nNote:\nAssumptions about the environment restrict you from storing integers larger than 32 bits, which means you must handle overflow scenarios by returning 0.\n321\nExplanation:Reversing 123 gives 321.\n-654\nExplanation:Reversing -456 gives -654.\n1\nExplanation:Reversing 100 removes leading zeros, giving 1.",
      "language": "cpp"
    },
    {
      "fileName": "Set the Kth Bit.cpp",
      "name": "Set the Kth Bit",
      "code": "\n\n/*\n\nExample\nInput:\nn = 8\nk = 2\nOutput:\n12\nExplanation:\nThe binary representation of 8 is 1000.\nBy setting the 2nd bit (0-indexed), the binary becomes 1100, which is 12 in decimal.\nNote\nYou are expected to manipulate the integer's binary form directly.\nThe problem does not require an actual change in bits, just return the integer value after setting the k-th bit.\nExample 1:\n\nInput:\n\nInput: n = 5, k = 1\n\nOutput:\n\n7\nExplanation:Binary of 5: 101 \u2192 Setting bit at position 1 \u2192 111 (decimal 7).\n\nExample 2:\n\nInput:\n\nInput: n = 8, k = 2\n\nOutput:\n\n12\nExplanation:Binary of 8: 1000 \u2192 Setting bit at position 2 \u2192 1100 (decimal 12).\n\nExample 3:\n\nInput:\n\nInput: n = 10, k = 0\n\nOutput:\n\n11\nExplanation:Binary of 10: 1010 \u2192 Setting bit at position 0 \u2192 1011 (decimal 11).\n\n*/\n\nint setKthBit(int n, int k) {\n  // Complete the logic here\n  int mask = 1 << k;\n  int ans = n | mask;\n  return ans;\n\n  /*\n\n  Single | = Bitwise OR (works on bits). Example: 0101 | 0010 = 0111.\nDouble || = Logical OR (works on conditions like true/false).\nSo to set k-th bit, we use n | (1 << k) because bitwise OR changes the actual\nbits.\n\n  */\n}\n",
      "output": "12\nExplanation:\nThe binary representation of 8 is 1000.\nBy setting the 2nd bit (0-indexed), the binary becomes 1100, which is 12 in decimal.\nNote\nYou are expected to manipulate the integer's binary form directly.\nThe problem does not require an actual change in bits, just return the integer value after setting the k-th bit.\n7\nExplanation:Binary of 5: 101 \u2192 Setting bit at position 1 \u2192 111 (decimal 7).\n12\nExplanation:Binary of 8: 1000 \u2192 Setting bit at position 2 \u2192 1100 (decimal 12).\n11\nExplanation:Binary of 10: 1010 \u2192 Setting bit at position 0 \u2192 1011 (decimal 11).",
      "language": "cpp"
    },
    {
      "fileName": "Smallest Digit.cpp",
      "name": "Smallest Digit",
      "code": "\n\n\n/*\n\nExample\nInput: num = 5892\nOutput: 2\nExplanation: Digits in 5892 are 5, 8, 9, and 2. The smallest digit among these is 2.\n\nInput: num = 4356\nOutput: 3\nExplanation: The digits present in 4356 are 4, 3, 5, and 6. The smallest digit is 3.\n\nInput: num = 1005\nOutput: 0 Explanation: Digits in 1005 are 1, 0, 0, and 5. Here, 0 is the smallest digit.\n\nThe function should work efficiently within the defined constraints.\n\nExample 1:\n\nInput:\n\nInput: num = 123\n\nOutput:\n\n1\nExplanation:Smallest digit in 123 is 1.\n\nExample 2:\n\nInput:\n\nInput: num = 456\n\nOutput:\n\n4\nExplanation:Smallest digit in 456 is 4.\n\nExample 3:\n\nInput:\n\nInput: num = 78910\n\nOutput:\n\n0\nExplanation:Smallest digit in 78910 is 0.\n\n*/\n\nclass Solution {\npublic:\n  int smallestDigit(int num) {\n    // Implement logic to find the smallest digit\n    int smallest = 9;\n    if (num == 0)\n      return 0;\n\n    while (num != 0) {\n      int digit = num % 10;\n      if (digit < smallest) {\n        smallest = digit;\n      }\n      num = num / 10;\n    }\n    return smallest;\n  }\n};",
      "output": "Explanation: Digits in 5892 are 5, 8, 9, and 2. The smallest digit among these is 2.\nExplanation: The digits present in 4356 are 4, 3, 5, and 6. The smallest digit is 3.\nThe function should work efficiently within the defined constraints.\n1\nExplanation:Smallest digit in 123 is 1.\n4\nExplanation:Smallest digit in 456 is 4.\n0\nExplanation:Smallest digit in 78910 is 0.",
      "language": "cpp"
    },
    {
      "fileName": "Sum of Digits.cpp",
      "name": "Sum of Digits",
      "code": "\n\n\n\n/*\n\nExamples\nExample 1:\nInput:\n\n\nnum = 12345\nOutput:\n\n\n15\nExplanation:\n\nThe individual digits of the number 12345 are 1, 2, 3, 4, and 5. Their sum is 1 + 2 + 3 + 4 + 5 = 15.\n\nExample 2:\nInput:\n\n\nnum = 0\nOutput:\n\n\n0\nExplanation:\n\nThe only digit here is 0, so the sum is 0.\n\nExample 1:\n\nInput:\n\nInput: num = 123\n\nOutput:\n\n6\nExplanation:Sum of 1, 2, and 3 is 6.\n\nExample 2:\n\nInput:\n\nInput: num = 456\n\nOutput:\n\n15\nExplanation:Sum of 4, 5, and 6 is 15.\n\nExample 3:\n\nInput:\n\nInput: num = 0\n\nOutput:\n\n0\nExplanation:Sum of digits in 0 is 0.\n\n*/\n\n\nclass Solution {\npublic:\n  int sumOfDigits(int num) {\n    // Implement logic to calculate the sum of digits\n    int sum = 0;\n    while (num != 0) {\n      sum = sum + num % 10;\n      num = num / 10;\n    }\n    return sum;\n  }\n};",
      "output": "15\nExplanation:\nThe individual digits of the number 12345 are 1, 2, 3, 4, and 5. Their sum is 1 + 2 + 3 + 4 + 5 = 15.\n0\nExplanation:\nThe only digit here is 0, so the sum is 0.\n6\nExplanation:Sum of 1, 2, and 3 is 6.\n15\nExplanation:Sum of 4, 5, and 6 is 15.\n0\nExplanation:Sum of digits in 0 is 0.",
      "language": "cpp"
    }
  ],
  "Patterns-printing": [
    {
      "fileName": "Alphabet Triangle Pattern.cpp",
      "name": "Alphabet Triangle Pattern",
      "code": "\n#include<iostream>\nusing namespace std;\n\n/*\n\nExample\nFor instance, if the input n is 5, the expected output should be:\n\n\nA\nAB\nABC\nABCD\nABCDE\nThis illustrates a triangle with 5 rows, where each row begins with the letter 'A' and extends through the i-th letter of the alphabet for that row number, where i is the row index starting from 1.\n\nExample 1:\n\nInput:\n\nn=1\n\nOutput:\n\nA\nExplanation:A single row with 'A'.\n\nExample 2:\n\nInput:\n\nn=2\n\nOutput:\n\nA\nAB\nExplanation:A triangle with two rows.\n\nExample 3:\n\nInput:\n\nn=3\n\nOutput:\n\nA\nAB\nABC\nExplanation:A triangle with three rows.\n\n*/\n\n\nclass Solution {\npublic:\n    void printAlphabetTriangle(int n) {\n        // Implement the pattern printing logic here\n        for(int i=1;i<=n;i++){\n            for(int j=0;j<i;j++){\n                cout<<char('A'+j);\n            }\n            cout<<endl;\n        }\n    }\n};",
      "output": "A\nExplanation:A single row with 'A'.\nA\nAB\nExplanation:A triangle with two rows.\nA\nAB\nABC\nExplanation:A triangle with three rows.",
      "language": "cpp"
    },
    {
      "fileName": "Floyd\u2019s Triangle Pattern.cpp",
      "name": "Floyd\u2019s Triangle Pattern",
      "code": "\n#include<iostream>\nusing namespace std;\n\n\n/*\n\nExample\nInput:\n\nn = 4\n\nOutput:\n\n\n1\n2 3\n4 5 6\n7 8 9 10\nExplanation:\n\nThe first row has 1 number: 1.\nThe second row has 2 numbers: 2, 3.\nThe third row has 3 numbers: 4, 5, 6.\nThe fourth row has 4 numbers: 7, 8, 9, 10.\nThese rows cumulatively form Floyd\u2019s Triangle with 4 rows. The numbers continue serially across the rows, forming a smooth sequence.\n\nExample 1:\n\nInput:\n\nn=1\n\nOutput:\n\n1\nExplanation:The first row of Floyd's Triangle.\n\nExample 2:\n\nInput:\n\nn=2\n\nOutput:\n\n1\n2 3\nExplanation:The first two rows of Floyd's Triangle.\n\nExample 3:\n\nInput:\n\nn=3\n\nOutput:\n\n1\n2 3\n4 5 6\nExplanation:The first three rows of Floyd's Triangle.\n\n*/\n\nclass Solution {\npublic:\n    void printFloydsTriangle(int n) {\n        // Implement the pattern printing logic here\n        int count=1;\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=i;j++){\n                cout<<count<<\" \";\n                count++;\n            }\n            cout<<endl;\n        }\n    }\n};",
      "output": "1\n2 3\n4 5 6\n7 8 9 10\nExplanation:\nThe first row has 1 number: 1.\nThe second row has 2 numbers: 2, 3.\nThe third row has 3 numbers: 4, 5, 6.\nThe fourth row has 4 numbers: 7, 8, 9, 10.\nThese rows cumulatively form Floyd\u2019s Triangle with 4 rows. The numbers continue serially across the rows, forming a smooth sequence.\n1\nExplanation:The first row of Floyd's Triangle.\n1\n2 3\nExplanation:The first two rows of Floyd's Triangle.\n1\n2 3\n4 5 6\nExplanation:The first three rows of Floyd's Triangle.",
      "language": "cpp"
    },
    {
      "fileName": "Hollow Diamond Pattern.cpp",
      "name": "Hollow Diamond Pattern",
      "code": "#include <iostream>\nusing namespace std;\n\n/*\n\nExample 1:\n\nInput:\n\nn = 1\n\nOutput:\n\n*\nExplanation:Smallest possible diamond with single star\n\nExample 2:\n\nInput:\n\nn = 2\n\nOutput:\n\n *\n* *\n *\nExplanation:Diamond with height 3 (2*n-1)\n\nExample 3:\n\nInput:\n\nn = 3\n\nOutput:\n\n  *\n * *\n*   *\n * *\n  *\nExplanation:Diamond with height 5 showing hollow structure\n\n*/\n\nclass Solution\n{\npublic:\n    void printHollowDiamond(int n)\n    {\n        // Top half including middle\n        for (int i = 1; i <= n; i++)\n        {\n            // Print leading spaces\n            for (int j = 1; j <= n - i; j++)\n                cout << \" \";\n\n            if (i == 1)\n            {\n                cout << \"*\";\n            }\n            else\n            {\n                cout << \"*\";\n                for (int j = 1; j <= 2 * i - 3; j++)\n                    cout << \" \";\n                cout << \"*\";\n            }\n            cout << endl;\n        }\n\n        // Bottom half\n        for (int i = n - 1; i >= 1; i--)\n        {\n            // Print leading spaces\n            for (int j = 1; j <= n - i; j++)\n                cout << \" \";\n\n            if (i == 1)\n            {\n                cout << \"*\";\n            }\n            else\n            {\n                cout << \"*\";\n                for (int j = 1; j <= 2 * i - 3; j++)\n                    cout << \" \";\n                cout << \"*\";\n            }\n            cout << endl;\n        }\n    }\n};\n",
      "output": "Explanation:Smallest possible diamond with single star\n*\nExplanation:Diamond with height 3 (2*n-1)\n*\n*\n*\nExplanation:Diamond with height 5 showing hollow structure",
      "language": "cpp"
    },
    {
      "fileName": "Hollow Pyramid Pattern.cpp",
      "name": "Hollow Pyramid Pattern",
      "code": "\n#include<iostream>\nusing namespace std;\n\n/*\n\nExample:\nFor example, if n = 5, the pattern would be:\n\n\n    *\n   * *\n  *   *\n *     *\n*********\nWhere each line is centered according to the base which has 2*n - 1 characters including spaces.\n\nExample 1:\n\nInput:\n\nn=1\n\nOutput:\n\n*\nExplanation:A single row pyramid with one '*' for n=1.\n\nExample 2:\n\nInput:\n\nn=2\n\nOutput:\n\n  *\n* * *\nExplanation:A hollow pyramid with two rows.\n\nExample 3:\n\nInput:\n\nn=3\n\nOutput:\n\n    *\n  *   *\n* * * * *\nExplanation:A hollow pyramid with three rows.\n\n*/\n\n\n\nclass Solution\n{\npublic:\n    void printHollowPyramid(int n)\n    {\n        // Implement the pattern printing logic here\n        for (int row = 1; row <= n; row++)\n        {\n            for (int colm = 1; colm <= n - row; colm++)\n            {\n                cout << \"  \";\n            }\n            if (row == 1)\n            {\n                cout << \"* \";\n            }\n            else if (row == n)\n            {\n                for (int colm = 1; colm <= (2 * n) - 1; colm++)\n                {\n                    cout << \"* \";\n                }\n            }\n            else\n            {\n                cout << \"* \";\n                for (int colm = 1; colm <= (2 * row) - 3; colm++)\n                {\n                    cout << \"  \";\n                }\n                cout << \"*\";\n            }\n            cout << endl;\n        }\n    }\n};",
      "output": "Explanation:A single row pyramid with one '*' for n=1.\n* *\nExplanation:A hollow pyramid with two rows.\n*\n* * * *\nExplanation:A hollow pyramid with three rows.",
      "language": "cpp"
    },
    {
      "fileName": "Hollow Rectangle Pattern.cpp",
      "name": "Hollow Rectangle Pattern",
      "code": "\n#include<iostream>\nusing namespace std;\n/*\n\nExample\nInput:\n\nn = 4\nm = 5\nOutput:\n\n* * * * * \n*       * \n*       * \n* * * * * \nIn this example, a rectangle of 4 rows and 5 columns is generated with a hollow inside and '*' characters on the border.\n\nExample 1:\n\nInput:\n\nn=2, m=5\n\nOutput:\n\n* * * * * \n* * * * * \nExplanation:For n=2, m=5, both rows are filled with '*' as it's only a two-row rectangle.\n\nExample 2:\n\nInput:\n\nn=3, m=7\n\nOutput:\n\n* * * * * * * \n*           * \n* * * * * * * \nExplanation:A hollow rectangle of 3 rows and 7 columns with '*' on the border.\n\nExample 3:\n\nInput:\n\nn=4, m=4\n\nOutput:\n\n* * * * \n*     * \n*     * \n* * * * \nExplanation:A hollow square-like rectangle of 4 rows and 4 columns.\n\n\n*/\n\n\n\nclass Solution {\npublic:\n  void printHollowRectangle(int n, int m) {\n    // Implement the pattern printing logic here\n    for (int row =1; row <= n; row++) {\n\n      if (row == 1 || row == n) {\n        for (int colm = 1; colm <= m; colm++) {\n          cout << \"* \";\n        }\n      } else {\n        cout << \"* \";\n        for (int colm = 1; colm <= (m - 2); colm++) {\n          cout << \"  \";\n        }\n        cout<< \"*  \";\n      }\n      cout << endl;\n    }\n  }\n};",
      "output": "* * * *\n*\n*\n* * * *\nIn this example, a rectangle of 4 rows and 5 columns is generated with a hollow inside and '*' characters on the border.\n* * * *\n* * * *\nExplanation:For n=2, m=5, both rows are filled with '*' as it's only a two-row rectangle.\n* * * * * *\n*\n* * * * * *\nExplanation:A hollow rectangle of 3 rows and 7 columns with '*' on the border.\n* * *\n*\n*\n* * *\nExplanation:A hollow square-like rectangle of 4 rows and 4 columns.",
      "language": "cpp"
    },
    {
      "fileName": "Hollow Right-Angle Triangle Pattern.cpp",
      "name": "Hollow Right-Angle Triangle Pattern",
      "code": "\n\n#include<iostream>\nusing namespace std;\n/*\n\nExample\nIf n = 5, the resulting pattern would be:\n\n\n*\n**\n* *\n*  *\n*****\nExplanation:\n\nLine 1 contains 1 star.\nLine 2 contains 2 stars.\nLine 3 has a star at the beginning and the end with a space in the middle.\nLine 4 has a star at the beginning and the end, with two spaces in between.\nLine 5 is completely filled with stars.\nExample 1:\n\nInput:\n\nn=2\n\nOutput:\n\n*\n* *\nExplanation:A hollow right-angle triangle pattern with two rows.\n\nExample 2:\n\nInput:\n\nn=3\n\nOutput:\n\n*\n* *\n* * *\nExplanation:A hollow right-angle triangle pattern with three rows.\n\nExample 3:\n\nInput:\n\nn=4\n\nOutput:\n\n*\n* *\n*   *\n* * * *\nExplanation:A hollow right-angle triangle pattern with four rows\n\n*/\n\nclass Solution\n{\npublic:\n    void printHollowRightAngleTriangle(int n)\n    {\n        // Implement the pattern printing logic here\n        for (int row = 1; row <= n; row++)\n        {\n            if (row == 1 || row == n)\n            {\n                for (int colm = 1; colm <= row; colm++)\n                {\n                    cout << \"* \";\n                }\n            }\n            else\n            {\n                cout << \"* \";\n                for (int colm = 1; colm <= (row - 2); colm++)\n                {\n                    cout << \"  \";\n                }\n                cout << \"* \";\n            }\n            cout << endl;\n        }\n    }\n};",
      "output": "*\nExplanation:A hollow right-angle triangle pattern with two rows.\n*\n* *\nExplanation:A hollow right-angle triangle pattern with three rows.\n*\n*\n* * *\nExplanation:A hollow right-angle triangle pattern with four rows",
      "language": "cpp"
    },
    {
      "fileName": "Hollow Square Pattern.cpp",
      "name": "Hollow Square Pattern",
      "code": "#include<iostream>\nusing namespace std;\n\n//Hollow Square Pattern\n\n/*\n\n*****\n*   *\n*   *\n*   *\n*****\n\n*/ \n\nclass Solution {\npublic:\n  void printHollowSquare(int n) {\n    // Implement the pattern printing logic here\n    for (int row = 1; row <= n; row++) {\n      if (row == 1 || row == n) {\n        for (int colm = 1; colm <= n; colm++) {\n          cout << \"* \";\n        }\n      }\n      else{\n      cout << \"* \";\n      for (int colm = 1; colm <= (n - 2);colm++) {\n        cout << \"  \";\n      }\n      cout << \"* \";\n      }\n      cout<<endl;\n    }\n \n  }\n};",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Hourglass Shape Pattern.cpp",
      "name": "Hourglass Shape Pattern",
      "code": "\n#include<iostream>\nusing namespace std;\n\n\n/*\n\nExample\nFor n = 4, the output would be:\n\n\n********\n ******\n  ****\n   **\n   **\n  ****\n ******\n********\nHere, the top four rows decrease and indent, while the last four rows increase and de-indent to complete the hourglass shape.\n\nExample 1:\n\nInput:\n\nn=2\n\nOutput:\n\n****\n **\n **\n****\nExplanation:An hourglass pattern with 2 rows in each half.\n\nExample 2:\n\nInput:\n\nn=3\n\nOutput:\n\n******\n ****\n  **\n  **\n ****\n******\nExplanation:An hourglass pattern with 3 rows in each half.\n\nExample 3:\n\nInput:\n\nn=4\n\nOutput:\n\n********\n ******\n  ****\n   **\n   **\n  ****\n ******\n********\nExplanation:An hourglass pattern with 4 rows in each half.\n\n*/\n\nclass Solution {\npublic:\n  void printHourglass(int n) {\n    // Implement the pattern printing logic here\n    // part-1\n    for (int i=1; i <= n; i++) {\n      // spaces\n      for (int j=1; j <= i - 1; j++) {\n        cout << \" \";\n      }\n      // stars\n      for (int j = 1; j <= 2 * (n - i + 1); j++) {\n        cout << \"*\";\n      }\n      cout << endl;\n    }\n    // part 2\n\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j <= n - i; j++) {\n        cout << \" \";\n      }\n      for (int j = 1; j <= 2 * i; j++) {\n        cout << \"*\";\n      }\n      cout << endl;\n    }\n  }\n};",
      "output": "***\n*\n*\n***\nExplanation:An hourglass pattern with 2 rows in each half.\n*****\n***\n*\n*\n***\n*****\nExplanation:An hourglass pattern with 3 rows in each half.\n*******\n*****\n***\n*\n*\n***\n*****\n*******\nExplanation:An hourglass pattern with 4 rows in each half.",
      "language": "cpp"
    },
    {
      "fileName": "Inverted Alphabet Triangle Pattern.cpp",
      "name": "Inverted Alphabet Triangle Pattern",
      "code": "\n#include<iostream>\nusing namespace std;\n\n\n\n\n/*\n\nExample\nFor n = 5, the expected output is:\n\n\nABCDE\nABCD\nABC\nAB\nA\nHere, each row in the resulting pattern decreases by one letter until only 'A' remains in the final row.\n\nThis task involves generating and printing this pattern based on the provided input value n.\n\nExample 1:\n\nInput:\n\nn=1\n\nOutput:\n\nA\nExplanation:A single row with 'A'.\n\nExample 2:\n\nInput:\n\nn=2\n\nOutput:\n\nAB\nA\nExplanation:An inverted triangle with two rows.\n\nExample 3:\n\nInput:\n\nn=3\n\nOutput:\n\nABC\nAB\nA\nExplanation:An inverted triangle with three rows.\n\n*/\n\nclass Solution {\npublic:\n    void printInvertedAlphabetTriangle(int n) {\n        // Implement the pattern printing logic here\n        for(int i=n;i>=1;i--){\n            for (int j = 0; j < i; j++) {\n                cout << char('A' + j);\n            }\n            cout<<endl;\n        }\n    }\n};",
      "output": "A\nExplanation:A single row with 'A'.\nAB\nA\nExplanation:An inverted triangle with two rows.\nABC\nAB\nA\nExplanation:An inverted triangle with three rows.",
      "language": "cpp"
    },
    {
      "fileName": "Inverted Right-Angle Triangle Pattern.cpp",
      "name": "Inverted Right-Angle Triangle Pattern",
      "code": "\n\n#include<iostream>\nusing namespace std;\n\n\n/*\n\nExample:\nIf the input n is 4, your output should be:\n\n\n* * * * \n* * * \n* * \n* \nExplanation:\nRow 1 has 4 asterisks, each followed by a space.\nRow 2 has 3 asterisks, each followed by a space.\nRow 3 has 2 asterisks, each followed by a space.\nRow 4 has 1 asterisk followed by a space.\nExample 1:\n\nInput:\n\nn=2\n\nOutput:\n\n* * \n* \nExplanation:An inverted right-angle triangle pattern of height 2.\n\nExample 2:\n\nInput:\n\nn=3\n\nOutput:\n\n* * * \n* * \n* \nExplanation:An inverted right-angle triangle pattern of height 3.\n\nExample 3:\n\nInput:\n\nn=5\n\nOutput:\n\n* * * * * \n* * * * \n* * * \n* * \n* \nExplanation:An inverted right-angle triangle pattern of height 5.\n\n*/\n\n\nclass Solution {\npublic:\n    void printInvertedRightAngleTriangle(int n) {\n        // Implement the pattern printing logic here\n        for(int row=0;row<n;row++){\n            for(int colm=0;colm<(n-row);colm++){\n                cout<<\"* \";\n            }\n            cout<<endl;\n        }\n    }\n};",
      "output": "*\nExplanation:An inverted right-angle triangle pattern of height 2.\n* *\n*\nExplanation:An inverted right-angle triangle pattern of height 3.\n* * * *\n* * *\n* *\n*\nExplanation:An inverted right-angle triangle pattern of height 5.",
      "language": "cpp"
    },
    {
      "fileName": "Inverted Solid Pyramid Pattern.cpp",
      "name": "Inverted Solid Pyramid Pattern",
      "code": "\n#include<iostream>\nusing namespace std;\n\n/*\n\nExample\nConsider n = 3:\n\n\n*****\n ***\n  *\nExplanation:\n\nThe first row has 5 stars (2*3 - 1) and no leading spaces.\nThe second row has 3 stars and 1 leading space.\nThe third row contains 1 star with 2 leading spaces.\nYour task is to implement the function such that it generates the correct pattern for any valid value of n.\n\nExample 1:\n\nInput:\n\nn=1\n\nOutput:\n\n* \nExplanation:A single row pyramid with one '*' for n=1.\n\nExample 2:\n\nInput:\n\nn=2\n\nOutput:\n\n* * * \n  * \nExplanation:An inverted solid pyramid with two rows.\n\nExample 3:\n\nInput:\n\nn=3\n\nOutput:\n\n* * * * * \n  * * * \n    * \nExplanation:An inverted solid pyramid with three rows.\n\n*/\n\n\n\n\nclass Solution {\npublic:\n  void printInvertedSolidPyramid(int n) {\n\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j <= i - 1; j++) {\n        cout << \"  \";\n      }\n      for (int k = 1; k <= 2 * (n - i) + 1; k++) {\n        cout << \"* \";\n      }\n      cout << endl;\n    }\n  }\n}\n;",
      "output": "Explanation:A single row pyramid with one '*' for n=1.\n* *\nExplanation:An inverted solid pyramid with two rows.\n* * * *\n* *\nExplanation:An inverted solid pyramid with three rows.",
      "language": "cpp"
    },
    {
      "fileName": "Number Pyramid Pattern.cpp",
      "name": "Number Pyramid Pattern",
      "code": "\n#include<iostream>\nusing namespace std;\n\n\n\n\n/*\n\nExample:\nIf n is 4, the output should be:\n\n\n      1\n    1 2\n  1 2 3\n1 2 3 4\nDetails:\nThe pyramid is built from a series of rows with each subsequent row having increasing numbers.\nAlign each row in a centered format, filling the space to the left with necessary spaces to maintain the pyramid structure.\nExample 1:\n\nInput:\n\nn = 1\n\nOutput:\n\n1\nExplanation:Single row with one number\n\nExample 2:\n\nInput:\n\nn = 2\n\nOutput:\n\n 1 \n1 2 \nExplanation:Two rows showing progression of numbers\n\nExample 3:\n\nInput:\n\nn = 3\n\nOutput:\n\n  1 \n 1 2 \n1 2 3 \nExplanation:Three rows with proper spacing\n\n*/\n\nclass Solution {\npublic:\n  void printNumberPyramid(int n) {\n    // Implement the pattern printing logic here\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j <= n - i; j++) {\n        cout << \" \";\n      }\n      for (int j = 1; j <= i; j++) {\n        cout << j<<\" \";\n      }\n      cout << endl;\n    }\n  }\n};",
      "output": "1\nExplanation:Single row with one number\n1\n1 2\nExplanation:Two rows showing progression of numbers\n1\n1 2\n1 2 3\nExplanation:Three rows with proper spacing",
      "language": "cpp"
    },
    {
      "fileName": "Number Triangle Pattern.cpp",
      "name": "Number Triangle Pattern",
      "code": "\n#include<iostream>\nusing namespace std;\n\n\n/*\n\nExample\nFor an input n = 5, the printed output should be:\n\n\n1\n22\n333\n4444\n55555\nThe first row contains the number 1, repeated once.\nThe second row contains the number 2, repeated twice, and so on, up to row n.\nExample 1:\n\nInput:\n\nn=1\n\nOutput:\n\n1\nExplanation:A single row with 1.\n\nExample 2:\n\nInput:\n\nn=2\n\nOutput:\n\n1\n22\nExplanation:A triangle with two rows.\n\nExample 3:\n\nInput:\n\nn=3\n\nOutput:\n\n1\n22\n333\nExplanation:A triangle with three rows.\n\n*/\n\n\n\n\n\n\n\nclass Solution {\npublic:\n    void printNumberTriangle(int n) {\n        // Implement the pattern printing logic here\n        for (int i = 1; i <= n; i++)\n {\n     for (int j  = 1; j <= i; j++)\n     {\n        cout<<i;\n        /* code */\n     }\n     cout<<endl;\n     \n }\n \n    }\n};",
      "output": "1\nExplanation:A single row with 1.\n1\n22\nExplanation:A triangle with two rows.\n1\n22\n333\nExplanation:A triangle with three rows.",
      "language": "cpp"
    },
    {
      "fileName": "Reverse Alphabet Right Triangle Pattern.cpp",
      "name": "Reverse Alphabet Right Triangle Pattern",
      "code": "\n\n\n\n/*\n\nExample:\n\nInput:\n\n\nn = 5\nOutput:\n\n\n    E\n   DE\n  CDE\n BCDE\nABCDE\nExample 1:\n\nInput:\n\nn = 1\n\nOutput:\n\nA\nExplanation:Single letter pattern\n\nExample 2:\n\nInput:\n\nn = 2\n\nOutput:\n\nB\nAB\nExplanation:Two row pattern without spaces\n\nExample 3:\n\nInput:\n\nn = 3\n\nOutput:\n\nC\nBC\nABC\nExplanation:Three row pattern as shown in example\n\n*/\n\n\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n  void printReverseAlphabetTriangle(int n) {\n    for (int i = 1; i <= n; i++) {\n      // spaces\n      for (int j = 1; j <= n - i; j++) {\n        cout << \"\"; \n      }\n\n      // alphabets\n      for (int j = (n - i) + 65; j <= (n - i) + 65 + (i - 1); j++) {\n        cout << char(j);\n      }\n\n      cout << endl;\n    }\n  }\n};\n",
      "output": "E\nDE\nCDE\nBCDE\nABCDE\nA\nExplanation:Single letter pattern\nB\nAB\nExplanation:Two row pattern without spaces\nC\nBC\nABC\nExplanation:Three row pattern as shown in example",
      "language": "cpp"
    },
    {
      "fileName": "Rhombus Pattern.cpp",
      "name": "Rhombus Pattern",
      "code": "\n#include<iostream>\nusing namespace std;\n\n\n/*\n\nExample\nSuppose you are given n = 4. The rhombus pattern will be generated as follows:\n\n\n            * * * * \n        * * * * \n    * * * * \n* * * * \nIn this example, notice how each line contains exactly n stars and starts with a precise amount of space, reducing by one on each subsequent line.\n\nExample 1:\n\nInput:\n\nn=1\n\nOutput:\n\n* \nExplanation:A single row rhombus with one '*' for n=1.\n\nExample 2:\n\nInput:\n\nn=2\n\nOutput:\n\n * * \n* * \nExplanation:A rhombus pattern with two rows.\n\nExample 3:\n\nInput:\n\nn=3\n\nOutput:\n\n  * * * \n * * * \n* * * \nExplanation:A rhombus pattern with three rows.\n\n*/\n\n\n\nclass Solution {\npublic:\n    void printRhombus(int n) {\n        // Implement the pattern printing logic here\n\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=n-i;j++){\n                cout<<\" \";\n            }\n            for(int j=1;j<=n;j++){\n                cout<<\"* \";\n            }\n            cout<<endl;\n        }\n    }\n};",
      "output": "Explanation:A single row rhombus with one '*' for n=1.\n*\n*\nExplanation:A rhombus pattern with two rows.\n* *\n* *\n* *\nExplanation:A rhombus pattern with three rows.",
      "language": "cpp"
    },
    {
      "fileName": "Right-Angle Triangle Pattern.cpp",
      "name": "Right-Angle Triangle Pattern",
      "code": "\n\n#include<iostream>\nusing namespace std;\n/*\n\nExample:\nIf the input n = 4, the expected output is:\n\n\n*  \n* *  \n* * *  \n* * * *  \nEach line of output should correspond to a row of the triangle, following the pattern described above.\n\nExample 1:\n\nInput:\n\nn=2\n\nOutput:\n\n* \n* * \nExplanation:A right-angle triangle pattern of height 2.\n\nExample 2:\n\nInput:\n\nn=3\n\nOutput:\n\n* \n* * \n* * * \nExplanation:A right-angle triangle pattern of height 3.\n\nExample 3:\n\nInput:\n\nn=5\n\nOutput:\n\n* \n* * \n* * * \n* * * * \n* * * * * \nExplanation:A right-angle triangle pattern of height 5.\n\n*/\n\n\nclass Solution {\npublic:\n    void printRightAngleTriangle(int n) {\n        // Implement the pattern printing logic here\n        for(int i=1; i<=n;i++){\n            for(int j=1;j<=i;j++){\n                cout<<\"* \";\n            }\n            cout<<endl;\n        }\n    }\n};",
      "output": "*\nExplanation:A right-angle triangle pattern of height 2.\n*\n* *\nExplanation:A right-angle triangle pattern of height 3.\n*\n* *\n* * *\n* * * *\nExplanation:A right-angle triangle pattern of height 5.",
      "language": "cpp"
    },
    {
      "fileName": "Solid Diamond Pattern.cpp",
      "name": "Solid Diamond Pattern",
      "code": "\n\n\n#include<iostream>\nusing namespace std;\n\n/*\n\nExample\nFor instance, let n = 3:\n\nThe pattern should be:\n\n\n  *\n ***\n*****\n ***\n  *\nThis pattern reflects a diamond shape with the widest point being the third row, consisting of 5 '*', then tapering down symmetrically. Your task is to produce such a pattern for any valid integer input n between 1 and 20.\n\nExample 1:\n\nInput:\n\nn=1\n\nOutput:\n\n*\nExplanation:A single row with one '*' as n=1.\n\nExample 2:\n\nInput:\n\nn=2\n\nOutput:\n\n *\n***\n *\nExplanation:Diamond pattern with height 3 rows when n=2.\n\nExample 3:\n\nInput:\n\nn=3\n\nOutput:\n\n  *\n ***\n*****\n ***\n  *\nExplanation:Diamond pattern with height 5 rows when n=3.\n\n*/\n\n\nclass Solution {\npublic:\n    void printSolidDiamond(int n) {\n        // Implement the pattern printing logic here\n        for(int row=1; row<=n;row++){\n            for(int colm=1;colm<=n-row;colm++){\n                cout<<\" \";\n\n            }\n            for(int colm=1;colm<=(2*row)-1;colm++ ){\n                cout<<\"*\";\n            }\n            cout<<endl;\n        }\n        n--;\n        for(int row=1;row<=n;row++){\n            for(int colm=1; colm<=row;colm++){\n                cout<<\" \";\n            }\n            for(int colm=1;colm<=(2*n)-(2*row)+1; colm++){\n                cout<<\"*\";\n            }\n            cout<<endl;\n        }\n    }\n};",
      "output": "Explanation:A single row with one '*' as n=1.\n**\nExplanation:Diamond pattern with height 3 rows when n=2.\n**\n****\n**\nExplanation:Diamond pattern with height 5 rows when n=3.",
      "language": "cpp"
    },
    {
      "fileName": "Solid Pyramid Pattern.cpp",
      "name": "Solid Pyramid Pattern",
      "code": "\n#include<iostream>\nusing namespace std;\n\n/*\n\nExample\nFor n = 4, the output should be:\n\n\n   *\n  ***\n *****\n*******\nHere, the pyramid is built with 4 rows, where each row is centered by adjusting the spaces on either side of the asterisks.\n\nYour task is to write a function that generates this pattern for any valid input of n within the specified constraints.\n\nExample 1:\n\nInput:\n\nn=1\n\nOutput:\n\n* \nExplanation:A single row pyramid with one '*' for n=1.\n\nExample 2:\n\nInput:\n\nn=2\n\nOutput:\n\n  * \n* * * \nExplanation:A solid pyramid with two rows.\n\nExample 3:\n\nInput:\n\nn=3\n\nOutput:\n\n    * \n  * * * \n* * * * * \nExplanation:A solid pyramid with three rows.\n\n*/\n\n\nclass Solution {\npublic:\n    void printSolidPyramid(int n) {\n        for (int row = 0; row < n; row++) {\n            // Print double-spaces for alignment\n            for (int col = 0; col < (n - row - 1); col++) {\n                cout << \"  \";\n            }\n\n            // Print stars with space\n            for (int k = 0; k < (2 * row + 1); k++) {\n                cout << \"* \";\n            }\n\n            cout << endl;\n        }\n    }\n};\n",
      "output": "Explanation:A single row pyramid with one '*' for n=1.\n* *\nExplanation:A solid pyramid with two rows.\n* *\n* * * *\nExplanation:A solid pyramid with three rows.",
      "language": "cpp"
    },
    {
      "fileName": "Solid Rectangle Pattern.cpp",
      "name": "Solid Rectangle Pattern",
      "code": "#include <iostream>\nusing namespace std;\n\n/*\n\n* * * * *\n* * * * *\n* * * * *\n\n*/\n\n/*\n\nExample 1:\n\nInput:\n\nn=2, m=5\n\nOutput:\n\n* * * * *\n* * * * *\nExplanation:A solid rectangle of 2 rows and 5 columns.\n\nExample 2:\n\nInput:\n\nn=3, m=7\n\nOutput:\n\n* * * * * * *\n* * * * * * *\n* * * * * * *\nExplanation:A solid rectangle of 3 rows and 7 columns.\n\nExample 3:\n\nInput:\n\nn=5, m=3\n\nOutput:\n\n* * *\n* * *\n* * *\n* * *\n* * *\nExplanation:A solid rectangle of 5 rows and 3 columns.\n\n*/\n\nclass Solution\n{\npublic:\n    void printSolidRectangle(int n, int m)\n    {\n        // Implement the pattern printing logic here\n        for (int row = 1; row <= n; row++)\n        {\n            for (int colm = 1; colm <= m; colm++)\n            {\n                cout << \"* \";\n            }\n            cout << endl;\n        }\n    }\n};",
      "output": "* * * *\n* * * *\nExplanation:A solid rectangle of 2 rows and 5 columns.\n* * * * * *\n* * * * * *\n* * * * * *\nExplanation:A solid rectangle of 3 rows and 7 columns.\n* *\n* *\n* *\n* *\n* *\nExplanation:A solid rectangle of 5 rows and 3 columns.",
      "language": "cpp"
    },
    {
      "fileName": "Solid Square Pattern.cpp",
      "name": "Solid Square Pattern",
      "code": "#include <iostream>\nusing namespace std;\n\n/*\n\n****\n****\n****\n****\n\n*/\n\nclass Solution\n{\npublic:\n    void printSquare(int n)\n    {\n        // User to fill this part\n        for (int row = 1; row <= n; row++)\n        {\n            for (int colm = 1; colm <= n; colm++)\n            {\n                cout << \"*\";\n            }\n            cout << endl;\n        }\n    }\n};\n",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Symmetric Alphabet Pyramid Pattern.cpp",
      "name": "Symmetric Alphabet Pyramid Pattern",
      "code": "\n#include<iostream>\nusing namespace std;\n\n\n/*\n\nExample\nIf the input n = 5, the output should be:\n\n\n    A\n   ABA\n  ABCBA\n ABCDCBA\nABCDEDCBA\nOn the first row, print 'A'.\nOn the second row, print 'A', followed by 'B', then back to 'A', with appropriate spaces for centering.\nContinue this pattern, adding the next letter in the sequence and forming a symmetric reflection in each subsequent row.\nYour task is to implement the pattern generation logic for any integer input n, where n represents the number of rows, and n falls within the constraints specified.\n\nExample 1:\n\nInput:\n\nn=1\n\nOutput:\n\nA\nExplanation:A single row with 'A'.\n\nExample 2:\n\nInput:\n\nn=2\n\nOutput:\n\n A\nABA\nExplanation:A symmetric pyramid pattern with two rows.\n\nExample 3:\n\nInput:\n\nn=3\n\nOutput:\n\n  A\n ABA\nABCBA\nExplanation:A symmetric pyramid pattern with three rows.\n\n\n*/\n\nclass Solution {\npublic:\n  void printSymmetricAlphabetPyramid(int n) {\n    // Implement the pattern printing logic here\n    for (int i = 1; i <= n; i++) {\n\n      // spaces\n      for (int j = 1; j <= n - i; j++) {\n        cout << \" \";\n      }\n      // left side harf\n      for (char ch = 'A'; ch < 'A' + i; ch++) {\n        cout << ch;\n      }\n      // right side half\n      for (char ch = 'A' + i - 2; ch >= 'A'; ch--) {\n        cout << ch;\n      }\n      cout << endl;\n    }\n  }\n};",
      "output": "A\nExplanation:A single row with 'A'.\nA\nABA\nExplanation:A symmetric pyramid pattern with two rows.\nA\nABA\nABCBA\nExplanation:A symmetric pyramid pattern with three rows.",
      "language": "cpp"
    },
    {
      "fileName": "Symmetric Number Pyramid.cpp",
      "name": "Symmetric Number Pyramid",
      "code": "\n#include<iostream>\nusing namespace std;\n\n\n/*\n\n1      1\n12    21\n123  321\n12344321\n\n//examples\n\nExample 1:\n\nInput:\n\nn = 1\n\nOutput:\n\n11\nExplanation:Single row with just 1 and 1\n\nExample 2:\n\nInput:\n\nn = 2\n\nOutput:\n\n1  1\n1221\nExplanation:Two rows following the pattern rules\n\nExample 3:\n\nInput:\n\nn = 3\n\nOutput:\n\n1    1\n12  21\n123321\nExplanation:Three rows with proper spacing\n\n*/\n\n\n\n\nclass Solution {\npublic:\n  void printPattern(int n) {\n\n    for (int i = 1; i <= n; i++) {\n      // right side numbers\n      for (int j = 1; j <= i; j++) {\n        cout << j;\n      }\n      // spaces\n      for (int j = 1; j <= 2 * (n - i); j++) {\n        cout << \" \";\n      }\n      // left side numbers\n      for (int j = i; j >= 1; j--) {\n        cout << j;\n      }\n      cout << endl;\n    }\n  }\n};",
      "output": "11\nExplanation:Single row with just 1 and 1\n1  1\n1221\nExplanation:Two rows following the pattern rules\n1    1\n12  21\n123321\nExplanation:Three rows with proper spacing",
      "language": "cpp"
    },
    {
      "fileName": "Zig-Zag Pattern.cpp",
      "name": "Zig-Zag Pattern",
      "code": "\n\n\n/*\n\n*       *\n *     *\n  *   *\n   * *\n    *\n   * *\n  *   *\n *     *\n*       *\n\n\nExample\nIf n = 4, the expected output pattern is as shown above.\n\nExample 1:\n\nInput:\n\nn=3\n\nOutput:\n\n*     *\n *   *\n  * *\n   *\n  * *\n *   *\n*     *\nExplanation:A zig-zag pattern with 3 rows.\n\nExample 2:\n\nInput:\n\nn=4\n\nOutput:\n\n*       *\n *     *\n  *   *\n   * *\n    *\n   * *\n  *   *\n *     *\n*       *\nExplanation:A zig-zag pattern with 4 rows.\n\nExample 3:\n\nInput:\n\nn=5\n\nOutput:\n\n*         *\n *       *\n  *     *\n   *   *\n    * *\n     *\n    * *\n   *   *\n  *     *\n *       *\n*         *\nExplanation:A zig-zag pattern with 5 rows.\n\n\n\n*/\n\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    void printZigZag(int n) {\n        // ---- Part 1 (Upper Half) ----\n        int maxSpace = 2 * n - 1;\n\n        for (int row = 1; row <= n; row++) {\n            // leading spaces\n            for (int col = 1; col <= row - 1; col++) {\n                cout << \" \";\n            }\n\n            // star\n            cout << \"*\";\n\n            // middle spaces\n            for (int col = 1; col <= maxSpace; col++) {\n                cout << \" \";\n            }\n\n            // star\n            cout << \"*\";\n            cout << endl;\n\n            maxSpace -= 2;\n        }\n\n        // ---- Part 2 (Lower Half) ----\n        int npart2 = n + 1;\n        for (int row = 1; row <= npart2; row++) {\n            // leading spaces\n            for (int col = 1; col <= npart2 - row; col++) {\n                cout << \" \";\n            }\n\n            // stars\n            if (row == 1) {\n                cout << \"*\";\n            } else {\n                cout << \"*\";\n                for (int col = 1; col <= 2 * row - 3; col++) {\n                    cout << \" \";\n                }\n                cout << \"*\";\n            }\n            cout << endl;\n        }\n    }\n};\n",
      "output": "*\n*\n*\n*\n*\n*\nExplanation:A zig-zag pattern with 3 rows.\n*\n*\n*\n*\n*\n*\n*\n*\nExplanation:A zig-zag pattern with 4 rows.\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\nExplanation:A zig-zag pattern with 5 rows.",
      "language": "cpp"
    }
  ],
  "Pointers And Basic Maths": [
    {
      "fileName": "Count Primes.cpp",
      "name": "Count Primes",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// leetcode->204 -> https://leetcode.com/problems/count-primes/description/\n\n/*\n\nExample 1:\n\nInput: n = 10\nOutput: 4\nExplanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.\nExample 2:\n\nInput: n = 0\nOutput: 0\nExample 3:\n\nInput: n = 1\nOutput: 0\n\n\nConstraints:\n\n0 <= n <= 5 * 106\n\n*/\n\nclass Solution\n{\npublic:\n    int countPrimes(int n)\n    {\n\n        if (n == 0)\n            return 0;\n        vector<bool> prime(n, true); // all are prime parked already\n        prime[0] = prime[1] == false;\n        int ans = 0;\n        for (int i = 2; i < n; i++)\n        {\n            if (prime[i])\n            {\n                ans++;\n                int j = 2 * i;\n                while (j < n)\n                {\n                    prime[j] = false;\n                    j += i;\n                }\n            }\n        }\n        return ans;\n    }\n};",
      "output": "Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.\nConstraints:\n0 <= n <= 5 * 106",
      "language": "cpp"
    },
    {
      "fileName": "Gcd.cpp",
      "name": "Gcd",
      "code": "#include <iostream>\nusing namespace std;\n\n/*\n\nExamples:\n\nInput: a = 20, b = 28\nOutput: 4\nExplanation: GCD of 20 and 28 is 4\nInput: a = 60, b = 36\nOutput: 12\nExplanation: GCD of 60 and 36 is 12\n\n*/\n\n\n// this code submited in gfg without time limit exceed\n\nclass Solution\n{\npublic:\n    int gcd(int a, int b)\n    {\n        if (a == 0)\n            return b;\n        if (b == 0)\n            return a;\n\n        while (a > 0 && b > 0)\n        {\n            if (a > b)\n            {\n                a = a % b;\n            }\n            else\n            {\n                b = b % a;\n            }\n        }\n\n        return a == 0 ? b : a;\n    }\n};\n\n// this code not submit in gfg platform due to time limit exceed\nclass Solution\n{\npublic:\n    int gcd(int a, int b)\n    {\n        if (a == 0)\n            return b;\n        if (b == 0)\n            return a;\n\n        while (a > 0 && b > 0)\n        {\n            if (a > b)\n            {\n                a = a - b;\n            }\n            else\n            {\n                b = b - a;\n            }\n        }\n\n        return a == 0 ? b : a;\n    }\n};\n\n// this code not submit in gfg platform due to time limit exceed\nclass Solution\n{\npublic:\n    int gcd(int a, int b)\n    {\n\n        int l = min(a, b);\n\n        for (int i = l; i >= 1; i--)\n        {\n            if (a % i == 0 && b % i == 0)\n            {\n                return i;\n            }\n        }\n\n        return 1;\n    }\n};\n",
      "output": "Explanation: GCD of 20 and 28 is 4\nExplanation: GCD of 60 and 36 is 12",
      "language": "cpp"
    },
    {
      "fileName": "Lcm.cpp",
      "name": "Lcm",
      "code": "#include <iostream>\nusing namespace std;\n\n/*\n\nGiven two numbers a and b. The task is to find out their LCM.\n\n\nExamples:\n\nInput: a = 5, b = 10\nOutput: 10\nExplanation: LCM of 5 and 10 is 10\nInput: a = 14, b = 8\nOutput: 56\nExplanation: LCM of 14 and 8 is 56\n\n*/\n\n// User function Template for C++\n\n// first code->\n\nint LCM(int a, int b)\n{\n\n    // write your code here\n\n    // return LCM of a and b\n\n    int l;\n    if (a > b)\n        l = a;\n    else\n        l = b;\n    int r = a * b;\n\n    for (int i = l; i <= r; i++)\n    {\n        if (i % a == 0 && i % b == 0)\n        {\n            return i;\n        }\n    }\n    return a * b;\n}\n\n// second code ->\n\nint gcd(int a, int b)\n{\n    if (a == 0)\n        return b;\n    if (b == 0)\n        return a;\n\n    while (a > 0 && b > 0)\n    {\n        if (a > b)\n        {\n            a = a % b;\n        }\n        else\n        {\n            b = b % a;\n        }\n    }\n\n    return a == 0 ? b : a;\n}\n\nint LCM(int a, int b)\n{\n\n    int ans = (a * b) / gcd(a, b);\n\n    return ans;\n}",
      "output": "Explanation: LCM of 5 and 10 is 10\nExplanation: LCM of 14 and 8 is 56",
      "language": "cpp"
    }
  ],
  "Practice-Problems-Beginners": [
    {
      "fileName": "Average of Three Integers.cpp",
      "name": "Average of Three Integers",
      "code": "\n\nclass Solution {\npublic:\n    int averageOfThree(int a, int b, int c) {\n        // Implement the logic to calculate the average of a, b, and c\n        int average=(a+b+c)/3;\n         return average;\n    }\n};",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Calculate the Area of a Rectangle.cpp",
      "name": "Calculate the Area of a Rectangle",
      "code": "\n\n\n\nclass Solution {\npublic:\n    long long calculateArea(int length, int breadth) {\n        // Implement the logic to calculate area of a rectangle\n        return (long long)length * breadth;\n        \n    }\n};",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Calculate the Percentage.cpp",
      "name": "Calculate the Percentage",
      "code": "\n\nclass Solution {\npublic:\n    double calculatePercentage(int totalMarks, int obtainedMarks) {\n        // Implement the logic to calculate the percentage\n        return (obtainedMarks*100/totalMarks);\n    }\n};",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Check Number Sign.cpp",
      "name": "Check Number Sign",
      "code": "\n\n#include<iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    string checkNumberSign(int num) {\n        // Implement the logic to check if the number is positive, negative, or zero\n        if(num>0){\n            return \"Positive\";\n        }\n        else if(num<0){\n           return \"Negative\";\n        }\n        else{\n            return \"Zero\";\n\n        }\n    }\n};",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Check a number is prime or not     Easy 0.cpp",
      "name": "Check a number is prime or not     Easy 0",
      "code": "#include <iostream>\nusing namespace std;\n\n/*\n\nInput format\nA single integer n.\n\nOutput format\nPrint Yes if the number is prime, otherwise print No.\n\nExample 1:\n\nInput:\n\nn=336366944\n\nOutput:\n\nNo\nExplanation:336366944 is divisible by a number other than 1 and itself, so it is not a prime number.\n\nExample 2:\n\nInput:\n\nn=34259552\n\nOutput:\n\nNo\nExplanation:34259552 is divisible by a number other than 1 and itself, so it is not a prime number.\n\nExample 3:\n\nInput:\n\nn=827373662\n\nOutput:\n\nNo\nExplanation:827373662 is divisible by a number other than 1 and itself, so it is not a prime number.\n\n*/\n\nclass Solution\n{\npublic:\n    string isPrime(int n)\n    {\n        if (n == 0 || n == 1)\n            return \"No\";\n\n        for (int i = 2; i < n; i++)\n        {\n            if ((n % i) == 0)\n            {\n                return \"No\";\n            }\n        }\n        //  \u201cAgar \u221an tak koi factor nahi mila, to n prime hai.\u201d\n        return \"Yes\";\n    }\n};\n",
      "output": "No\nExplanation:336366944 is divisible by a number other than 1 and itself, so it is not a prime number.\nNo\nExplanation:34259552 is divisible by a number other than 1 and itself, so it is not a prime number.\nNo\nExplanation:827373662 is divisible by a number other than 1 and itself, so it is not a prime number.",
      "language": "cpp"
    },
    {
      "fileName": "Check given triangle is valid or not.cpp",
      "name": "Check given triangle is valid or not",
      "code": "#include <iostream>\nusing namespace std;\n\n/*\n\nInput format\nThree space-separated numbers representing the sides of the triangle.\n\nOutput format\nPrint Yes if a valid triangle can be formed, otherwise print No.\n\nExample 1:\n\nInput: a=29 b=37 c=18\n\nOutput: Yes\n\nExplanation: The sum of any two sides is greater than the third side, so the triangle is valid.\n\nExample 2:\n\nInput: a=44 b=26 c=48\n\nOutput: 'Yes'\n\nExplanation: The sum of any two sides is greater than the third side, so the triangle is valid.\n\nExample 3:\n\nInput: a=336366944 b=34259552 c=827373662\n\nOutput: 'No'\n\nExplanation: The sum of any two sides is not greater than the third side, so the triangle is not valid.\n\n*/\n\nclass Solution {\npublic:\n  string isValidTriangle(int a, int b, int c) {\n\n    if ((a + b) > c && (b + c) > a && (a + c) > b) {\n      return \"Yes\";\n    }\n    return \"No\";\n  }\n};",
      "output": "Explanation: The sum of any two sides is greater than the third side, so the triangle is valid.\nExplanation: The sum of any two sides is greater than the third side, so the triangle is valid.\nExplanation: The sum of any two sides is not greater than the third side, so the triangle is not valid.",
      "language": "cpp"
    },
    {
      "fileName": "Determine Day Type.cpp",
      "name": "Determine Day Type",
      "code": "\n\nclass Solution {\npublic:\n    string determineDayType(int day) {\n        // Implement the if-else-if ladder logic to determine if it's a weekday or weekend\n        if(day==6||day==7){\n   return  \"Weekend\";\n        }\n        else{\n            return \"Weekday\";\n        }\n    }\n};",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Determine Month Name.cpp",
      "name": "Determine Month Name",
      "code": "class Solution {\npublic:\n    string getMonthName(int month) {\n        // Implement the switch-case logic to determine the month name\n        switch(month){\n            case 1:\n            return \"January\";\n            break;\n             case 2:\n            return \"February\";\n            break;\n            case 3:\n            return \"March\";\n            break;\n             case 4:\n            return \"April\";\n            break;\n            case 5:\n            return \"May\";\n            break;\n             case 6:\n            return \"June\";\n            break;\n            case 7:\n            return \"July\";\n            break;\n             case 8:\n            return \"August\";\n            break;\n            case 9:\n            return \"September\";\n            break;\n             case 10:\n            return \"October\";\n            break;\n            case 11:\n            return \"November\";\n            break;\n             case 12:\n            return \"December\";\n            break;\n            \n        }\n    }\n};",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Find perimeter of a triangle.cpp",
      "name": "Find perimeter of a triangle",
      "code": "#include <iostream>\nusing namespace std;\n\n/*\n\nExample 1:\n\nInput:\n\na=562 b=727 c=349\n\nOutput:\n\n1638\nExplanation:The perimeter of a triangle is the sum of its three sides.\n\nExample 2:\n\nInput:\n\na=873 b=516 c=960\n\nOutput:\n\n2349\nExplanation:The perimeter of a triangle is the sum of its three sides.\n\nExample 3:\n\nInput:\n\na=317 b=529 c=702\n\nOutput:\n\n1548\nExplanation:The perimeter of a triangle is the sum of its three sides.\n\n*/\n\nclass Solution\n{\npublic:\n    int findPerimeter(int a, int b, int c) { return (a + b + c); }\n};\n",
      "output": "1638\nExplanation:The perimeter of a triangle is the sum of its three sides.\n2349\nExplanation:The perimeter of a triangle is the sum of its three sides.\n1548\nExplanation:The perimeter of a triangle is the sum of its three sides.",
      "language": "cpp"
    },
    {
      "fileName": "Find simple interest.cpp",
      "name": "Find simple interest",
      "code": "#include <iostream>\nusing namespace std;\n\n/*\n\nInput\nThree integers:\nP \u2192 Principal amount\nR \u2192 Rate of Interest (in %)\nT \u2192 Time (in years)\nOutput\nAn integer or floating-point value representing the Simple Interest.\nExample 1:\n\nInput:\n\nP=561830 R=73 T=35\n\nOutput:\n\n14354756\nExplanation:Simple Interest is calculated using the formula (P * R * T) / 100.\n\nExample 2:\n\nInput:\n\nP=915546 R=1 T=60\n\nOutput:\n\n549327\nExplanation:Simple Interest is calculated using the formula (P * R * T) / 100.\n\nExample 3:\n\nInput:\n\nP=872254 R=52 T=96\n\nOutput:\n\n593246\nExplanation:Simple Interest is calculated using the formula (P * R * T) / 100.\n\n*/\n\nclass Solution\n{\npublic:\n    int simpleInterest(int P, int R, int T)\n    {\n\n        return (P * R * T) / 100;\n    }\n};",
      "output": "14354756\nExplanation:Simple Interest is calculated using the formula (P * R * T) / 100.\n549327\nExplanation:Simple Interest is calculated using the formula (P * R * T) / 100.\n593246\nExplanation:Simple Interest is calculated using the formula (P * R * T) / 100.",
      "language": "cpp"
    },
    {
      "fileName": "Namaste-Codehelp.cpp",
      "name": "Namaste-Codehelp",
      "code": "\n\n#include<iostream>\nusing namespace std;\nint main(){\n   \n   cout<<\"@@Namaste World\";\n\n\n    return 0;\n}\n\n",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Print Counting from 1 to N.cpp",
      "name": "Print Counting from 1 to N",
      "code": "class Solution {\npublic:\n    void printCounting(int n) {\n        // Implement the loop logic to print numbers from 1 to n\n        for(int i=1;i<=n;i++){\n            cout<<i<<\" \";\n        }\n    }\n};",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Print Counting from N to 1.cpp",
      "name": "Print Counting from N to 1",
      "code": "#include<iostream>\nusing namespace std;\n\n\n\nclass Solution {\npublic:\n    void printCountingReverse(int n) {\n        // Print numbers from n down to 1\n        for (int i = n; i >= 1; i--) {\n            cout << i << \" \";\n        }\n    }\n};\n",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Print Half of an Integer.cpp",
      "name": "Print Half of an Integer",
      "code": "\n\n\nclass Solution {\npublic:\n    int halfOfInteger(int num) {\n        // Write down your code here\n        return num/2;\n        \n    }\n};",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Print Number Multiple Times.cpp",
      "name": "Print Number Multiple Times",
      "code": "class Solution {\npublic:\n  void printNumberMultipleTimes(int num, int n) {\n    // Implement the loop logic to print num, n times\n    for(int i=1;i<=n;i++){\n        cout<<num;\n        if(i<n){\n          cout<<\" \";\n        }\n    }\n  }\n};",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Print maximum of three numbers.cpp",
      "name": "Print maximum of three numbers",
      "code": "#include <iostream>\nusing namespace std;\n\n/*\n\nExample 1:\n\nInput:\n\na=3 b=7 c=5\n\nOutput:\n\n7\nExplanation:Among the three numbers 3, 7, and 5, the maximum is 7.\n\nExample 2:\n\nInput: a=-327266113 b=-931480897 c=654747322\n\nOutput: '654747322'\n\nExplanation: Among the numbers -327266113, -931480897, and 654747322, the maximum is 654747322.\n\nExample 3:\n\nInput: a=-861733977 b=65034374 c=580274960\n\nOutput: '580274960'\n\nExplanation: Among the numbers -861733977, 65034374, and 580274960, the maximum is 580274960.\n\n*/\n\nclass Solution\n{\npublic:\n    int maxi(int a, int b, int c)\n    {\n        if (a > b && a > c)\n            return a;\n        else if (b > a && b > c)\n            return b;\n        else\n            return c;\n    }\n};",
      "output": "7\nExplanation:Among the three numbers 3, 7, and 5, the maximum is 7.\nExplanation: Among the numbers -327266113, -931480897, and 654747322, the maximum is 654747322.\nExplanation: Among the numbers -861733977, 65034374, and 580274960, the maximum is 580274960.",
      "language": "cpp"
    },
    {
      "fileName": "Read-and-Print-an-Integer.cpp",
      "name": "Read-and-Print-an-Integer",
      "code": "\n// platform-codehelp\n\n\nclass Solution\n{\npublic:\n    int readAndPrintInteger(int num)\n    {\n        // enter your code here\n        return num;\n    }\n};",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Sum of N Numbers.cpp",
      "name": "Sum of N Numbers",
      "code": "class Solution {\npublic:\n    int sumNumbers(int n) {\n        //do not write cin >> n, as input n is already taken in the driver code\n        // Implement the loop logic to sum n numbers\n        int sum=0,x;\n        for(int i=1;i<=n;i++){\n            cin>>x;\n           sum=sum+x;\n        }\n        return sum;\n    }\n};",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Sum of Two Integers.cpp",
      "name": "Sum of Two Integers",
      "code": "\n\n\nclass Solution {\npublic:\n    int sumOfTwoIntegers(int a, int b) {\n        // Implement the logic to calculate the sum of a and b\n        return a+b;\n    \n    }\n};",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Voting Eligibility Checker.cpp",
      "name": "Voting Eligibility Checker",
      "code": "\n\nclass Solution {\npublic:\n    string checkVotingEligibility(int age) {\n        // Implement the logic to check voting eligibility\n        if(age>=18){\n            return \"Eligible to vote\";\n        }\n        else{\n            return \"Not eligible to vote\";\n        }\n    }\n};",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "evem-numbers.cpp",
      "name": "evem-numbers",
      "code": "class Solution {\npublic:\n    void printEvenNumbers(int n) {\n        bool first = true;  // to handle spaces\n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                if (!first) cout << \" \";  // print space before next number\n                cout << i;\n                first = false;\n            }\n        }\n    }\n};\n",
      "output": "Output not specified in comments.",
      "language": "cpp"
    }
  ],
  "Recursion": [
    {
      "fileName": "Coin-Change-2.cpp",
      "name": "Coin-Change-2",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nExample 1:\n\nInput: amount = 5, coins = [1, 2, 5] Output: 4 Explanation: There are four ways to make up the amount: 5 = 5 5 = 2 + 2 + 1 5 = 2 + 1 + 1 + 1 5 = 1 + 1 + 1 + 1 + 1\n\nExample 2:\n\nInput: amount = 3, coins = [2] Output: 0 Explanation: The amount of 3 cannot be made with the given coins.\n\nExample 3:\n\nInput: amount = 10, coins = [10] Output: 1\n\nNote:\n\nYou may assume that you have an infinite number of each kind of coin available.\nExample 1:\n\nInput:\n\nInput: amount = 5, coins = [1, 2, 5]\n\nOutput:\n\n4\nExplanation:Ways to make 5: (5), (2+2+1), (2+1+1+1), (1+1+1+1+1)\n\nExample 2:\n\nInput:\n\nInput: amount = 3, coins = [2]\n\n0\nExplanation:No way to make 3 using only coin 2.\n\nExample 3:\n\nInput:\n\nInput: amount = 10, coins = [10]\n\nOutput:\n\n1\nExplanation:Only one way: (10)\n\n*/\n\nclass Solution\n{\npublic:\n    int solve(int amount, int index, vector<int> &coins)\n    {\n        // base case\n        if (amount == 0)\n        {\n            return 1;\n        }\n        if (index >= coins.size())\n        {\n            return 0;\n        }\n        // current coin ko include krke number of ways find karlo\n        // main current coin ko tabhi include karunga jab bo amount se <=hoga\n        int includeAns = 0;\n        if (coins[index] <= amount)\n        {\n            includeAns = solve(amount - coins[index], index, coins);\n        }\n        // current coin ko exclude krke number of ways find karlo\n        int excludeAns = solve(amount, index + 1, coins);\n        // total ways nikal lo\n        int total = includeAns + excludeAns;\n        // return kardo\n        return total;\n    }\n\n    int change(int amount, vector<int> &coins)\n    {\n        int index = 0;\n        int ans = solve(amount, index, coins);\n        return ans;\n    }\n};\n\n// note-> is question ko krte hue leetcode pe tle aa gaya hai ise baad me hum dp se solve karenge achhe se\n",
      "output": "Note:\nYou may assume that you have an infinite number of each kind of coin available.\n4\nExplanation:Ways to make 5: (5), (2+2+1), (2+1+1+1), (1+1+1+1+1)\n1\nExplanation:Only one way: (10)",
      "language": "cpp"
    },
    {
      "fileName": "Compute Factorial of a Number Recursively.cpp",
      "name": "Compute Factorial of a Number Recursively",
      "code": "#include <iostream>\nusing namespace std;\n\n/*\n\nExample\nInput:\n\nn = 5\n\nOutput:\n\n120\n\nExplanation:\n\n5! = 5 * 4 * 3 * 2 * 1 = 120.\nInput:\n\nn = 0\n\nOutput:\n\n1\n\nExplanation:\n\n0! = 1 (by definition).\n\n*/\nint factorial(int n)\n{\n    if (n == 0)\n    {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}",
      "output": "120\nExplanation:\n5! = 5 * 4 * 3 * 2 * 1 = 120.\n1\nExplanation:\n0! = 1 (by definition).",
      "language": "cpp"
    },
    {
      "fileName": "Compute Fibonacci Numbers Recursively.cpp",
      "name": "Compute Fibonacci Numbers Recursively",
      "code": "#include <iostream>\nusing namespace std;\n\n/*\n\nExample:\nInput:\n\nn = 5\n\nOutput:\n\n5\n\nExplanation:\n\nF(0) = 0\nF(1) = 1\nF(2) = F(1) + F(0) = 1\nF(3) = F(2) + F(1) = 2\nF(4) = F(3) + F(2) = 3\nF(5) = F(4) + F(3) = 5\nSo, the 5th Fibonacci number is 5.\n\nExample 1:\n\nInput:\n\nInput: n = 0\n\n0\nExplanation:Fibonacci(0) = 0.\n\nExample 2:\n\nInput:\n\nInput: n = 1\n\nOutput:\n\n1\nExplanation:Fibonacci(1) = 1.\n\nExample 3:\n\nInput:\n\nInput: n = 2\n\nOutput:\n\n1\nExplanation:Fibonacci(2) = Fibonacci(1) + Fibonacci(0) = 1 + 0 = 1.\n\n*/\nclass Fibonacci\n{\npublic:\n    int fib(int n)\n    {\n        if (n == 0)\n            return 0;\n        if (n == 1)\n            return 1;\n        return fib(n - 1) + fib(n - 2);\n    }\n};",
      "output": "5\nExplanation:\nF(0) = 0\nF(1) = 1\nF(2) = F(1) + F(0) = 1\nF(3) = F(2) + F(1) = 2\nF(4) = F(3) + F(2) = 3\nF(5) = F(4) + F(3) = 5\nSo, the 5th Fibonacci number is 5.\n1\nExplanation:Fibonacci(1) = 1.\n1\nExplanation:Fibonacci(2) = Fibonacci(1) + Fibonacci(0) = 1 + 0 = 1.",
      "language": "cpp"
    },
    {
      "fileName": "Compute Power of a Number Recursively.cpp",
      "name": "Compute Power of a Number Recursively",
      "code": "#include <iostream>\nusing namespace std;\n\n/*\n\nExample:\nInput:\nbase = 2, exponent = 3\n\nOutput:\n8\n\nExplanation:\n\nStart with base = 2 and exponent = 3.\nCalculate 2^3: 2 * 2 * 2 = 8.\nReturn 8.\nNote:\nWhen exponent is 0, any base other than 0 should return 1.\nWhen base is 0 and exponent is 0, consider the result as 1 (by convention in this problem).\nExample 1:\n\nInput:\n\nInput: base = 2, exponent = 0\n\nOutput:\n\n1\nExplanation:Any number raised to power 0 is 1.\n\nExample 2:\n\nInput:\n\nInput: base = 2, exponent = 1\n\nOutput:\n\n2\nExplanation:2^1 = 2.\n\nExample 3:\n\nInput:\n\nInput: base = 2, exponent = 3\n\nOutput:\n\n8\nExplanation:2^3 = 2 \u00d7 2 \u00d7 2 = 8.\n\n*/\n\nint powerRecursive(int base, int exponent)\n{\n    if (exponent == 0)\n    {\n        return 1;\n    }\n    return base * powerRecursive(base, exponent - 1);\n}\n",
      "output": "8\nExplanation:\nStart with base = 2 and exponent = 3.\nCalculate 2^3: 2 * 2 * 2 = 8.\nReturn 8.\nNote:\nWhen exponent is 0, any base other than 0 should return 1.\nWhen base is 0 and exponent is 0, consider the result as 1 (by convention in this problem).\n1\nExplanation:Any number raised to power 0 is 1.\n2\nExplanation:2^1 = 2.\n8\nExplanation:2^3 = 2 \u00d7 2 \u00d7 2 = 8.",
      "language": "cpp"
    },
    {
      "fileName": "Compute the Sum of an Array using Recursion.cpp",
      "name": "Compute the Sum of an Array using Recursion",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\n\nExample\nInput:\n\nnums = [1, 2, 3, 4, 5]\n\nOutput:\n\n15\n\nExplanation: The sum of array elements is calculated as follows:\n\nStart from index = 0, numb = 1\nrecursiveSum(nums, 1) = 2 + recursiveSum(nums, 2)\nrecursiveSum(nums, 2) = 3 + recursiveSum(nums, 3)\nrecursiveSum(nums, 3) = 4 + recursiveSum(nums, 4)\nrecursiveSum(nums, 4) = 5\nrecursiveSum(nums, 5) = 0 (base case)\nWhen these are added together, the sum is 15.\n\nFunction Signature\ncpp int recursiveSum(std::vector& nums, int index);\n\nExample 1:\n\nInput:\n\nInput: n = 5, nums = [1, 2, 3, 4, 5]\n\nOutput:\n\n15\nExplanation:Sum of [1, 2, 3, 4, 5] is 1+2+3+4+5 = 15.\n\nExample 2:\n\nInput:\n\nInput: n = 4, nums = [10, 20, 30, 40]\n\nOutput:\n\n100\nExplanation:Sum of [10, 20, 30, 40] is 10+20+30+40 = 100.\n\nExample 3:\n\nInput:\n\nInput: n = 6, nums = [5, -5, 10, -10, 15, -15]\n\n0\nExplanation:Sum of [5, -5, 10, -10, 15, -15] is 0.\n\n*/\n\nint recursiveSum(vector<int> &nums, int index)\n{\n    if (nums.size() == index)\n    {\n        return 0;\n    }\n    return nums[index] + recursiveSum(nums, index + 1);\n}",
      "output": "15\nExplanation: The sum of array elements is calculated as follows:\nStart from index = 0, numb = 1\nrecursiveSum(nums, 1) = 2 + recursiveSum(nums, 2)\nrecursiveSum(nums, 2) = 3 + recursiveSum(nums, 3)\nrecursiveSum(nums, 3) = 4 + recursiveSum(nums, 4)\nrecursiveSum(nums, 4) = 5\nrecursiveSum(nums, 5) = 0 (base case)\nWhen these are added together, the sum is 15.\nFunction Signature\ncpp int recursiveSum(std::vector& nums, int index);\n15\nExplanation:Sum of [1, 2, 3, 4, 5] is 1+2+3+4+5 = 15.\n100\nExplanation:Sum of [10, 20, 30, 40] is 10+20+30+40 = 100.",
      "language": "cpp"
    },
    {
      "fileName": "Find Maximum Element in an Array using Recursion.cpp",
      "name": "Find Maximum Element in an Array using Recursion",
      "code": "#include <iostream>\n#include <climits>\n#include <vector>\nusing namespace std;\n\nvoid getMaxElement(const vector<int> &arr, int n, int index, int &maxi)\n{\n    // base case\n    if (index >= n)\n    {\n        return;\n    }\n\n    // 1 case main solve karunga\n    maxi = max(maxi, arr[index]);\n\n    // recursive call\n    getMaxElement(arr, n, index + 1, maxi);\n}\n\nint findMaxRecursively(const vector<int> &arr, int index)\n{\n    int maxi = INT_MIN;\n    getMaxElement(arr, arr.size(), 0, maxi);\n    return maxi;\n}\n",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Find Minimum Element in an Array using Recursion.cpp",
      "name": "Find Minimum Element in an Array using Recursion",
      "code": "#include <iostream>\n#include <climits>\n#include <vector>\nusing namespace std;\n\n/*\n\nExample 1:\n\nInput:\n\nInput: n = 5, arr = [3, 1, 4, 1, 5]\n\nOutput:\n\n1\nExplanation:The minimum element in [3, 1, 4, 1, 5] is 1.\n\nExample 2:\n\nInput:\n\nInput: n = 4, arr = [10, 20, 5, 15]\n\nOutput:\n\n5\nExplanation:The minimum element in [10, 20, 5, 15] is 5.\n\nExample 3:\n\nInput:\n\nInput: n = 6, arr = [5, 5, 5, 5, 5, 5]\n\nOutput:\n\n5\nExplanation:All elements are the same, so min is 5.\n\n*/\n\nvoid getMinElement(const vector<int> &arr, int n, int index, int &mini)\n{\n    // base case\n    if (index >= n)\n    {\n        return;\n    }\n\n    // 1 case main solve karunga\n    mini = min(mini, arr[index]);\n\n    // recursive call\n    getMinElement(arr, n, index + 1, mini);\n}\n\nint findMinRecursively(const vector<int> &arr, int n)\n{\n    int mini = INT_MAX;\n    getMinElement(arr, n, 0, mini);\n    return mini;\n}",
      "output": "1\nExplanation:The minimum element in [3, 1, 4, 1, 5] is 1.\n5\nExplanation:The minimum element in [10, 20, 5, 15] is 5.\n5\nExplanation:All elements are the same, so min is 5.",
      "language": "cpp"
    },
    {
      "fileName": "Generate All Subsequences of a String.cpp",
      "name": "Generate All Subsequences of a String",
      "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n\nExample 1:\n\n\nInput: s = \"a\"\nOutput: [\"\", \"a\"]\nExample 2:\n\n\nInput: s = \"ab\"\nOutput: [\"\", \"a\", \"b\", \"ab\"]\nExample 3:\n\n\nInput: s = \"abc\"\nOutput: [\"\", \"a\", \"b\", \"c\", \"ab\", \"ac\", \"bc\", \"abc\"]\n(The order of subsequences in the output list may vary.)\n\nExample 4:\n\n\nInput: s = \"\"\nOutput: [\"\"]\nExample 1:\n\nInput: s = abc\n\nOutput: [, a, ab, abc, ac, b, bc, c]\n\nExplaintation: This test case covers a standard scenario with distinct characters. All 2^3 = 8 subsequences are generated and returned in lexicographical order.\n\nExample 2:\n\nInput: s = a\n\nOutput: [, a]\n\nExplaintation: This is a basic test case for a single-character string. It should produce the empty string and the character itself as subsequences. The order in the output list is lexicographical due to the use of std::set for uniqueness.\n\nExample 3:\n\nInput: s =\n\nOutput: []\n\nExplaintation: Tests the edge case of an empty input string. The only subsequence is the empty string itself, represented as an empty list.\n\n*/\n\nclass Solution\n{\npublic:\n    void solve(string s, int index, string output, vector<string> &ans)\n    {\n        // base case\n        if (index >= s.length())\n        {\n            // 2 kaam ->rukhna jab h,subsequence ready hota hai is case pr\n            ans.push_back(output);\n            return;\n        }\n        // 1 case main solve kr deta hu\n        // ek character ko pakad ke include ans exlude krdeta hu\n        // baki recursion sambhal lega\n        char ch = s[index];\n        // include\n        output.push_back(ch);\n        solve(s, index + 1, output, ans);\n        // backtrack\n        output.pop_back();\n        // exclude\n        solve(s, index + 1, output, ans);\n    }\n\n    std::vector<std::string> generateAllSubsequences(std::string s)\n    {\n        vector<string> ans;\n        int index = 0;\n        string output = \"\";\n        solve(s, index, output, ans);\n        return ans;\n    }\n};",
      "output": "(The order of subsequences in the output list may vary.)\nExplaintation: This test case covers a standard scenario with distinct characters. All 2^3 = 8 subsequences are generated and returned in lexicographical order.\nExplaintation: This is a basic test case for a single-character string. It should produce the empty string and the character itself as subsequences. The order in the output list is lexicographical due to the use of std::set for uniqueness.\nExplaintation: Tests the edge case of an empty input string. The only subsequence is the empty string itself, represented as an empty list.",
      "language": "cpp"
    },
    {
      "fileName": "House Robber.cpp",
      "name": "House Robber",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nIn this problem, you are tasked with determining how much money you can rob from a line of houses without tripping the security systems. Each house has a certain amount of money, represented as a non-negative integer in an array nums. The catch is that robbing two directly adjacent houses will trigger the alarm, so you need to strategically choose which houses to rob to maximize your total haul for the night.\n\nExample 1:\n\nInput:\n\nnums=[1,2,3,1]\n\nOutput:\n\n4\nExplanation:Rob houses 1 and 3 (money = 1 + 3 = 4) to get maximum amount.\n\nExample 2:\n\nInput:\n\nnums=[2,7,9,3,1]\n\nOutput:\n\n12\nExplanation:Rob houses 1, 3, and 5 (money = 2 + 9 + 1 = 12) for maximum amount.\n\nExample 3:\n\nInput:\n\nnums=[2,1,1,2]\n\nOutput:\n\n4\nExplanation:Rob houses 1 and 4 (money = 2 + 2 = 4) for maximum amount.\n\n*/\n\nclass Solution\n{\npublic:\n    int solve(vector<int> &nums, int index)\n    {\n        // base case\n        if (index >= nums.size())\n        {\n            return 0;\n        }\n        // include\n        int includeAns = nums[index] + solve(nums, index + 2);\n        // exclude\n        int excludeAns = 0 + solve(nums, index + 1);\n        int finalAns = max(includeAns, excludeAns);\n        return finalAns;\n    }\n\n    int rob(vector<int> &nums)\n    {\n        int index = 0;\n        int ans = solve(nums, index);\n        return ans;\n    }\n};",
      "output": "4\nExplanation:Rob houses 1 and 3 (money = 1 + 3 = 4) to get maximum amount.\n12\nExplanation:Rob houses 1, 3, and 5 (money = 2 + 9 + 1 = 12) for maximum amount.\n4\nExplanation:Rob houses 1 and 4 (money = 2 + 2 = 4) for maximum amount.",
      "language": "cpp"
    },
    {
      "fileName": "Integer to English Words Using Recursion.cpp",
      "name": "Integer to English Words Using Recursion",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nExample:\nExample 1:\n\nInput: num = 123\nOutput: \"One Hundred Twenty Three\"\nExample 2:\n\nInput: num = 12345\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\nExample 3:\n\nInput: num = 1234567\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\nExample 4:\n\nInput: num = 0\nOutput: \"Zero\"\nNote:\nHandle special cases separately, such as when num is 0. The number will always fall within the given constraints, so focus on crafting a recursive approach for converting the integer to its English words representation.\n\nExample 1:\n\nInput:\n\nnum=123\n\nOutput:\n\nOne Hundred Twenty Three\nExplanation:123 translates to 'One Hundred Twenty Three'\n\nExample 2:\n\nInput:\n\nnum=45\n\nOutput:\n\nForty Five\nExplanation:45 translates to 'Forty Five'\n\nExample 3:\n\nInput:\n\nnum=1001\n\nOutput:\n\nOne Thousand One\nExplanation:1001 translates to 'One Thousand One'\n\n*/\n\nclass Solution\n{\npublic:\n    vector<pair<int, string>> mp = {{1000000000, \"Billion\"},\n                                    {1000000, \"Million\"},\n                                    {1000, \"Thousand\"},\n                                    {100, \"Hundred\"},\n                                    {90, \"Ninety\"},\n                                    {80, \"Eighty\"},\n                                    {70, \"Seventy\"},\n                                    {60, \"Sixty\"},\n                                    {50, \"Fifty\"},\n                                    {40, \"Forty\"},\n                                    {30, \"Thirty\"},\n                                    {20, \"Twenty\"},\n                                    {19, \"Nineteen\"},\n                                    {18, \"Eighteen\"},\n                                    {17, \"Seventeen\"},\n                                    {16, \"Sixteen\"},\n                                    {15, \"Fifteen\"},\n                                    {14, \"Fourteen\"},\n                                    {13, \"Thirteen\"},\n                                    {12, \"Twelve\"},\n                                    {11, \"Eleven\"},\n                                    {10, \"Ten\"},\n                                    {9, \"Nine\"},\n                                    {8, \"Eight\"},\n                                    {7, \"Seven\"},\n                                    {6, \"Six\"},\n                                    {5, \"Five\"},\n                                    {4, \"Four\"},\n                                    {3, \"Three\"},\n                                    {2, \"Two\"},\n                                    {1, \"One\"}};\n    string numberToWords(int num)\n    {\n        if (num == 0)\n            return \"Zero\";\n\n        for (auto it : mp)\n        {\n            if (num >= it.first)\n            {\n                string a = \"\";\n                if (num >= 100)\n                {\n                    a = numberToWords(num / it.first) + \" \";\n                }\n                string b = it.second;\n                string c = \"\";\n                if (num % it.first != 0)\n                {\n                    c = \" \" + numberToWords(num % it.first);\n                }\n                return a + b + c;\n            }\n        }\n        return \"\";\n    }\n};",
      "output": "Note:\nHandle special cases separately, such as when num is 0. The number will always fall within the given constraints, so focus on crafting a recursive approach for converting the integer to its English words representation.\nOne Hundred Twenty Three\nExplanation:123 translates to 'One Hundred Twenty Three'\nForty Five\nExplanation:45 translates to 'Forty Five'\nOne Thousand One\nExplanation:1001 translates to 'One Thousand One'",
      "language": "cpp"
    },
    {
      "fileName": "Last Index of a Character in a String.cpp",
      "name": "Last Index of a Character in a String",
      "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n/*\n\nExample 1:\n\nInput:\n\nstr = 'hello', x = 'l'\n\nOutput:\n\n3\nExplanation:The last occurrence of 'l' is at index 3.\n\nExample 2:\n\nInput:\n\nstr = 'world', x = 'o'\n\nOutput:\n\n1\nExplanation:The last occurrence of 'o' is at index 1.\n\nExample 3:\n\nInput:\n\nstr = 'abcd', x = 'z'\n\nOutput:\n\n-1\nExplanation:The character 'z' is not present in the string.\n\nConstraints\n\n1 <= str.length <= 10^5\nstr consists of lowercase and uppercase English letters, digits, and symbols.\nx is a single character.\n\n*/\n\n//   left to right solution\nclass Solution\n{\npublic:\n    void findLastOccLTR(string &str, char x, int index, int &ans)\n    {\n\n        // base case\n        if (index >= str.size())\n        {\n            return;\n        }\n\n        // ek case solution\n        if (str[index] == x)\n        {\n            ans = index; // har match pe update hota rahega\n        }\n\n        // recursion\n        findLastOccLTR(str, x, index + 1, ans);\n    }\n\n    int lastIndex(string str, char x)\n    {\n        int ans = -1;\n        findLastOccLTR(str, x, 0, ans);\n        return ans;\n    }\n};\n\n\n\n// right to left soltuion\n\nclass Solution\n{\npublic:\n    void findLastOccRTL(string &str, char x, int index, int &ans)\n    {\n\n        // base case\n        if (index < 0)\n        {\n            return;\n        }\n\n        // ek case solution\n        if (str[index] == x)\n        {\n            ans = index; // pehla match from right = last occurrence\n            return;      // recursion yahin stop\n        }\n\n        // recursion\n        findLastOccRTL(str, x, index - 1, ans);\n    }\n\n    int lastIndex(string str, char x)\n    {\n        int ans = -1;\n        findLastOccRTL(str, x, str.size() - 1, ans);\n        return ans;\n    }\n};\n",
      "output": "3\nExplanation:The last occurrence of 'l' is at index 3.\n1\nExplanation:The last occurrence of 'o' is at index 1.\n-1\nExplanation:The character 'z' is not present in the string.\nConstraints\n1 <= str.length <= 10^5\nstr consists of lowercase and uppercase English letters, digits, and symbols.\nx is a single character.",
      "language": "cpp"
    },
    {
      "fileName": "Print All Even Numbers in an Array using Recursion     Easy 0.cpp",
      "name": "Print All Even Numbers in an Array using Recursion     Easy 0",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nExample\nInput:\n\narr = [2, 3, 5, 6, 8, 11] n = 6\n\nOutput:\n\n2 6 8\n\nExplanation:\n\nThe numbers 2, 6, and 8 from the array are even numbers, and hence they are printed.\nThe numbers 3, 5, and 11 are odd, so they are not printed.\nExample 1:\n\nInput:\n\nInput: n = 5, arr = [1, 2, 3, 4, 5]\n\nOutput:\n\n2 4\nExplanation:Only even numbers in [1, 2, 3, 4, 5] are 2 and 4.\n\nExample 2:\n\nInput:\n\nInput: n = 4, arr = [10, 21, 32, 45]\n\nOutput:\n\n10 32\nExplanation:Even numbers in [10, 21, 32, 45] are 10 and 32.\n\nExample 3:\n\nInput:\n\nInput: n = 6, arr = [2, 4, 6, 8, 10, 12]\n\nOutput:\n\n2 4 6 8 10 12\nExplanation:All numbers are even.\n\n*/\n\nvector<int> printEvenNumbers(vector<int> &arr, int index)\n{\n    // Base case\n    if (index >= arr.size())\n        return {};\n\n    // Recursive case\n    std::vector<int> result = printEvenNumbers(arr, index + 1);\n\n    if (abs(arr[index]) % 2 == 0)\n    {                                              // Checking for even number including handling negative numbers\n        result.insert(result.begin(), arr[index]); // Inserting at the start to retain left-right order\n    }\n\n    return result;\n}",
      "output": "2 6 8\nExplanation:\nThe numbers 2, 6, and 8 from the array are even numbers, and hence they are printed.\nThe numbers 3, 5, and 11 are odd, so they are not printed.\n2 4\nExplanation:Only even numbers in [1, 2, 3, 4, 5] are 2 and 4.\n10 32\nExplanation:Even numbers in [10, 21, 32, 45] are 10 and 32.\n2 4 6 8 10 12\nExplanation:All numbers are even.",
      "language": "cpp"
    },
    {
      "fileName": "Print All Odd Numbers in an Array using Recursion.cpp",
      "name": "Print All Odd Numbers in an Array using Recursion",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nExample\nInput:\n[3, 6, 1, 4, 7, 9]\n\nOutput:\n3 1 7 9\n\nExplanation:\nThe input array contains the integers: 3, 6, 1, 4, 7, 9.\nThe odd numbers among these are 3, 1, 7, and 9. Thus, the output should be a string of these numbers separated by spaces.\nNote:\nFor this problem, the output does not require them to be in any particular format other than space-separated.\nExample 1:\n\nInput:\n\nInput: n = 5, arr = [1, 2, 3, 4, 5]\n\nOutput:\n\n1 3 5\nExplanation:Odd numbers in [1, 2, 3, 4, 5] are 1, 3, and 5.\n\nExample 2:\n\nInput:\n\nInput: n = 4, arr = [2, 4, 6, 8]\n\nExplanation:No odd numbers in [2, 4, 6, 8].\n\nExample 3:\n\nInput:\n\nInput: n = 6, arr = [7, 9, 11, 13, 15, 17]\n\nOutput:\n\n7 9 11 13 15 17\nExplanation:All numbers are odd.\n\n*/\n\nvector<int> printAllOddNumbers(const vector<int> &arr, int index)\n{\n\n    if (index >= arr.size())\n    {\n        return {};\n    }\n\n    vector<int> smallAns = printAllOddNumbers(arr, index + 1);\n\n    if (arr[index] % 2 != 0)\n    {\n        smallAns.insert(smallAns.begin(), arr[index]);\n    }\n\n    return smallAns;\n}\n",
      "output": "3 1 7 9\nExplanation:\nThe input array contains the integers: 3, 6, 1, 4, 7, 9.\nThe odd numbers among these are 3, 1, 7, and 9. Thus, the output should be a string of these numbers separated by spaces.\nNote:\nFor this problem, the output does not require them to be in any particular format other than space-separated.\n1 3 5\nExplanation:Odd numbers in [1, 2, 3, 4, 5] are 1, 3, and 5.\n7 9 11 13 15 17\nExplanation:All numbers are odd.",
      "language": "cpp"
    },
    {
      "fileName": "Print Digits of a Number Recursively     Easy 0.cpp",
      "name": "Print Digits of a Number Recursively     Easy 0",
      "code": "#include<iostream>\nusing namespace std;\n\n/*\n\nExample:\nExample 1:\nInput:\n\nn = 12345\n\nOutput:\n\n1 2 3 4 5\n\nExample 2:\nInput:\n\nn = 8\n\nOutput:\n\n8\n\nExplanation:\nIn the first example, the digits of the number 12345 are printed one by one from the most significant to the least significant using recursive function calls. For the second example, since the number is a single digit, it is printed as is.\n\nNotes:\nThe function should print digits directly rather than returning them in any data structure.\nExample 1:\n\nInput:\n\nInput: n = 5\n\nOutput:\n\n5\nExplanation:For a single-digit number, the function prints that digit.\n\nExample 2:\n\nInput:\n\nInput: n = 12\n\nOutput:\n\n1\n2\nExplanation:The digits of 12 are printed in order.\n\nExample 3:\n\nInput:\n\nInput: n = 100\n\nOutput:\n\n1\n0\n0\nExplanation:The function correctly handles numbers with trailing zeros.\n\n*/\n\nvoid helper(int n)\n{\n    if (n == 0)\n        return;\n\n    helper(n / 10);         // pehle chhota number\n    cout << n % 10 << endl; // baad me digit print\n}\n\nvoid printDigitsRecursively(int n)\n{\n    if (n < 0)\n        n = -n; // negative handle\n    if (n == 0)\n    {\n        cout << 0 << endl;\n        return;\n    }\n    helper(n);\n}\n",
      "output": "1 2 3 4 5\n8\nExplanation:\nIn the first example, the digits of the number 12345 are printed one by one from the most significant to the least significant using recursive function calls. For the second example, since the number is a single digit, it is printed as is.\nNotes:\nThe function should print digits directly rather than returning them in any data structure.\n5\nExplanation:For a single-digit number, the function prints that digit.\n1\n2\nExplanation:The digits of 12 are printed in order.\n1\n0\n0\nExplanation:The function correctly handles numbers with trailing zeros.",
      "language": "cpp"
    },
    {
      "fileName": "Print an array.cpp",
      "name": "Print an array",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nExample 1:\nInput: arr = [1, 2, 3, 4, 5]\nOutput: 1 2 3 4 5\nExample 2:\nInput: arr = [10, 20, 30]\nOutput: 10 20 30\n\n\n*/\n\nclass Solution\n{\npublic:\n    void printRecursive(vector<int> &arr, int idx)\n    {\n        if (idx == arr.size())\n            return;\n        cout << arr[idx] << \" \";\n        return printRecursive(arr, idx + 1);\n    }\n\n    void printArray(vector<int> &arr) { printRecursive(arr, 0); }\n};\n",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Reverse String [Using Recursion].cpp",
      "name": "Reverse String [Using Recursion]",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nExample:\nInput:\n\n\ns = ['h', 'e', 'l', 'l', 'o']\nOutput:\n\nAfter executing the function, the array s should be modified to:\n\n\n['o', 'l', 'l', 'e', 'h']\n\n*/\n\nclass Solution\n{\n    void reverseHelper(vector<char> &s, int start, int end)\n    {\n        if (start >= end)\n            return; // Base case\n        // pehla case mai solve krlunga\n        char temp = s[start];\n        s[start] = s[end];\n        s[end] = temp;\n        // baki case recursion solve kr dega\n        reverseHelper(s, start + 1, end - 1);\n    }\n\npublic:\n    vector<char> reverseString(vector<char> &s)\n    {\n        reverseHelper(s, 0, s.size() - 1);\n        return s;\n    }\n};",
      "output": "After executing the function, the array s should be modified to:\n['o', 'l', 'l', 'e', 'h']",
      "language": "cpp"
    },
    {
      "fileName": "Search for an Element in an Array using Recursion.cpp",
      "name": "Search for an Element in an Array using Recursion",
      "code": "#include <iostream>\n#include <vector>\n\n/*\n\nExample:\nInput:\n\narr = [4, 2, 7, 3, 8] target = 7\n\nOutput:\n\n2\n\nExplanation: The element 7 is found at index 2.\n\nInput:\n\narr = [1, 2, 3, 4, 5] target = 6\n\nOutput:\n\n-1\n\nExplanation: The element 6 is not present in the array.\n\nExample 1:\n\nInput:\n\nInput: n = 5, arr = [1, 2, 3, 4, 5], target = 3\n\nOutput:\n\n2\nExplanation:The target 3 is found at index 2.\n\nExample 2:\n\nInput:\n\nInput: n = 4, arr = [7, 8, 9, 10], target = 5\n\nOutput:\n\n-1\nExplanation:The target 5 is not in the array, so -1 is returned.\n\nExample 3:\n\nInput:\n\nInput: n = 6, arr = [10, 20, 30, 40, 50, 60], target = 40\n\nOutput:\n\n3\nExplanation:The target 40 is found at index 3.\n\n*/\nusing namespace std;\n\nint searchElementRecursive(const vector<int> &arr, int target, int index)\n{\n    if (index == arr.size())\n    {\n        return -1;\n    }\n    if (arr[index] == target)\n    {\n        return index;\n    }\n    return searchElementRecursive(arr, target, index + 1);\n}",
      "output": "2\nExplanation: The element 7 is found at index 2.\n-1\nExplanation: The element 6 is not present in the array.\n2\nExplanation:The target 3 is found at index 2.\n-1\nExplanation:The target 5 is not in the array, so -1 is returned.\n3\nExplanation:The target 40 is found at index 3.",
      "language": "cpp"
    },
    {
      "fileName": "Search in an array.cpp",
      "name": "Search in an array",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nExample 1:\n\nInput: n=4, k=533, arr=[34,828,69,533]\n\nOutput: 3\n\nExample 2:\n\nInput: n=2, k=533, arr=[34, 828]\n\nOutput: -1\n\nExample 3:\n\nInput: n=4, k=851, arr=[996, 639, 914, 310]\n\nOutput: -1\n*/\n\nclass Solution\n{\npublic:\n    int searchRecursive(vector<int> &arr, int k, int idx)\n    {\n        if (idx >= arr.size())\n            return -1;\n        if (arr[idx] == k)\n            return idx;\n        return searchRecursive(arr, k, idx + 1);\n    }\n\n    int findIndex(vector<int> &arr, int k) { return searchRecursive(arr, k, 0); }\n};\n",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Valid palindrome using recusion.cpp",
      "name": "Valid palindrome using recusion",
      "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n/*\n\nExample 1:\n\nInput: \"A man, a plan, a canal: Panama\"\nOutput: true\nExplanation: After removing non-alphanumeric characters and converting the string to lowercase, it becomes \"amanaplanacanalpanama\", which is a palindrome.\nExample 2:\n\nInput: \"race a car\"\nOutput: false\nExplanation: After processing, the string becomes \"raceacar\", which is not a palindrome.\nNote:\nUse recursion to tackle this problem, by progressively checking and reducing the string until the base case condition is met.\n\nExample 1:\n\nInput:\n\ns=\"A man, a plan, a canal: Panama\"\n\nOutput:\n\ntrue\nExplanation:Ignoring cases and non-alphanumeric characters, 'AmanaplanacanalPanama' is a palindrome.\n\nExample 2:\n\nInput:\n\ns=\"racecar\"\n\nOutput:\n\ntrue\nExplanation:'racecar' is a palindrome.\n\nExample 3:\n\nInput:\n\ns=\"madam\"\n\nOutput:\n\ntrue\nExplanation:'madam' is a palindrome.\n\n*/\n\nclass Solution\n{\npublic:\n    bool isValidCharacter(char ch)\n    {\n        if (ch >= '0' && ch <= '9')\n            return true;\n        if (ch >= 'a' && ch <= 'z')\n            return true;\n        if (ch >= 'A' && ch <= 'Z')\n            return true;\n        return false;\n    }\n\n    string normaliseString(string s)\n    {\n        string newStr = \"\";\n        for (int i = 0; i < s.length(); i++)\n        {\n            char ch = s[i];\n            if (isValidCharacter(ch))\n            {\n                if (ch >= 'A' && ch <= 'Z')\n                    ch = ch - 'A' + 'a';\n                newStr.push_back(ch);\n            }\n        }\n        return newStr;\n    }\n\n    bool checkPalindrome(string &s, int i, int j)\n    {\n        // base case\n        if (i >= j)\n            return true;\n\n        // one case\n        if (s[i] != s[j])\n            return false;\n\n        // recursion\n        return checkPalindrome(s, i + 1, j - 1);\n    }\n\n    bool isPalindrome(string s)\n    {\n        string newStr = normaliseString(s);\n        return checkPalindrome(newStr, 0, newStr.length() - 1);\n    }\n};\n\n// try to understand this code\n\nclass Solution\n{\npublic:\n    bool isPalindrome(string s)\n    {\n        return isPalindromeRec(s, 0, s.size() - 1);\n    }\n\n    bool isPalindromeRec(const string &s, int left, int right)\n    {\n        // Base case\n        if (left >= right)\n            return true;\n\n        // Skip non-alphanumeric characters\n        if (!isalnum(s[left]))\n            return isPalindromeRec(s, left + 1, right);\n        if (!isalnum(s[right]))\n            return isPalindromeRec(s, left, right - 1);\n\n        // Recursive case\n        if (tolower(s[left]) != tolower(s[right]))\n            return false;\n        return isPalindromeRec(s, left + 1, right - 1);\n    }\n};",
      "output": "Explanation: After removing non-alphanumeric characters and converting the string to lowercase, it becomes \"amanaplanacanalpanama\", which is a palindrome.\nExplanation: After processing, the string becomes \"raceacar\", which is not a palindrome.\nNote:\nUse recursion to tackle this problem, by progressively checking and reducing the string until the base case condition is met.\ntrue\nExplanation:Ignoring cases and non-alphanumeric characters, 'AmanaplanacanalPanama' is a palindrome.\ntrue\nExplanation:'racecar' is a palindrome.\ntrue\nExplanation:'madam' is a palindrome.",
      "language": "cpp"
    }
  ],
  "Sorting-And Searching": [
    {
      "fileName": "Binary Search Implementation.cpp",
      "name": "Binary Search Implementation",
      "code": "\n/*\nExample 1:\nInput: arr = [-1, 0, 3, 5, 9, 12], target = 9\nOutput: 4\nExplanation: The number 9 is located at index 4 in the array.\nExample 2:\nInput: arr = [-1, 0, 3, 5, 9, 12], target = 2\nOutput: -1\nExplanation: The number 2 is not present in the array, thus the function returns -1.\nNote:\nAssume that all integers in the array arr are unique.\nThe algorithm should have a time complexity of O(log n).\nExample 1:\n\nInput:\n\nInput: arr = [1, 2, 3, 4, 5, 6, 7, 8, 9], target = 5\n\nOutput:\n\n4\nExplanation:\n\nExample 2:\n\nInput:\n\nInput: arr = [10, 20, 30, 40, 50, 60], target = 30\n\nOutput:\n\n2\nExplanation:\n\nExample 3:\n\nInput:\n\nInput: arr = [1, 3, 5, 7, 9], target = 8\n\nOutput:\n\n-1\nExplanation:\n\n*/\n\n#include <bits/stdc++.h>\n#include<vector>\nusing namespace std;\n\nint binarySearch(vector<int> &arr, int target)\n{\n    int low = 0, high = arr.size() - 1;\n    while (low <= high)\n    {\n        int mid = low + (high - low) / 2;\n        if (arr[mid] == target)\n            return mid;\n        else if (arr[mid] < target)\n            low = mid + 1;\n        else\n            high = mid - 1;\n    }\n    return -1;\n}\n",
      "output": "Explanation: The number 9 is located at index 4 in the array.\nExplanation: The number 2 is not present in the array, thus the function returns -1.\nNote:\nAssume that all integers in the array arr are unique.\nThe algorithm should have a time complexity of O(log n).\n4\nExplanation:\n2\nExplanation:\n-1\nExplanation:",
      "language": "cpp"
    },
    {
      "fileName": "Find First and Last Occurrence of an Element in a Sorted Array.cpp",
      "name": "Find First and Last Occurrence of an Element in a Sorted Array",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nExample 1:\n\n\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3, 4]\nExample 2:\n\n\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1, -1]\nExample 3:\n\n\nInput: nums = [], target = 0\nOutput: [-1, -1]\nExplanation\nIn Example 1, the target 8 appears from index 3 to 4. Thus, the output is [3, 4].\nIn Example 2, the target 6 is absent from the array, so the output is [-1, -1].\nIn Example 3, the array is empty, thus the target 0 is not found, resulting in [-1, -1].\nExample 1:\n\nInput:\n\nInput: nums = [5,7,7,8,8,10], target = 8\n\nOutput:\n\n[3, 4]\nExplanation:\n\nExample 2:\n\nInput:\n\nInput: nums = [5,7,7,8,8,10], target = 6\n\nOutput:\n\n[-1, -1]\nExplanation:\n\nExample 3:\n\nInput:\n\nInput: nums = [], target = 0\n\nOutput:\n\n[-1, -1]\nExplanation:\n\n*/\n\n// important note:- aise questions jinme hum lage ki ye answer ho bhi sakta hai aur nhi bhi to us value ko store kr lo is technique ko hum store and compute kehte hai\n\nclass Solution\n{\npublic:\n    int LastOccurence(vector<int> &nums, int target)\n    {\n\n        int n = nums.size();\n        int s = 0;\n        int e = n - 1;\n        int ans = -1;\n\n        while (s <= e)\n        {\n            int mid = (s + e) / 2;\n            if (nums[mid] == target)\n            {\n                // store and compute\n                ans = mid;\n                // right\n                s = mid + 1;\n            }\n            else if (target < nums[mid])\n            {\n                // left\n                e = mid - 1;\n            }\n            else\n            {\n                // right\n                s = mid + 1;\n            }\n        }\n        return ans;\n    }\n\n    int firstOccurence(vector<int> &nums, int target)\n    {\n\n        int n = nums.size();\n        int s = 0;\n        int e = n - 1;\n        int ans = -1;\n\n        while (s <= e)\n        {\n            int mid = (s + e) / 2;\n            if (nums[mid] == target)\n            {\n                // store and compute\n                ans = mid;\n                // left\n                e = mid - 1;\n            }\n            else if (target < nums[mid])\n            {\n                // left\n                e = mid - 1;\n            }\n            else\n            {\n                // right\n                s = mid + 1;\n            }\n        }\n        return ans;\n    }\n\n    vector<int> searchRange(vector<int> &nums, int target)\n    {\n        int first = firstOccurence(nums, target);\n        int Last = LastOccurence(nums, target);\n        vector<int> temp;\n        temp.push_back(first);\n        temp.push_back(Last);\n        return temp;\n    }\n};",
      "output": "Explanation\n[3, 4]\nExplanation:\n[-1, -1]\nExplanation:\n[-1, -1]\nExplanation:",
      "language": "cpp"
    },
    {
      "fileName": "Find K Closest Elements.cpp",
      "name": "Find K Closest Elements",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n/*\n\nExample:\nInput:\n\narr = [1, 2, 3, 4, 5]\nk = 4\nx = 3\nOutput:\n\n[1, 2, 3, 4]\nExplanation: The four integers closest to 3 are 1, 2, 3, and 4. Each has a unique absolute difference with 3 or are smaller numbers at the same difference when compared to others like 5.\n\nAdditional Considerations:\nEnsure that the function handles edge cases where x is greater or smaller than all values in the array.\nThe order of the elements in the array should remain ascending in the result list.\nExample 1:\n\nInput:\n\narr = [1,2,3,4,5], k = 4, x = 3\n\nOutput:\n\n[1, 2, 3, 4]\nExplanation:-\n\nExample 2:\n\nInput:\n\narr = [1,2,3,4,5], k = 4, x = -1\n\nOutput:\n\n[1, 2, 3, 4]\nExplanation:-\n\nConstraints\n\n1 <= k <= arr.length\n1 <= arr.length <= 10\narr is sorted in ascending order.\n-10\n\n*/\n\n// two pointer method\n\nclass Solution\n{\npublic:\n    vector<int> twoPtrMethod(vector<int> &arr, int k, int x)\n    {\n        int l = 0, h = arr.size() - 1;\n        while (h - l >= k)\n        {\n            if (x - arr[l] > arr[h] - x)\n            {\n                l++;\n            }\n            else\n            {\n                h--;\n            }\n        }\n        vector<int> ans;\n        for (int i = l; i <= h; i++)\n        {\n            ans.push_back(arr[i]);\n        }\n        return ans;\n    }\n\n    vector<int> findClosestElements(vector<int> &arr, int k, int x)\n    {\n        return twoPtrMethod(arr, k, x);\n    }\n};\n\n// binary search method\n\nclass Solution\n{\npublic:\n    int lowerBound(vector<int> &arr, int x)\n    {\n        int start = 0, end = arr.size() - 1;\n        int ans = end;\n        while (start <= end)\n        {\n            int mid = (start + end) / 2;\n            if (arr[mid] >= x)\n            {\n                ans = mid;\n                end = mid - 1;\n            }\n            else if (x > arr[mid])\n            {\n                start = mid + 1;\n            }\n            else\n            {\n                end = mid - 1;\n            }\n\n            return ans;\n        }\n    }\n    vector<int> bs_method(vector<int> &arr, int k, int x)\n    {\n        // lower bound\n        int h = lowerBound(arr, x);\n        int l = h - 1;\n        while (k--)\n        {\n            if (l < 0)\n            {\n                h++;\n            }\n            else if (h >= arr.size())\n            {\n                l--;\n            }\n            else if (x - arr[l] > arr[h] - x)\n            {\n                h++;\n            }\n            else\n            {\n                l--;\n            }\n        }\n        return vector<int>(arr.begin() + l + 1, arr.begin() + h);\n    }\n\n    vector<int> findClosestElements(vector<int> &arr, int k, int x)\n    {\n        return bs_method(arr, k, x);\n    }\n};\n\n// both codes time complexity 0(n)",
      "output": "[1, 2, 3, 4]\nExplanation: The four integers closest to 3 are 1, 2, 3, and 4. Each has a unique absolute difference with 3 or are smaller numbers at the same difference when compared to others like 5.\nAdditional Considerations:\nEnsure that the function handles edge cases where x is greater or smaller than all values in the array.\nThe order of the elements in the array should remain ascending in the result list.\n[1, 2, 3, 4]\nExplanation:-\n[1, 2, 3, 4]\nExplanation:-\nConstraints\n1 <= k <= arr.length\n1 <= arr.length <= 10\narr is sorted in ascending order.\n-10",
      "language": "cpp"
    },
    {
      "fileName": "Find Peak Index in a Mountain Array Method-2.cpp",
      "name": "Find Peak Index in a Mountain Array Method-2",
      "code": "// methid -2\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nExample:\n\n\n\nInput: arr = [0, 2, 5, 3, 1]\nOutput: 2\nIn this example, the peak element is 5, located at index 2.\n\nNote:\n\nThe input is guaranteed to be a mountain array.\nExample 1:\n\nInput:\n\nInput: arr = [0, 1, 0]\n\nOutput:\n\n1\nExplanation:\n\nExample 2:\n\nInput:\n\nInput: arr = [1, 3, 5, 4, 2]\n\nOutput:\n\n2\nExplanation:\n\nExample 3:\n\nInput:\n\nInput: arr = [0, 2, 4, 6, 5, 3, 1]\n\nOutput:\n\n3\nExplanation:\n\n*/\n\nint peakIndexInMountainArray(vector<int> &arr)\n{\n    // Your implementation here\n    int n = arr.size();\n    int s = 0;\n    int e = n - 1;\n    int mid = (s + e) / 2;\n\n    while (s < e)\n    {\n        if (arr[mid] < arr[mid + 1])\n        {\n            s = mid + 1;\n        }\n        else\n        {\n            e = mid;\n        }\n        mid = (s + e) / 2;\n    }\n    return mid;\n}",
      "output": "In this example, the peak element is 5, located at index 2.\nNote:\nThe input is guaranteed to be a mountain array.\n1\nExplanation:\n2\nExplanation:\n3\nExplanation:",
      "language": "cpp"
    },
    {
      "fileName": "Find Peak Index in a Mountain Array.cpp",
      "name": "Find Peak Index in a Mountain Array",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nExample:\n\n\nInput: arr = [0, 2, 5, 3, 1]\nOutput: 2\nIn this example, the peak element is 5, located at index 2.\n\nNote:\n\nThe input is guaranteed to be a mountain array.\nExample 1:\n\nInput:\n\nInput: arr = [0, 1, 0]\n\nOutput:\n\n1\nExplanation:\n\nExample 2:\n\nInput:\n\nInput: arr = [1, 3, 5, 4, 2]\n\nOutput:\n\n2\nExplanation:\n\nExample 3:\n\nInput:\n\nInput: arr = [0, 2, 4, 6, 5, 3, 1]\n\nOutput:\n\n3\nExplanation:\n\n*/\n\nint peakIndexInMountainArray(vector<int> &arr)\n{\n    // Your implementation here\n    int n = arr.size();\n    int s = 0;\n    int e = n - 1;\n    int ansIndex = -1;\n\n    while (s <= e)\n    {\n        int mid = (s + e) / 2;\n\n        if (arr[mid] < arr[mid + 1])\n        {\n            // right\n            s = mid + 1;\n        }\n        else\n        {\n            // mid is on line 2\n            // line 2 is also contains peak element\n            // mid may be on peak element or a non peak element\n            // stire and compute\n            ansIndex = mid;\n            e = mid - 1;\n        }\n    }\n    return ansIndex;\n}",
      "output": "In this example, the peak element is 5, located at index 2.\nNote:\nThe input is guaranteed to be a mountain array.\n1\nExplanation:\n2\nExplanation:\n3\nExplanation:",
      "language": "cpp"
    },
    {
      "fileName": "Find Quotient Without Using Division and Modulus Operators.cpp",
      "name": "Find Quotient Without Using Division and Modulus Operators",
      "code": "#include <iostream>\nusing namespace std;\n#include <limits.h>\n\n/*\n\nExamples:\nExample 1:\nInput:\ndividend = 10\ndivisor = 3\nOutput:\n3\nExplanation: Performing the division 10 / 3 results in 3.3333..., and after truncation towards zero, the result is 3.\nExample 2:\nInput:\ndividend = 7\ndivisor = -3\nOutput:\n-2\nExplanation: Performing the division 7 / -3 results in -2.3333..., and after truncation towards zero, the result is -2.\nYour task is to implement the function:\n\n\nint findQuotient(int dividend, int divisor)\nThis function returns the integer quotient of dividing dividend by divisor with truncation towards zero.\n\nExample 1:\n\nInput:\n\nInput: dividend = 10, divisor = 2\n\nOutput:\n\n5\nExplanation:10 divided by 2 gives quotient 5.\n\nExample 2:\n\nInput:\n\nInput: dividend = 43, divisor = 5\n\nOutput:\n\n8\nExplanation:43 divided by 5 gives quotient 8 (ignoring remainder).\n\nExample 3:\n\nInput:\n\nInput: dividend = -50, divisor = -5\n\nOutput:\n\n10\nExplanation:-50 divided by -5 gives quotient 10.\n\n*/\n\n#include <limits.h>\n\nlong long int solve(long long int dividend, long long int divisor)\n{\n\n    long long int s = 0;\n    long long int e = dividend;\n    long long int ans = -1;\n\n    while (s <= e)\n    {\n        long long mid = s + ((e - s) >> 1);\n        long long product = divisor * mid;\n\n        if (product == dividend)\n        {\n            return mid;\n        }\n        else if (product > dividend)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            // store and compute logic\n            ans = mid;\n            s = mid + 1;\n        }\n    }\n    return ans;\n}\n\nlong long int findQuotient(int dividend, int divisor)\n{\n    // The user will implement this method\n    if (divisor == 0)\n    {\n        return INT_MAX;\n    }\n\n    if (dividend == INT_MIN && divisor == -1)\n        return INT_MAX;\n\n    long long int ans =\n        solve(abs((long long int)dividend), abs((long long int)divisor));\n\n    if ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0))\n        return ans;\n\n    else\n    {\n        return (0 - ans);\n    }\n    return 0;\n}",
      "output": "3\nExplanation: Performing the division 10 / 3 results in 3.3333..., and after truncation towards zero, the result is 3.\n-2\nExplanation: Performing the division 7 / -3 results in -2.3333..., and after truncation towards zero, the result is -2.\nYour task is to implement the function:\nint findQuotient(int dividend, int divisor)\nThis function returns the integer quotient of dividing dividend by divisor with truncation towards zero.\n5\nExplanation:10 divided by 2 gives quotient 5.\n8\nExplanation:43 divided by 5 gives quotient 8 (ignoring remainder).\n10\nExplanation:-50 divided by -5 gives quotient 10.",
      "language": "cpp"
    },
    {
      "fileName": "Find Single Non-Duplicate Element using Binary Search.cpp",
      "name": "Find Single Non-Duplicate Element using Binary Search",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nExample:\nInput: nums = [1, 1, 2, 3, 3, 4, 4, 8, 8]\n\nOutput: 2\n\nExplanation: Here, each element appears twice except for 2, which appears only once. Therefore, 2 is the single non-duplicate element in the array.\n\nExample 1:\n\nInput:\n\nInput: [1,1,2,3,3,4,4,8,8]\n\nOutput:\n\n2\nExplanation:The unique element in the array is 2.\n\nExample 2:\n\nInput:\n\nInput: [3,3,7,7,10,11,11]\n\nOutput:\n\n10\nExplanation:The unique element in the array is 10.\n\nExample 3:\n\nInput:\n\nInput: [1,1,2,2,3]\n\nOutput:\n\n3\nExplanation:The unique element in the array is 3.\n\n*/\n\nclass Solution\n{\npublic:\n    int singleNonDuplicate(vector<int> &nums)\n    {\n        int n = nums.size();\n        int s = 0;\n        int e = n - 1;\n\n        while (s <= e)\n        {\n\n            if (s == e)\n            {\n                // single element\n                return nums[s];\n            }\n\n            int mid = (s + e) / 2;\n\n            int currentValue = nums[mid];\n\n            int leftValue = -1;\n            if (mid - 1 >= 0)\n            {\n                leftValue = nums[mid - 1];\n            }\n\n            int rightValue = -1;\n            if (mid + 1 < n)\n            {\n                rightValue = nums[mid + 1];\n            }\n\n            // check current value is a answer or not\n\n            if (currentValue != leftValue && currentValue != rightValue)\n            {\n                return currentValue;\n            }\n\n            // logic for movement to left right\n\n            if (currentValue == leftValue && currentValue != rightValue)\n            {\n                // agar currentvalue==leftvalue hai to ye ek duplicate pair hai to iska matlb pair ka starting index left value ke index ke equal hai\n                // iska matlb pair starting index left value ka index hai\n                // left value ka index mid-1;\n                // agar mai ans ke left me hu to starting index of pair even hoga\n                // agar mai answer ke right me hu , to starting index of pair odd hoga\n                int pairStartingIndex = mid - 1;\n                if (pairStartingIndex & 1)\n                {\n                    // odd case -> yaani ye pair answer k right me h, iska matlb mujhe\n                    // left jana hai padega\n                    e = mid - 1;\n                }\n                else\n                {\n                    // right s=mid+1;\n                    s = mid + 1;\n                }\n            }\n\n            if (currentValue != leftValue && currentValue == rightValue)\n            {\n                // yaha current value to right value ke equal ho gayi iska matlb pair ka\n                // starting index current value ka index hoga current value ka starting\n                // index mid hai\n                int pairStartingIndex = mid;\n                // agar mai ans ke left me hu to starting index of pair even hoga\n                // agar mai answer ke right me hu , to starting index of pair odd hoga\n                if (pairStartingIndex & 1)\n                {\n                    // odd case -> yaani ye pair answer k right me h, iska matlb mujhe\n                    // left jana hai padega\n                    e = mid - 1;\n                }\n                else\n                {\n                    // right s=mid+1;\n                    s = mid + 1;\n                }\n            }\n        }\n    }\n};",
      "output": "Explanation: Here, each element appears twice except for 2, which appears only once. Therefore, 2 is the single non-duplicate element in the array.\n2\nExplanation:The unique element in the array is 2.\n10\nExplanation:The unique element in the array is 10.\n3\nExplanation:The unique element in the array is 3.",
      "language": "cpp"
    },
    {
      "fileName": "Find Square Root using Binary Search-mthod-2-form amazon.cpp",
      "name": "Find Square Root using Binary Search-mthod-2-form amazon",
      "code": "// main method\n// very important question for amazon,flipcart,microsoft,google\n\n/*\n\nExample:\nExample 1:\nInput: x = 16\n\nOutput: 4\n\nExplanation: The integer part of the square root of 16 is 4 since 4 * 4 = 16.\n\nExample 2:\nInput: x = 8\n\nOutput: 2\n\nExplanation: The integer part of the square root of 8 is 2 since 3 * 3 = 9 (which is greater than 8), and 2 * 2 = 4, which is less than 8.\n\nExample 1:\n\nInput:\n\nInput: x = 0\n\nOutput:\n\n0\nExplanation:\n\nExample 2:\n\nInput:\n\nInput: x = 1\n\nOutput:\n\n1\nExplanation:\n\nExample 3:\n\nInput:\n\nInput: x = 4\n\nOutput:\n\n2\nExplanation:\n\n*/\n\nclass Solution\n{\npublic:\n    bool checlValidAnswer(long long product, int target)\n    {\n        if (product == target)\n            return true;\n        else\n            return false;\n    }\n\n    int mySqrt(int x)\n    {\n        // Implement the logic for calculating sqrt using binary search\n        int target = x;\n        int s = 0;\n        int e = target;\n        int ans = -1;\n\n        while (s <= e)\n        {\n            long long mid = s + (e - s) / 2;\n            long long int product = mid * mid;\n            // check mid\n            if (checlValidAnswer(product, target))\n            {\n                return mid;\n            }\n            // left\n            if (product > target)\n            {\n                e = mid - 1;\n            }\n            // right\n            if (product < target)\n            {\n                // store the mid\n                ans = mid;\n\n                s = mid + 1;\n            }\n        }\n\n        return ans;\n    }\n};\n\n/*\nimportant note:-\n\nsearch space reduction technique\nbinary search ke advanced questions isi technique per based hote hai like book allocation, eco spoch, roti paratha spoch\nmid ko check krne ke liye ek alag se function likha jata hai jise hum predicate function kehte hai\n\n*/\n\n/*\n\n =================== BINARY SEARCH ON ANSWER (SHORT NOTES) ===================\n\n 1) Use when array me search nahi karna hota,\n    balki answer ek RANGE me hota hai (0..10^9 type).\n\n 2) Is technique ka naam:\n    - Search Space Reduction\n   - Solution Space Reduction\n   - Binary Search on Answer\n\n 3) Advanced problems isi par based:\n    Book Allocation, Aggressive Cows, Roti-Paratha,\n    ECO-SPOJ, Koko Bananas, Painter Partition, Shipping Capacity.\n\n 4) Logic:\n    - Search space choose karo (s, e)\n    - mid = possible answer\n    - mid ko check karne ke liye PREDICATE FUNCTION banao\n\n 5) Predicate Function:\n    - Returns TRUE \u2192 mid ek valid answer ho sakta hai\n    - Returns FALSE \u2192 mid invalid \u2192 search adjust\n\n6) Very important:\n    if (predicate(mid) == true)\n         answer = mid; e = mid - 1;   // minimize answer\n    else\n        s = mid + 1;\n\n7) Predicate function names:\n    - isPossible()\n    - canDo()\n    - isValid()\n    - check()\n    - feasible()\n\n 8) End:\n    - Loop ke baad 'answer' hi final hoga.\n ==============================================================================\n\n\n\n*/",
      "output": "Explanation: The integer part of the square root of 16 is 4 since 4 * 4 = 16.\nExplanation: The integer part of the square root of 8 is 2 since 3 * 3 = 9 (which is greater than 8), and 2 * 2 = 4, which is less than 8.\n0\nExplanation:\n1\nExplanation:\n2\nExplanation:",
      "language": "cpp"
    },
    {
      "fileName": "Find Square Root using Binary Search.cpp",
      "name": "Find Square Root using Binary Search",
      "code": "// very important question for amazon,flipcart,microsoft,google\n//main method for amazon in method -2\n\n\n\n//this is method-1 \n\n\n#include <iostream>\nusing namespace std;\n\n/*\n\nExample:\nExample 1:\nInput: x = 16\n\nOutput: 4\n\nExplanation: The integer part of the square root of 16 is 4 since 4 * 4 = 16.\n\nExample 2:\nInput: x = 8\n\nOutput: 2\n\nExplanation: The integer part of the square root of 8 is 2 since 3 * 3 = 9 (which is greater than 8), and 2 * 2 = 4, which is less than 8.\n\nExample 1:\n\nInput:\n\nInput: x = 0\n\nOutput:\n\n0\nExplanation:\n\nExample 2:\n\nInput:\n\nInput: x = 1\n\nOutput:\n\n1\nExplanation:\n\nExample 3:\n\nInput:\n\nInput: x = 4\n\nOutput:\n\n2\nExplanation:\n\n*/\n\nclass Solution\n{\npublic:\n    int mySqrt(int x)\n    {\n        // Implement the logic for calculating sqrt using binary search\n        int target = x;\n        int s = 0;\n        int e = target;\n        int ans = -1;\n\n        while (s <= e)\n        {\n            long long mid = s + (e - s) / 2;\n            long long int product = mid * mid;\n            // check mid\n            if (product == target)\n            {\n                return mid;\n            }\n            // left\n            if (product > target)\n            {\n                e = mid - 1;\n            }\n            // right\n            if (product < target)\n            {\n                // store the mid\n                ans = mid;\n\n                s = mid + 1;\n            }\n        }\n\n        return ans;\n    }\n};\n\n\n\n\n\n/*\nimportant note:-\n\nsearch space reduction technique \nbinary search ke advanced questions isi technique per based hote hai like book allocation, eco spoch, roti paratha spoch\nmid ko check krne ke liye ek alag se function likha jata hai jise hum predicate function kehte hai \n\n*/",
      "output": "Explanation: The integer part of the square root of 16 is 4 since 4 * 4 = 16.\nExplanation: The integer part of the square root of 8 is 2 since 3 * 3 = 9 (which is greater than 8), and 2 * 2 = 4, which is less than 8.\n0\nExplanation:\n1\nExplanation:\n2\nExplanation:",
      "language": "cpp"
    },
    {
      "fileName": "Find an Element in a Nearly Sorted Array Elements can be swapped with adjacent ones.cpp",
      "name": "Find an Element in a Nearly Sorted Array Elements can be swapped with adjacent ones",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nExample\nInput:\n\n\nn = 5\narr = [3, 5, 10, 9, 11]\nK = 10\nOutput:\n\n\n2\nExplanation: The element 10 can be found at index 2, satisfying the conditions of a nearly sorted array.\n\nAdditional Example\nInput:\n\n\nn = 4\narr = [1, 3, 4, 2]\nK = 4\nOutput:\n\n\n2\nExplanation: The element 4 appears at index 2 in this nearly sorted array.\n\nExample 1:\n\nInput:\n\nInput: n = 7, arr = [10, 3, 40, 20, 50, 80, 70], K = 40\n\nOutput:\n\n2\nExplanation:40 is found at index 2.\n\nExample 2:\n\nInput:\n\nInput: n = 5, arr = [5, 10, 30, 20, 40], K = 20\n\nOutput:\n\n3\nExplanation:20 is found at index 3.\n\nExample 3:\n\nInput:\n\nInput: n = 6, arr = [10, 20, 30, 40, 50, 60], K = 30\n\nOutput:\n\n2\nExplanation:30 is found at index 2.\n\n*/\n\nint findElementInNearlySortedArray(const vector<int> &arr, int target)\n{\n    // Implement the logic here\n    // code here\n    int n = arr.size();\n    int s = 0;\n    int e = n - 1;\n\n    while (s <= e)\n    {\n        int mid = (s + e) / 2;\n\n        // check mid for t target\n        // as this is a almost sorted array\n        // target can be found on 3 indexes -> mid,mid-1,mid+1\n\n        if (arr[mid] == target)\n        {\n            return mid;\n        }\n        else if (arr[mid + 1] == target)\n        {\n            return mid + 1;\n        }\n\n        else if (arr[mid - 1] == target)\n        {\n            return mid - 1;\n        }\n        else if (target > arr[mid])\n        {\n            s = mid + 2;\n        }\n        else\n        {\n            e = mid - 2;\n        }\n    }\n\n    return -1;\n\n    return -1; // Placeholder return\n}",
      "output": "2\nExplanation: The element 10 can be found at index 2, satisfying the conditions of a nearly sorted array.\n2\nExplanation: The element 4 appears at index 2 in this nearly sorted array.\n2\nExplanation:40 is found at index 2.\n3\nExplanation:20 is found at index 3.\n2\nExplanation:30 is found at index 2.",
      "language": "cpp"
    },
    {
      "fileName": "Find the Pivot Index of a Rotated Array.cpp",
      "name": "Find the Pivot Index of a Rotated Array",
      "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\n/*\n\nYour Task:\nWrite a function to return the index of the pivot.\n\nExample:\nInput: nums = [4, 5, 6, 7, 0, 1, 2]\n\nOutput: 3\n\nExplanation: In this array, the pivot point is the index 3 because the array [4, 5, 6, 7], when combined with [0, 1, 2], forms the original sorted array [0, 1, 2, 4, 5, 6, 7].\n\nExample 1:\n\nInput:\n\nInput: nums = [3, 4, 5, 1, 2]\n\nOutput:\n\n2\nExplanation:\n\nExample 2:\n\nInput:\n\nInput: nums = [4, 5, 6, 7, 0, 1, 2]\n\nOutput:\n\n3\nExplanation:\n\nExample 3:\n\nInput:\n\nInput: nums = [1, 2, 3, 4, 5]\n\nOutput:\n\n-1\nExplanation:\n\n*/\n\n\nclass Solution {\npublic:\n  int findPivotIndex(vector<int> &nums) {\n\n    int n = nums.size();\n    int s = 0;\n    int e = n - 1;\n\n    while (s <= e) {\n\n      int mid = (s + e) / 2;\n\n      // Case 1: mid is pivot\n      if (mid + 1 < n && nums[mid] > nums[mid + 1]) {\n        return mid;\n      }\n\n      // Case 2: mid is in rotated part (line-2)\n      if (nums[mid] < nums[s]) {\n        e = mid - 1;     // go left\n      }\n\n      else {\n        s = mid + 1;     // go right\n      }\n    }\n\n    // no pivot means array is not rotated\n    return -1;\n  }\n};\n",
      "output": "Explanation: In this array, the pivot point is the index 3 because the array [4, 5, 6, 7], when combined with [0, 1, 2], forms the original sorted array [0, 1, 2, 4, 5, 6, 7].\n2\nExplanation:\n3\nExplanation:\n-1\nExplanation:",
      "language": "cpp"
    },
    {
      "fileName": "Koko Eating Bananas.cpp",
      "name": "Koko Eating Bananas",
      "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/*\n\nExample 1:\n\nInput: piles = [3,6,7,11], h = 8\nOutput: 4\nExample 2:\n\nInput: piles = [30,11,23,4,20], h = 5\nOutput: 30\nExample 3:\n\nInput: piles = [30,11,23,4,20], h = 6\nOutput: 23\n\n*/\n\nclass Solution\n{\npublic:\n    int minEatingSpeed(vector<int> &piles, int h)\n    {\n        int start = 1;\n        int end = *max_element(piles.begin(), piles.end());\n        int ans = end;\n\n        while (start <= end)\n        {\n            int mid = start + (end - start) / 2;\n            long long totalTime = 0;\n\n            for (int i = 0; i < piles.size(); i++)\n            {\n                totalTime += (piles[i] + mid - 1) / mid;\n            }\n\n            if (totalTime <= h)\n            {\n                ans = mid;\n                end = mid - 1;\n            }\n            else\n            {\n                start = mid + 1;\n            }\n        }\n\n        return ans;\n    }\n};\n",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Missing Number.cpp",
      "name": "Missing Number",
      "code": "\n\n/*\n\nExample 1:\n\nInput:\n\nn=3 nums=[3,0,1]\n\nOutput:\n\n2\nExplanation:The range should contain {0,1,2,3}. Only 2 is absent.\n\nExample 2:\n\nInput:\n\nn=4 nums=[1,2,3,4]\n\nOutput:\n\n0\nExplanation:Numbers present are {1,2,3,4}; 0 is missing.\n\nExample 3:\n\nInput:\n\nn=4 nums=[0,1,2,3]\n\nOutput:\n\n4\nExplanation:Expected range is {0,1,2,3,4}; 4 is not present.\n\n*/\n\n#include <iostream>\nusing namespace std;\n#include <algorithm>\n#include <algorithm>\n#include <vector>\nclass Solution\n{\npublic:\n    int getMissingNumber(vector<int> &nums)\n    {\n        int n = nums.size();\n        int s = 0;\n        int e = n - 1;\n        int ans = n; // kyunki agar koi bhi element missing ni hoga to last number missing hoga\n\n        while (s <= e)\n        {\n            int mid = (s + e) / 2;\n\n            if (mid == nums[mid])\n            {\n                // right\n                s = mid + 1;\n            }\n            else\n            {\n                ans = mid;\n                // left\n                e = mid - 1;\n            }\n        };\n        return ans;\n    }\n\n    int missingNumber(vector<int> &nums)\n    {\n        // first sort\n\n        sort(nums.begin(), nums.end());\n        int ans = getMissingNumber(nums);\n        return ans;\n    }\n};",
      "output": "2\nExplanation:The range should contain {0,1,2,3}. Only 2 is absent.\n0\nExplanation:Numbers present are {1,2,3,4}; 0 is missing.\n4\nExplanation:Expected range is {0,1,2,3,4}; 4 is not present.",
      "language": "cpp"
    },
    {
      "fileName": "Number of occurrence.cpp",
      "name": "Number of occurrence",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nGiven a sorted array, arr[] and a number target, you need to find the number of occurrences of target in arr[].\n\nExamples :\n\nInput: arr[] = [1, 1, 2, 2, 2, 2, 3], target = 2\nOutput: 4\nExplanation: target = 2 occurs 4 times in the given array so the output is 4.\nInput: arr[] = [1, 1, 2, 2, 2, 2, 3], target = 4\nOutput: 0\nExplanation: target = 4 is not present in the given array so the output is 0.\nInput: arr[] = [8, 9, 10, 12, 12, 12], target = 12\nOutput: 3\nExplanation: target = 12 occurs 3 times in the given array so the output is 3.\n\n*/\n\nclass Solution\n{\npublic:\n    int LastOccurence(vector<int> &arr, int x)\n    {\n\n        int n = arr.size();\n        int s = 0;\n        int e = n - 1;\n        int ans = -1;\n\n        while (s <= e)\n        {\n            int mid = (s + e) / 2;\n            if (arr[mid] == x)\n            {\n                // store and compute\n                ans = mid;\n                // right\n                s = mid + 1;\n            }\n            else if (x < arr[mid])\n            {\n                // left\n                e = mid - 1;\n            }\n            else\n            {\n                // right\n                s = mid + 1;\n            }\n        }\n        return ans;\n    }\n\n    int firstOccurence(vector<int> &arr, int x)\n    {\n\n        int n = arr.size();\n        int s = 0;\n        int e = n - 1;\n        int ans = -1;\n\n        while (s <= e)\n        {\n            int mid = (s + e) / 2;\n            if (arr[mid] == x)\n            {\n                // store and compute\n                ans = mid;\n                // left\n                e = mid - 1;\n            }\n            else if (x < arr[mid])\n            {\n                // left\n                e = mid - 1;\n            }\n            else\n            {\n                // right\n                s = mid + 1;\n            }\n        }\n        return ans;\n    }\n\n    int countFreq(vector<int> &arr, int target)\n    {\n        // code here\n        int first = firstOccurence(arr, target);\n        if (first == -1)\n            return 0; // element nahi mila\n        int last = LastOccurence(arr, target);\n        return last - first + 1;\n    }\n};\n",
      "output": "Explanation: target = 2 occurs 4 times in the given array so the output is 4.\nExplanation: target = 4 is not present in the given array so the output is 0.\nExplanation: target = 12 occurs 3 times in the given array so the output is 3.",
      "language": "cpp"
    },
    {
      "fileName": "Row with Maximum 1\u2019s.cpp",
      "name": "Row with Maximum 1\u2019s",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*       Row with Maximum 1\u2019s\n\nExample\nInput:\nmat = [[0, 0, 0, 1], [0, 0, 1, 1], [0, 1, 1, 1], [1, 1, 1, 1]]\n\nOutput:\n3\n\nExplanation:\nAll the rows are:\n\nRow 0: 1 one\nRow 1: 2 ones\nRow 2: 3 ones\nRow 3: 4 ones\nSince row 3 contains the maximum number of 1s, the index 3 is returned.\n\nNote:\nIf no row contains a 1 at all, return -1.\n\nExample 1:\n\nInput:\n\nm = 4, n = 4, matrix = [[0,0,0,1],[0,0,1,1],[0,1,1,1],[1,1,1,1]]\n\nOutput:\n\n3\nExplanation:Row'3 contains 4 ones, the maximum among all rows.\n\nExample 2:\n\nInput:\n\nm = 3, n = 5, matrix = [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]\n\nOutput:\n\n-1\nExplanation:No row contains a 1, so \u22121 is returned.\n\nExample 3:\n\nInput:\n\nm = 4, n = 4, matrix = [[0,1,1,1],[0,1,1,1],[0,0,1,1],[0,0,1,1]]\n\nOutput:\n\n0\nExplanation:Rows 0 and 1 each have two 1 s, rows 2 and 3 each have three 1 s; the first of the rows with the highest count (index2) is returned.\n\n\n*/\n\nint rowWithMaxOnes(const vector<vector<int>> &mat)\n{\n    // Implement the function to find the row with the maximum number of 1s.\n    // Return the index of the row.\n    int n = mat.size();\n    int m = mat[0].size();\n\n    int maxCnt = 0;\n    int maxIdx = -1;\n\n    for (int i = 0; i < n; i++)\n    {\n        // will find no. of ones in ith row\n\n        auto it = lower_bound(mat[i].begin(), mat[i].end(), 1);\n\n        int firstOneTdx = it - mat[i].begin();\n\n        int ones = m - firstOneTdx;\n\n        if (ones > maxCnt)\n        {\n            maxCnt = ones;\n            maxIdx = i;\n        }\n    }\n\n    return maxIdx;\n}",
      "output": "3\nExplanation:\nAll the rows are:\nRow 0: 1 one\nRow 1: 2 ones\nRow 2: 3 ones\nRow 3: 4 ones\nSince row 3 contains the maximum number of 1s, the index 3 is returned.\nNote:\nIf no row contains a 1 at all, return -1.\n3\nExplanation:Row'3 contains 4 ones, the maximum among all rows.\n-1\nExplanation:No row contains a 1, so \u22121 is returned.\n0\nExplanation:Rows 0 and 1 each have two 1 s, rows 2 and 3 each have three 1 s; the first of the rows with the highest count (index2) is returned.",
      "language": "cpp"
    },
    {
      "fileName": "Search In A Roated Sorted Array.cpp",
      "name": "Search In A Roated Sorted Array",
      "code": "\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n\nExample 1:\n\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\nExample 2:\n\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\nExample 3:\n\nInput: nums = [1], target = 0\nOutput: -1\n\n\n*/\n\nclass Solution\n{\npublic:\n    int findPivotIndex(vector<int> &nums)\n    {\n\n        int n = nums.size();\n        int s = 0;\n        int e = n - 1;\n\n        while (s <= e)\n        {\n\n            int mid = (s + e) / 2;\n\n            // single case\n            if (s == e)\n            {\n                return mid;\n            }\n\n            //  mid is pivot\n            if (mid + 1 < n && nums[mid] > nums[mid + 1])\n            {\n                return mid;\n            }\n\n            //` mid is in rotated part (line-2)\n            if (nums[mid] < nums[s])\n            {\n                e = mid - 1; // go left\n            }\n\n            else\n            {\n                s = mid + 1; // go right\n            }\n        }\n\n        // no pivot means array is not rotated\n        return -1;\n    }\n\n    int binarySearch(int s, int e, vector<int> &nums, int target)\n    {\n\n        while (s <= e)\n        { // <-- bas ye while add kiya\n            int mid = (s + e) / 2;\n\n            if (nums[mid] == target)\n            {\n                return mid;\n            }\n            if (target > nums[mid])\n            {\n                s = mid + 1;\n            }\n            else\n            {\n                e = mid - 1;\n            }\n        }\n\n        return -1;\n    }\n\n    int search(vector<int> &nums, int target)\n    {\n\n        int pivotIndex = findPivotIndex(nums);\n        // yaha tum baad me code likhoge\n\n        /*\n            for l-1\n              s = 0\n              end = pivotIndex\n\n            for l-2\n              s = pivotIndex + 1\n              end = n - 1;\n        */\n        int n = nums.size();\n\n        if (target >= nums[0] && target <= nums[pivotIndex])\n        {\n            int ans = binarySearch(0, pivotIndex, nums, target);\n            return ans;\n        }\n        /*\n          for l-2\n              s = pivotIndex + 1\n              end = n - 1;\n        */\n        else\n        {\n            int ans = binarySearch(pivotIndex + 1, n - 1, nums, target);\n            return ans;\n        }\n\n        return -1;\n    }\n};\n",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Search an Element in a 2D Matrix.cpp",
      "name": "Search an Element in a 2D Matrix",
      "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\n\n\n/*\n\nExample:\nInput:\n\n\nmatrix = [[1, 4, 7, 11, 15],\n          [2, 5, 8, 12, 19],\n          [3, 6, 9, 16, 22],\n          [10, 13, 14, 17, 24],\n          [18, 21, 23, 26, 30]]\ntarget = 5\nOutput: true\n\nExplanation: 5 is located in the second row of the matrix.\n\nInput:\n\n\nmatrix = [[1, 4, 7, 11, 15],\n          [2, 5, 8, 12, 19],\n          [3, 6, 9, 16, 22],\n          [10, 13, 14, 17, 24],\n          [18, 21, 23, 26, 30]]\ntarget = 20\nOutput: false\n\nExplanation: 20 does not exist in the matrix.\n\nExample 1:\n\nInput:\n\nInput: matrix = [[1, 3, 5], [7, 9, 11], [13, 15, 17]], target = 9\n\nOutput:\n\ntrue\nExplanation:\n\nExample 2:\n\nInput:\n\nInput: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], target = 10\n\nOutput:\n\nfalse\nExplanation:\n\nExample 3:\n\nInput:\n\nInput: matrix = [[10, 20, 30], [40, 50, 60], [70, 80, 90]], target = 80\n\nOutput:\n\ntrue\nExplanation:\n\n*/\n\n\nclass Solution {\npublic:\n  bool searchMatrix(vector<vector<int>> &matrix, int target) {\n    // Implement the solution here\n    int row = matrix.size();\n    int cols = matrix[0].size();\n    int total = row * cols;\n    int s = 0;\n    int e = total - 1;\n\n    while (s <= e) {\n      int mid = (s + e) / 2;\n\n      // convert mid into rowIndex, colIndex\n      int rowIndex = mid / cols;\n      int colIndex = mid % cols;\n\n      if (matrix[rowIndex][colIndex] == target) {\n        return true;\n      }\n      if (target > matrix[rowIndex][colIndex]) {\n        s = mid + 1;\n\n      } else {\n        e = mid - 1;\n      }\n    }\n    return false;\n  }\n};",
      "output": "Explanation: 5 is located in the second row of the matrix.\nExplanation: 20 does not exist in the matrix.\ntrue\nExplanation:\nfalse\nExplanation:\ntrue\nExplanation:",
      "language": "cpp"
    },
    {
      "fileName": "find Peak Element.cpp",
      "name": "find Peak Element",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n//     leet code-162 problem\n\n/*\n\nExample 1:\n\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.\nExample 2:\n\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\n\n*/\n\nclass Solution\n{\npublic:\n    int findPeakElement(vector<int> &nums)\n    {\n        int n = nums.size();\n        if (n == 1)\n            return 0;\n        if (nums[0] > nums[1])\n            return 0;\n        if (nums[n - 1] > nums[n - 2])\n            return n - 1;\n\n        int s = 1, e = n - 1;\n\n        while (s <= e)\n        {\n            int mid = (s + e) / 2;\n            if (nums[mid] < nums[mid + 1])\n                s = mid + 1;\n\n            else if (nums[mid] < nums[mid - 1])\n                e = mid - 1;\n\n            else\n                return mid;\n        }\n\n        return -1;\n    }\n};",
      "output": "Explanation: 3 is a peak element and your function should return the index number 2.\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.",
      "language": "cpp"
    },
    {
      "fileName": "find a peak element-2.cpp",
      "name": "find a peak element-2",
      "code": "#include <iostream>\n#include <vector>\n#include <limits.h>\nusing namespace std;\n\n/*\n\nA peak element in a 2D grid is an element that is strictly greater than all of its adjacent neighbors to the left, right, top, and bottom.\n\nGiven a 0-indexed m x n matrix mat where no two adjacent cells are equal, find any peak element mat[i][j] and return the length 2 array [i,j].\n\nYou may assume that the entire matrix is surrounded by an outer perimeter with the value -1 in each cell.\n\nYou must write an algorithm that runs in O(m log(n)) or O(n log(m)) time.\n\n \n\nExample 1:\n\n\n\nInput: mat = [[1,4],\n             [3,2]]\nOutput: [0,1]\nExplanation: Both 3 and 4 are peak elements so [1,0] and [0,1] are both acceptable answers.\nExample 2:\n\n\n\nInput: mat = [[10,20,15],\n             [21,30,14],\n             [7,16,32]]\nOutput: [1,1]\nExplanation: Both 30 and 32 are peak elements so [1,1] and [2,2] are both acceptable answers.\n \n\n*/\n\n\nclass Solution{\npublic:\n    int findMaxIndex(vector<vector<int>> &mat, int n, int m, int j)\n    {\n        // find jth midth column's colm wise max element\n        int maxi = INT_MIN;\n        int index = -1;\n        for (int i = 0; i < n; i++)\n        {\n            if (mat[i][j] > maxi)\n            {\n                maxi = mat[i][j];\n                index = i;\n            }\n        }\n        return index;\n    }\n\n    vector<int> findPeakGrid(vector<vector<int>> &mat)\n    {\n        int n = mat.size();\n        int m = mat[0].size();\n        int s = 0, e = m - 1; // colm wise\n        while (s <= e)\n        {\n            int mid = (s + e) / 2;\n            int maxRowIndex = findMaxIndex(mat, n, m, mid);\n            // now my approach deduced to 1D Sort of thinking\n            int left = mid - 1 >= 0 ? mat[maxRowIndex][mid - 1] : INT_MIN;\n            int right = mid + 1 < m ? mat[maxRowIndex][mid + 1] : INT_MIN;\n\n            if (mat[maxRowIndex][mid] > left && mat[maxRowIndex][mid] > right)\n            {\n                return {maxRowIndex, mid};\n            }\n            else if (mat[maxRowIndex][mid] < left)\n            {\n                e = mid - 1;\n            }\n            else\n            {\n                s = mid + 1;\n            }\n        }\n        return {};\n    }\n};",
      "output": "Explanation: Both 3 and 4 are peak elements so [1,0] and [0,1] are both acceptable answers.\nExplanation: Both 30 and 32 are peak elements so [1,1] and [2,2] are both acceptable answers.",
      "language": "cpp"
    },
    {
      "fileName": "k-diff-pairs-in-an-array.cpp",
      "name": "k-diff-pairs-in-an-array",
      "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\n/*\n\nGiven an array of integers nums and an integer k, return the number of unique k-diff pairs in the array.\n\nA k-diff pair is an integer pair (nums[i], nums[j]), where the following are true:\n\n0 <= i, j < nums.length\ni != j\n|nums[i] - nums[j]| == k\nNotice that |val| denotes the absolute value of val.\n\n\nExample 1:\n\nInput: nums = [3,1,4,1,5], k = 2\nOutput: 2\nExplanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).\nAlthough we have two 1s in the input, we should only return the number of unique pairs.\nExample 2:\n\nInput: nums = [1,2,3,4,5], k = 1\nOutput: 4\nExplanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).\nExample 3:\n\nInput: nums = [1,3,1,5,4], k = 0\nOutput: 1\nExplanation: There is one 0-diff pair in the array, (1, 1).\n\n\nConstraints:\n\n1 <= nums.length <= 104\n-107 <= nums[i] <= 107\n0 <= k <= 107\n\n*/\n\n// Two Pointer->https://leetcode.com/problems/k-diff-pairs-in-an-array/submissions/1862623380/\n\nclass Solution\n{\npublic:\n    int findPairs(vector<int> &nums, int k)\n    {\n        sort(nums.begin(), nums.end());\n        set<pair<int, int>> ans;\n        int i = 0, j = 1;\n        while (j < nums.size())\n        {\n            int diff = nums[j] - nums[i];\n            if (diff == k)\n            {\n                ans.insert({nums[i], nums[j]});\n                ++i;\n                ++j;\n            }\n            else if (diff > k)\n            {\n                i++;\n            }\n            else\n            {\n                j++;\n            }\n            if (i == j)\n                j++;\n        }\n        return ans.size();\n    }\n};\n\n/*\n\n\ud83e\uddea IMPORTANT MAIN 3 TEST CASES\n\u2705 Test Case 1 (Duplicates \u2013 MOST IMPORTANT)\nnums = [3,1,4,1,5]\nk = 2\nOutput = 2\nPairs \u2192 (1,3), (3,5)\n\n\n\n\ud83d\udc49 (1,3) appears twice but counted once because of set\n\n\u2705 Test Case 2 (k = 0 case)\nnums = [1,1,1,1]\nk = 0\nOutput = 1\nPair \u2192 (1,1)\n\n\n\ud83d\udc49 set avoids multiple (1,1) counts\n\n\u2705 Test Case 3 (Mixed duplicates)\nnums = [1,1,1,2,2,2]\nk = 1\nOutput = 1\nPair \u2192 (1,2)\n\n\n\ud83d\udc49 Without set \u2192 wrong count\n\n\u23f1\ufe0f Complexity\n\nTime: O(n log n)\n\nSpace: O(n) (set)\n\n*/\n\n// binary search technique\n\nclass Solution\n{\npublic:\n    int bs(vector<int> &nums, int start, int x)\n    {\n        int end = nums.size() - 1;\n        while (start <= end)\n        {\n            int mid = (start + end) / 2;\n            if (nums[mid] == x)\n            {\n                return mid;\n            }\n            else if (x > nums[mid])\n            {\n                start = mid + 1;\n            }\n            else\n            {\n                end = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    int findPairs(vector<int> &nums, int k)\n    {\n        sort(nums.begin(), nums.end());\n        set<pair<int, int>> ans;\n        for (int i = 0; i < nums.size(); i++)\n        {\n            if (bs(nums, i + 1, nums[i] + k) != -1)\n            {\n                ans.insert({nums[i], nums[i] + k});\n            }\n        }\n        return ans.size();\n    }\n};\n\n/*\n\nAlgorithm (Binary Search Method):\n\nSort the array nums.\n\nFor every element nums[i], search nums[i] + k using binary search in the right part (i+1 to end).\n\nIf found, store the pair (nums[i], nums[i]+k) in a set to avoid duplicates.\n\nReturn the size of the set.\n\n*/\n\n// important note->  agar ka negative ho to approach\n\n#include <set>\nclass Solution\n{\npublic:\n    int findPairs(vector<int> &nums, int k)\n    {\n        sort(nums.begin(), nums.end());\n        set<pair<int, int>> ans;\n        k = abs(k);\n        int i = 0, j = 1;\n\n        while (i < nums.size() && j < nums.size())\n        {\n            int diff = nums[j] - nums[i];\n\n            if (diff == k)\n            {\n                ans.insert({nums[i], nums[j]});\n                i++;\n                j++;\n            }\n            else if (diff > k)\n            {\n                i++;\n            }\n            else\n            {\n                j++;\n            }\n\n            if (i == j)\n                j++;\n        }\n        return ans.size();\n    }\n};\n\n/*\n\n\ud83e\udde0 Yaad rakhne ka GOLDEN NOTE (abs(k) kyu lagaya)\n\ud83d\udc49 Reason (1 line)\n\nArray sort karne ke baad nums[j] - nums[i] kabhi negative nahi hota,\nisliye agar k negative ho to compare karne ke liye abs(k) lagana padta hai.\n\n\ud83d\udccc Mini Example (dimag me chipak jaaye)\nnums = [1,2,3,4,5]\nk = -1\n\n\nSorted array me:\n\nnums[j] - nums[i] = 1, 1, 1, 1   (kabhi -1 nahi aayega)\n\n\n\u274c 1 == -1 \u2192 kabhi true nahi\n\u2705 abs(-1) = 1 \u2192 1 == 1 \u2192 pairs milte hain\n\n*/",
      "output": "Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).\nAlthough we have two 1s in the input, we should only return the number of unique pairs.\nExplanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).\nExplanation: There is one 0-diff pair in the array, (1, 1).\nConstraints:\n1 <= nums.length <= 104\n-107 <= nums[i] <= 107\n0 <= k <= 107",
      "language": "cpp"
    }
  ],
  "Strings": [
    {
      "fileName": "Check if a String is a Palindrome.cpp",
      "name": "Check if a String is a Palindrome",
      "code": "#include<iostream>\nusing namespace std;\n\n/*\n\nExample:\nExample 1:\nInput:\n\n\ns = \"madam\"\nOutput:\n\n\ntrue\nExplanation: The string \"madam\" reads identically forwards and backwards.\n\nExample 2:\nInput:\n\n\ns = \"hello\"\nOutput:\n\n\nfalse\nExplanation: The string \"hello\" does not have the same sequence when read backwards.\n\nNote:\nThe palindrome check is case-sensitive, meaning \"Madam\" and \"madam\" are distinct; only strings with identical sequences in both directions when case is considered will qualify as palindromes.\nExample 1:\n\nInput:\n\nInput: \"racecar\"\n\nOutput:\n\ntrue\nExplanation:The string \"racecar\" reads the same forward and backward.\n\nExample 2:\n\nInput:\n\nInput: \"level\"\n\nOutput:\n\ntrue\nExplanation:The string \"level\" is a palindrome.\n\nExample 3:\n\nInput:\n\nInput: \"hello\"\n\nOutput:\n\nfalse\nExplanation:The string \"hello\" does not read the same forward and backward.\n\n*/\n\nbool isPalindrome(string s) {\n  int i = 0;\n  int j = s.length() - 1;\n  while (i <= j) {\n    if (s[i] != s[j]) {\n      return false;\n    } else {\n      i++;\n      j--;\n    }\n  }\n  return true;\n}",
      "output": "true\nExplanation: The string \"madam\" reads identically forwards and backwards.\nfalse\nExplanation: The string \"hello\" does not have the same sequence when read backwards.\nNote:\nThe palindrome check is case-sensitive, meaning \"Madam\" and \"madam\" are distinct; only strings with identical sequences in both directions when case is considered will qualify as palindromes.\ntrue\nExplanation:The string \"racecar\" reads the same forward and backward.\ntrue\nExplanation:The string \"level\" is a palindrome.\nfalse\nExplanation:The string \"hello\" does not read the same forward and backward.",
      "language": "cpp"
    },
    {
      "fileName": "Convert a String to Lowercase.cpp",
      "name": "Convert a String to Lowercase",
      "code": "#include<iostream>\nusing namespace std;\n\n/*\n\nExample\nExample 1:\nInput: \"HeLLo WoRLd\"\nOutput: \"hello world\"\nExample 2:\nInput: \"PYTHON\"\nOutput: \"python\"\nExplanation:\nExample 1: The input string 'HeLLo WoRLd' is transformed to 'hello world' by converting each uppercase character to its corresponding lowercase form.\nExample 2: For 'PYTHON', every character in the string is converted to lowercase, resulting in 'python'.\nExample 1:\n\nInput:\n\nInput: \"Hello World\"\n\nOutput:\n\nhello world\nExplanation:All uppercase letters are converted to lowercase.\n\nExample 2:\n\nInput:\n\nInput: \"TeStInG\"\n\nOutput:\n\ntesting\nExplanation:Mixed uppercase and lowercase letters are converted to all lowercase.\n\nExample 3:\n\nInput:\n\nInput: \"C++ Programming\"\n\nOutput:\n\nc++ programming\nExplanation:Letters are converted to lowercase, but special characters remain unchanged.\n\n*/\n\nclass Solution {\npublic:\n    string toLowerCase(string s) {\n       for(int i=0;i<s.length();i++){\n        if(s[i]>='A' && s[i]<='Z'){\n            s[i]=s[i]-'A'+'a';\n        }\n      }\n      return s;\n\n    }\n};",
      "output": "Explanation:\nhello world\nExplanation:All uppercase letters are converted to lowercase.\ntesting\nExplanation:Mixed uppercase and lowercase letters are converted to all lowercase.\nc++ programming\nExplanation:Letters are converted to lowercase, but special characters remain unchanged.",
      "language": "cpp"
    },
    {
      "fileName": "Convert a String to Uppercase.cpp",
      "name": "Convert a String to Uppercase",
      "code": "#include<iostream>\nusing namespace std;\n\n\n/*\n\nExample 1:\n\nInput:\n\nInput: \"hello world\"\n\nOutput:\n\nHELLO WORLD\nExplanation:All lowercase letters are converted to uppercase.\n\nExample 2:\n\nInput:\n\nInput: \"TeStInG\"\n\nOutput:\n\nTESTING\nExplanation:Mixed uppercase and lowercase letters are converted to all uppercase.\n\nExample 3:\n\nInput:\n\nInput: \"c++ programming\"\n\nOutput:\n\nC++ PROGRAMMING\nExplanation:Letters are converted to uppercase, but special characters remain unchanged.\n\n*/\n\nclass Solution {\npublic:\n    string toUpperCase(string s) {\n      \n      for(int i=0;i<s.length();i++){\n        if(s[i]>='a' && s[i]<='z'){\n            s[i]=s[i]-'a'+'A';\n        }\n      }\n      return s;\n    }\n};",
      "output": "HELLO WORLD\nExplanation:All lowercase letters are converted to uppercase.\nTESTING\nExplanation:Mixed uppercase and lowercase letters are converted to all uppercase.\nC++ PROGRAMMING\nExplanation:Letters are converted to uppercase, but special characters remain unchanged.",
      "language": "cpp"
    },
    {
      "fileName": "Count-Palindromic-Substrings.cpp",
      "name": "Count-Palindromic-Substrings",
      "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n/*\n\nInput: s = \"abaab\"\nOutput: 3\nExplanation: All palindromic substrings (of length > 1) are: \"aba\", \"aa\", \"baab\".\nInput: s = \"aaa\"\nOutput: 3\nExplanation: All palindromic substrings (of length > 1) are: \"aa\", \"aa\", \"aaa\".\nInput: s = \"abbaeae\"\nOutput: 4\nExplanation: All palindromic substrings (of length > 1) are: \"bb\", \"abba\", \"aea\", \"eae\".\n\n*/\n\nclass Solution\n{\npublic:\n    int checkPalindrome(string s, int i, int j)\n    {\n        int count = 0;\n        while (i >= 0 && j < s.length() && s[i] == s[j])\n        {\n            count++;\n            i--;\n            j++;\n        }\n        return count;\n    }\n\n    int countPS(string &s)\n    {\n        int count = 0;\n        for (int centre = 0; centre < s.length(); centre++)\n        {\n            // odd\n            int i = centre;\n            int j = centre;\n            int oddLengthPalindromeCount = checkPalindrome(s, i, j);\n\n            // even\n            i = centre;\n            j = centre + 1;\n            int evenlengthPalindromeCount = checkPalindrome(s, i, j);\n\n            count = count + oddLengthPalindromeCount + evenlengthPalindromeCount;\n        }\n\n        return count - s.length();\n    }\n};\n",
      "output": "Explanation: All palindromic substrings (of length > 1) are: \"aba\", \"aa\", \"baab\".\nExplanation: All palindromic substrings (of length > 1) are: \"aa\", \"aa\", \"aaa\".\nExplanation: All palindromic substrings (of length > 1) are: \"bb\", \"abba\", \"aea\", \"eae\".",
      "language": "cpp"
    },
    {
      "fileName": "Custom Sort String.cpp",
      "name": "Custom Sort String",
      "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n/*\n\nExample 1:\n\nInput: order = \"cba\", s = \"abcd\"\n\nOutput: \"cbad\"\n\nExplanation: \"a\", \"b\", \"c\" appear in order, so the order of \"a\", \"b\", \"c\" should be \"c\", \"b\", and \"a\".\n\nSince \"d\" does not appear in order, it can be at any position in the returned string. \"dcba\", \"cdba\", \"cbda\" are also valid outputs.\n\nExample 2:\n\nInput: order = \"bcafg\", s = \"abcd\"\n\nOutput: \"bcad\"\n\nExplanation: The characters \"b\", \"c\", and \"a\" from order dictate the order for the characters in s. The character \"d\" in s does not appear in order, so its position is flexible.\n\nFollowing the order of appearance in order, \"b\", \"c\", and \"a\" from s should be arranged as \"b\", \"c\", \"a\". \"d\" can be placed at any position since it's not in order. The output \"bcad\" correctly follows this rule. Other arrangements like \"dbca\" or \"bcda\" would also be valid, as long as \"b\", \"c\", \"a\" maintain their order.\n\n\nConstraints:\n\n1 <= order.length <= 26\n1 <= s.length <= 200\norder and s consist of lowercase English letters.\nAll the characters of order are unique\n\n*/\n\nstring orderCopy;\nclass Solution\n{\npublic:\n    static bool cmp(char ch1, char ch2)\n    {\n        // main sort krna chahata hu as per the order string\n        // if ch1 is present before ch2 in order string\n        //  then place ch1 before ch2 in string s\n        //  and vice versa\n        return (orderCopy.find(ch1) < orderCopy.find(ch2));\n    }\n    string customSortString(string order, string s)\n    {\n        orderCopy = order;\n        sort(s.begin(), s.end(), cmp);\n        return s;\n    }\n};",
      "output": "Explanation: \"a\", \"b\", \"c\" appear in order, so the order of \"a\", \"b\", \"c\" should be \"c\", \"b\", and \"a\".\nSince \"d\" does not appear in order, it can be at any position in the returned string. \"dcba\", \"cdba\", \"cbda\" are also valid outputs.\nExplanation: The characters \"b\", \"c\", and \"a\" from order dictate the order for the characters in s. The character \"d\" in s does not appear in order, so its position is flexible.\nFollowing the order of appearance in order, \"b\", \"c\", and \"a\" from s should be arranged as \"b\", \"c\", \"a\". \"d\" can be placed at any position since it's not in order. The output \"bcad\" correctly follows this rule. Other arrangements like \"dbca\" or \"bcda\" would also be valid, as long as \"b\", \"c\", \"a\" maintain their order.\nConstraints:\n1 <= order.length <= 26\n1 <= s.length <= 200\norder and s consist of lowercase English letters.\nAll the characters of order are unique",
      "language": "cpp"
    },
    {
      "fileName": "Decode The Message.cpp",
      "name": "Decode The Message",
      "code": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\n// leet code-> https://leetcode.com/problems/decode-the-message/description/\n/*\n\nYou are given the strings key and message, which represent a cipher key and a secret message, respectively. The steps to decode message are as follows:\n\nUse the first appearance of all 26 lowercase English letters in key as the order of the substitution table.\nAlign the substitution table with the regular English alphabet.\nEach letter in message is then substituted using the table.\nSpaces ' ' are transformed to themselves.\nFor example, given key = \"happy boy\" (actual key would have at least one instance of each letter in the alphabet), we have the partial substitution table of ('h' -> 'a', 'a' -> 'b', 'p' -> 'c', 'y' -> 'd', 'b' -> 'e', 'o' -> 'f').\nReturn the decoded message.\n\n\nExample 1:\n\n\nInput: key = \"the quick brown fox jumps over the lazy dog\", message = \"vkbs bs t suepuv\"\nOutput: \"this is a secret\"\nExplanation: The diagram above shows the substitution table.\nIt is obtained by taking the first appearance of each letter in \"the quick brown fox jumps over the lazy dog\".\nExample 2:\n\n\nInput: key = \"eljuxhpwnyrdgtqkviszcfmabo\", message = \"zwx hnfx lqantp mnoeius ycgk vcnjrdb\"\nOutput: \"the five boxing wizards jump quickly\"\nExplanation: The diagram above shows the substitution table.\nIt is obtained by taking the first appearance of each letter in \"eljuxhpwnyrdgtqkviszcfmabo\".\n\n\n*/\n\nclass Solution\n{\npublic:\n    void createMapping(unordered_map<char, char> &mapping, string key)\n    {\n        char start = 'a';\n\n        for (int i = 0; i < key.length(); i++)\n        {\n            // mereko sirf usi character ki mapping store krni hai\n            // jiski mapping pehle se store nhi hai\n            char ch = key[i];\n            if (mapping.find(ch) == mapping.end())\n            {\n                // create or store mapping,if not present\n                mapping[ch] = start;\n                start++;\n            }\n        }\n    }\n    string useMapping(unordered_map<char, char> &mapping, string message)\n    {\n        string s = \"\";\n        for (int i = 0; i < message.length(); i++)\n        {\n            char ch = message[i];\n            // find mapped character\n            char mappedCharacter = mapping[ch];\n            // include this in ans string\n            s.push_back(mappedCharacter);\n        }\n        return s;\n    }\n    string decodeMessage(string key, string message)\n    {\n        // step-1 -> create mapping\n        unordered_map<char, char> mapping;\n        char space = ' ';\n        mapping[space] = space;\n        createMapping(mapping, key);\n        // step-2 -> use mapping\n\n        string ans = useMapping(mapping, message);\n        return ans;\n    }\n};",
      "output": "Explanation: The diagram above shows the substitution table.\nIt is obtained by taking the first appearance of each letter in \"the quick brown fox jumps over the lazy dog\".\nExplanation: The diagram above shows the substitution table.\nIt is obtained by taking the first appearance of each letter in \"eljuxhpwnyrdgtqkviszcfmabo\".",
      "language": "cpp"
    },
    {
      "fileName": "Find and Replace Patter.cpp",
      "name": "Find and Replace Patter",
      "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\n\n/*\n\nExample 1:\n\nInput: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}.\n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.\nExample 2:\n\nInput: words = [\"a\",\"b\",\"c\"], pattern = \"a\"\nOutput: [\"a\",\"b\",\"c\"]\n\n\nConstraints:\n\n1 <= pattern.length <= 20\n1 <= words.length <= 50\nwords[i].length == pattern.length\npattern and words[i] are lowercase English letters.\n\n*/\n\nclass Solution\n{\npublic:\n    string normaliseString(string &str)\n    {\n        // is function me main her ek string ko standard formet me convert kr dunga\n        // creating mapping\n        char start = 'a';\n        unordered_map<char, char> mapping;\n        for (int i = 0; i < str.length(); i++)\n        {\n            char ch = str[i];\n            if (mapping.find(ch) == mapping.end())\n            {\n                // sgar pehle se mapping ni hai create a record\n                mapping[ch] = start;\n                start++;\n            }\n        }\n        // usemapping\n        string ansString = \"\";\n        for (int i = 0; i < str.length(); i++)\n        {\n            char ch = str[i];\n            char mappedCharacter = mapping[ch];\n            // original character ko hi replace kr diya\n            // if you want,then you can create a new normalised string\n            ansString.push_back(mappedCharacter);\n        }\n        return ansString;\n    }\n    vector<string> findAndReplacePattern(vector<string> &words, string pattern)\n    {\n        vector<string> ans;\n        string newPattern = normaliseString(pattern);\n\n        for (int i = 0; i < words.size(); i++)\n        {\n            string currentWord = words[i];\n            string newCurrentWord = normaliseString(currentWord);\n            // i just have to check the normalise string with normalised patter string\n            if (newPattern == newCurrentWord)\n            {\n                // include in answer\n                ans.push_back(currentWord);\n            }\n        }\n        return ans;\n    }\n};",
      "output": "Explanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}.\n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.\nConstraints:\n1 <= pattern.length <= 20\n1 <= words.length <= 50\nwords[i].length == pattern.length\npattern and words[i] are lowercase English letters.",
      "language": "cpp"
    },
    {
      "fileName": "Find length of a String.cpp",
      "name": "Find length of a String",
      "code": "#include <iostream>\nusing namespace std;\n\n/*\n\nExample:\nInput: \"OpenAI\"\n\nOutput: 6\n\nExplanation: The string \"OpenAI\" has six characters: 'O', 'p', 'e', 'n', 'A', and 'I'. Thus, the length is 6.\n\nExample 1:\n\nInput:\n\nInput: 'hello'\n\nOutput:\n\n5\nExplanation:The string 'hello' has 5 characters.\n\nExample 2:\n\nInput:\n\nInput: 'world!'\n\nOutput:\n\n6\nExplanation:The string 'world!' has 6 characters.\n\nExample 3:\n\nInput:\n\nInput: 'openai'\n\nOutput:\n\n6\nExplanation:The string 'openai' has 6 characters.\n\n*/\n\nint findStringLength(const string &input)\n{\n    return input.length();\n}",
      "output": "Explanation: The string \"OpenAI\" has six characters: 'O', 'p', 'e', 'n', 'A', and 'I'. Thus, the length is 6.\n5\nExplanation:The string 'hello' has 5 characters.\n6\nExplanation:The string 'world!' has 6 characters.\n6\nExplanation:The string 'openai' has 6 characters.",
      "language": "cpp"
    },
    {
      "fileName": "Find the Index of the First Occurrence in a String.cpp",
      "name": "Find the Index of the First Occurrence in a String",
      "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n/*\n\nExample 1:\n\nInput:\n\nInput: haystack = 'hello', needle = 'll'\n\nOutput:\n\n2\nExplanation:The substring 'll' starts at index 2 in 'hello'.\n\nExample 2:\n\nInput:\n\nInput: haystack = 'aaaaa', needle = 'bba'\n\nOutput:\n\n-1\nExplanation:'bba' does not occur in 'aaaaa'.\n\nExample 3:\n\nInput:\n\nInput: haystack = 'mississippi', needle = 'issip'\n\nOutput:\n\n4\nExplanation:The substring 'issip' starts at index 4.\n\n*/\n\nclass Solution\n{\npublic:\n    int strStr(const string &haystack, const string &needle)\n    {\n        int n = haystack.size();\n        int m = needle.size();\n        for (int i = 0; i <= n - m; i++)\n        {\n            for (int j = 0; j < m; j++)\n            {\n                if (needle[j] != haystack[i + j])\n                {\n                    break;\n                }\n                if (j == m - 1)\n                {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n};",
      "output": "2\nExplanation:The substring 'll' starts at index 2 in 'hello'.\n-1\nExplanation:'bba' does not occur in 'aaaaa'.\n4\nExplanation:The substring 'issip' starts at index 4.",
      "language": "cpp"
    },
    {
      "fileName": "Implement Atoi.cpp",
      "name": "Implement Atoi",
      "code": "#include <iostream>\n#include <string>\n#include <climits>\nusing namespace std;\n\n/*\n\nGiven a string s, the objective is to convert it into integer format without utilizing any built-in functions. Refer the below steps to know about atoi() function.\n\nCases for atoi() conversion:\n\nSkip any leading whitespaces.\nCheck for a sign (\u2018+\u2019 or \u2018-\u2018), default to positive if no sign is present.\nRead the integer by ignoring leading zeros until a non-digit character is encountered or end of the string is reached. If no digits are present, return 0.\nIf the integer is greater than 231 \u2013 1, then return 231 \u2013 1 and if the integer is smaller than -231, then return -231.\nExamples:\n\nInput: s = \"-123\"\nOutput: -123\nExplanation: It is possible to convert -123 into an integer so we returned in the form of an integer\nInput: s = \"  -\"\nOutput: 0\nExplanation: No digits are present, therefore the returned answer is 0.\nInput: s = \" 1231231231311133\"\nOutput: 2147483647\nExplanation: The converted number will be greater than 231 \u2013 1, therefore print 231 \u2013 1 = 2147483647.\nInput: s = \"-999999999999\"\nOutput: -2147483648\nExplanation: The converted number is smaller than -231, therefore print -231 = -2147483648.\nInput: s = \"  -0012gfg4\"\nOutput: -12\nExplanation: After ignoring leading zeros nothing is read after -12 as a non-digit character \u2018g\u2019 was encountered.\n\n*/\n\nclass Solution\n{\npublic:\n    int myAtoi(string s)\n    {\n        int num = 0;\n        int i = 0;\n        int sign = 1; // +ve\n\n        // Skip leading spaces\n        while (i < s.size() && s[i] == ' ')\n        {\n            i++;\n        }\n\n        //  Check sign\n        if (i < s.size() && (s[i] == '-' || s[i] == '+'))\n        {\n            sign = (s[i] == '+') ? 1 : -1;\n            i++;\n        }\n\n        //  Convert digits\n        while (i < s.size() && isdigit(s[i]))\n        {\n            //  Handle overflow\n            if (num > INT_MAX / 10 ||\n                (num == INT_MAX / 10 && s[i] > '7'))\n            {\n                return (sign == -1) ? INT_MIN : INT_MAX;\n            }\n\n            num = num * 10 + (s[i] - '0');\n            i++;\n        }\n\n        return num * sign;\n    }\n};\n\n/*\n\n\ud83d\udcd8 String to Integer (myAtoi) \u2014 Complete Explanation\n\ud83d\udd39 Problem Statement (Simple Language)\nHume ek string di jaati hai.\nHume us string ke starting part se ek integer banana hota hai, lekin kuch strict rules follow karne hote hain.\nHum:\nstring ke beech se number nahi utha sakte\ndirect library function (stoi) use nahi kar sakte\noverflow / underflow ko handle karna zaroori hai\n\ud83d\udd39 Important Rules (Ye clear hone chahiye)\nLeading spaces ignore kiye jaate hain\nOptional sign (+ / \u2212) ho sakta hai\nDigits continuous hone chahiye\nDigit ke baad non-digit aaya \u2192 stop\nAgar pehle hi non-digit aa gaya \u2192 answer = 0\nAnswer 32-bit signed integer range me hona chahiye\nOverflow / underflow hone par limit return hoti hai\n\ud83d\udd39 32-bit Integer Range (Bahut Important)\nMaximum (INT_MAX) = 2147483647\nMinimum (INT_MIN) = -2147483648\nIs range ke bahar jaane par:\nPositive \u2192 INT_MAX\nNegative \u2192 INT_MIN\n\ud83d\udd39 Step-by-Step THEORY (Without Code)\n\ud83e\udde9 Step 1: Leading Spaces Ignore Karna\nString ke start me jitne bhi spaces hain, unka koi matlab nahi.\nReal number wahi se start hota hai jahan pehla non-space character milta hai.\n\ud83d\udccc Example\n\"   123\" \u2192 \"123\"\n\ud83e\udde9 Step 2: Sign Identify Karna\nSpaces ke baad:\n'+' mile \u2192 number positive\n'-' mile \u2192 number negative\nKuch nahi mile \u2192 positive by default\n\ud83d\udccc Example\n\"-45\" \u2192 negative\n\"+78\" \u2192 positive\n\"90\" \u2192 positive\n\ud83e\udde9 Step 3: Digits Read Karna\nSign ke baad sirf digits padhe jaate hain.\nJaise hi koi non-digit character mile \u2014 reading stop.\n\ud83d\udccc Example\n\"4193 with words\" \u2192 4193\n\"12a34\" \u2192 12\n\ud83e\udde9 Step 4: Agar Digit Start Hone Se Pehle Letter Aa Jaye\nAgar spaces ke baad hi letter aa gaya,\nto valid integer exist nahi karta.\n\ud83d\udccc Example\n\"words 123\" \u2192 0\n\ud83e\udde9 Step 5: Overflow / Underflow Logic (Most Important)\nHar naya digit add karte waqt number aise banta hai:\nnew_number = old_number \u00d7 10 + digit\nSocho:\nCopy code\n\nINT_MAX = 2147483647\nINT_MAX / 10 = 214748364\nAgar:\ncurrent number 214748364 hai\naur next digit 7 se badi hai\nto:\nCopy code\n\n214748364 \u00d7 10 + 8 = 2147483648  \u274c overflow\nIsliye:\nLast digit sirf 7 tak hi allowed hai\n\ud83e\udde9 Step 6: Final Answer Return\nDigits se jo number bana:\nuspar sign lagaya jaata hai\naur final integer return kiya jaata hai\n\ud83d\udd01 One-Line Flow (Yaad Rakhne ke Liye)\nSpaces hatao \u2192 sign dekho \u2192 digits padho \u2192 non-digit pe ruk jao \u2192 overflow check \u2192 answer return\n\n*/\n\n",
      "output": "Explanation: It is possible to convert -123 into an integer so we returned in the form of an integer\nExplanation: No digits are present, therefore the returned answer is 0.\nExplanation: The converted number will be greater than 231 \u2013 1, therefore print 231 \u2013 1 = 2147483647.\nExplanation: The converted number is smaller than -231, therefore print -231 = -2147483648.\nExplanation: After ignoring leading zeros nothing is read after -12 as a non-digit character \u2018g\u2019 was encountered.",
      "language": "cpp"
    },
    {
      "fileName": "Isomorphic String.cpp",
      "name": "Isomorphic String",
      "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n/*\n\nExamples:\nExample 1:\n\nInput: s = \"paper\", t = \"title\"\nOutput: true\nExample 2:\n\nInput: s = \"ab\", t = \"aa\"\nOutput: false\nExample 1:\n\nInput:\n\ns = 'egg', t = 'add'\n\nOutput:\n\ntrue\nExplanation:Mapping 'e' to 'a' and 'g' to 'd' makes the strings isomorphic.\n\nExample 2:\n\nInput:\n\ns = 'foo', t = 'bar'\n\nOutput:\n\nfalse\nExplanation:Character 'o' would have to map to both 'a' and 'r', which is not allowed.\n\nExample 3:\n\nInput:\n\ns = 'paper', t = 'title'\n\nOutput:\n\ntrue\nExplanation:Mapping 'p' to 't', 'a' to 'i', 'e' to 'l', and 'r' to 'e' makes the strings isomorphic.\n\n*/\n\nclass Solution\n{\npublic:\n    bool isIsomorphic(const string &s, const string &t)\n    {\n        if (s.size() != t.size())\n            return false;\n        int hash[256] = {\n            0}; // mapping of each char of language 's1' to language 's2'\n        bool isCharsMapped[256] = {\n            0}; // stores if s2[i] char already mapped with s1[i]\n\n        for (int i = 0; i < s.size(); i++)\n        {\n            if (hash[s[i]] == 0 && isCharsMapped[t[i]] == 0)\n            {\n                hash[s[i]] = t[i];\n                isCharsMapped[t[i]] = true;\n            }\n        }\n        for (int i = 0; i < t.size(); i++)\n        {\n            if (hash[s[i]] != t[i])\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n// 1) Agar lengths different hain \u2192 isomorphic possible hi nahi \u2192 return false\n// 2) hash[ch] = s ke char ka mapping t ke char se\n// 3) isCharsMapped[ch] = batata hai t ka char pehle se kisi aur se mapped hai ya nahi\n// 4) Pehle loop me mapping set karo (s[i] \u2192 t[i]) only jab dono unused hon\n// 5) Dusre loop me verify karo ki har s[i] ka mapped char exactly t[i] hi ho\n// 6) Agar kahin mismatch mile \u2192 return false, warna end me true\n",
      "output": "true\nExplanation:Mapping 'e' to 'a' and 'g' to 'd' makes the strings isomorphic.\nfalse\nExplanation:Character 'o' would have to map to both 'a' and 'r', which is not allowed.\ntrue\nExplanation:Mapping 'p' to 't', 'a' to 'i', 'e' to 'l', and 'r' to 'e' makes the strings isomorphic.",
      "language": "cpp"
    },
    {
      "fileName": "Longest Common Prefix of Strings.cpp",
      "name": "Longest Common Prefix of Strings",
      "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nclass Solution\n{\npublic:\n    string longestCommonPrefix(vector<string> strs)\n    {\n        if (strs.size() == 0)\n            return \"\";\n\n        string ans = \"\";\n        int i = 0;\n\n        while (true)\n        {\n            char curr_ch = 0;\n\n            for (auto str : strs)\n            {\n\n                // out of bound check\n                if (i >= str.size())\n                {\n                    return ans;\n                }\n\n                if (curr_ch == 0)\n                {\n                    curr_ch = str[i]; // first string character\n                }\n                else if (str[i] != curr_ch)\n                {\n                    curr_ch = 0;\n                    break; // mismatch found\n                }\n            }\n            if (curr_ch == 0)\n            {\n                break;\n            }\n            ans.push_back(curr_ch); // common character found\n            i++;\n        }\n        return ans;\n    }\n};",
      "output": "Output not specified in comments.",
      "language": "cpp"
    },
    {
      "fileName": "Minimum Amount Of Time To Collect Garbage.cpp",
      "name": "Minimum Amount Of Time To Collect Garbage",
      "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// leetcode->2391 -> https://leetcode.com/problems/minimum-amount-of-time-to-collect-garbage/description/\n\n/*\n\nExample 1:\n\nInput: garbage = [\"G\",\"P\",\"GP\",\"GG\"], travel = [2,4,3]\nOutput: 21\nExplanation:\nThe paper garbage truck:\n1. Travels from house 0 to house 1\n2. Collects the paper garbage at house 1\n3. Travels from house 1 to house 2\n4. Collects the paper garbage at house 2\nAltogether, it takes 8 minutes to pick up all the paper garbage.\nThe glass garbage truck:\n1. Collects the glass garbage at house 0\n2. Travels from house 0 to house 1\n3. Travels from house 1 to house 2\n4. Collects the glass garbage at house 2\n5. Travels from house 2 to house 3\n6. Collects the glass garbage at house 3\nAltogether, it takes 13 minutes to pick up all the glass garbage.\nSince there is no metal garbage, we do not need to consider the metal garbage truck.\nTherefore, it takes a total of 8 + 13 = 21 minutes to collect all the garbage.\nExample 2:\n\nInput: garbage = [\"MMM\",\"PGM\",\"GP\"], travel = [3,10]\nOutput: 37\nExplanation:\nThe metal garbage truck takes 7 minutes to pick up all the metal garbage.\nThe paper garbage truck takes 15 minutes to pick up all the paper garbage.\nThe glass garbage truck takes 15 minutes to pick up all the glass garbage.\nIt takes a total of 7 + 15 + 15 = 37 minutes to collect all the garbage.\n\n\n*/\n\nclass Solution\n{\npublic:\n    int garbageCollection(vector<string> &garbage, vector<int> &travel)\n    {\n\n        // p truck\n        int pickP = 0;\n        int lastHouseP = 0;\n\n        // g truck\n        int pickG = 0;\n        int lastHouseG = 0;\n\n        // m truck\n        int pickM = 0;\n        int lastHouseM = 0;\n\n        // travel krna start krte hain road par\n        for (int i = 0; i < garbage.size(); i++)\n        {\n\n            // main kisi ghar par truck leker pahunch gaya\n            string currentHouseGarbage = garbage[i];\n\n            for (int j = 0; j < currentHouseGarbage.length(); j++)\n            {\n\n                char GarbageType = currentHouseGarbage[j];\n\n                if (GarbageType == 'P')\n                {\n                    pickP++;\n                    lastHouseP = i;\n                }\n                else if (GarbageType == 'M')\n                {\n                    pickM++;\n                    lastHouseM = i;\n                }\n                else if (GarbageType == 'G')\n                {\n                    pickG++;\n                    lastHouseG = i;\n                }\n            }\n        }\n\n        // ab mere pass har truck ka pick and lastHouse ka Data Present h\n        // ab mujhe har truck k travel time ka data nikalna hai\n        // travel time ka data nikalne ke liye house index ka data use hoga\n\n        int travelP = 0;\n        int travelG = 0;\n        int travelM = 0;\n\n        // lets find out the travel time for truck P\n        for (int i = 0; i < lastHouseP; i++)\n        {\n            travelP = travelP + travel[i];\n        }\n\n        for (int i = 0; i < lastHouseM; i++)\n        {\n            travelM = travelM + travel[i];\n        }\n\n        for (int i = 0; i < lastHouseG; i++)\n        {\n            travelG = travelG + travel[i];\n        }\n\n        int totalTime = (pickP + pickM + pickG) + (travelP + travelM + travelG);\n        return totalTime;\n    }\n};\n",
      "output": "Explanation:\nThe paper garbage truck:\n1. Travels from house 0 to house 1\n2. Collects the paper garbage at house 1\n3. Travels from house 1 to house 2\n4. Collects the paper garbage at house 2\nAltogether, it takes 8 minutes to pick up all the paper garbage.\nThe glass garbage truck:\n1. Collects the glass garbage at house 0\n2. Travels from house 0 to house 1\n3. Travels from house 1 to house 2\n4. Collects the glass garbage at house 2\n5. Travels from house 2 to house 3\n6. Collects the glass garbage at house 3\nAltogether, it takes 13 minutes to pick up all the glass garbage.\nSince there is no metal garbage, we do not need to consider the metal garbage truck.\nTherefore, it takes a total of 8 + 13 = 21 minutes to collect all the garbage.\nExplanation:\nThe metal garbage truck takes 7 minutes to pick up all the metal garbage.\nThe paper garbage truck takes 15 minutes to pick up all the paper garbage.\nThe glass garbage truck takes 15 minutes to pick up all the glass garbage.\nIt takes a total of 7 + 15 + 15 = 37 minutes to collect all the garbage.",
      "language": "cpp"
    },
    {
      "fileName": "Palindromic Substrings.cpp",
      "name": "Palindromic Substrings",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n//   leet code->647     https: // leetcode.com/problems/palindromic-substrings/description/\n\n/*\n\nGiven a string s, return the number of palindromic substrings in it.\n\nA string is a palindrome when it reads the same backward as forward.\n\nA substring is a contiguous sequence of characters within the string.\n\n\n\nExample 1:\n\nInput: s = \"abc\"\nOutput: 3\nExplanation: Three palindromic strings: \"a\", \"b\", \"c\".\nExample 2:\n\nInput: s = \"aaa\"\nOutput: 6\nExplanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\n\n*/\n\nclass Solution\n{\npublic:\n    int checkPalindrome(string s, int i, int j)\n    {\n        int count = 0;\n        while (i >= 0 && j < s.length() && s[i] == s[j])\n        {\n            count++;\n            i--;\n            j++;\n        }\n        return count;\n    }\n    int countSubstrings(string s)\n    {\n        int count = 0;\n        for (int centre = 0; centre < s.length(); centre++)\n        {\n            // center ->odd and even case\n            // odd\n            int i = centre;\n            int j = centre;\n            int oddLengthPalindromeCount = checkPalindrome(s, i, j);\n            // even wala case\n            i = centre;\n            j = centre + 1;\n            int evenlengthPalindromeCount = checkPalindrome(s, i, j);\n            count = count + oddLengthPalindromeCount + evenlengthPalindromeCount;\n        }\n        return count;\n    }\n};\n",
      "output": "Explanation: Three palindromic strings: \"a\", \"b\", \"c\".\nExplanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".",
      "language": "cpp"
    },
    {
      "fileName": "Remove All Occurrences of a Substring.cpp",
      "name": "Remove All Occurrences of a Substring",
      "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n/*\n\nExample:\nExample 1:\n\nInput: s = \"ababcab\", part = \"ab\"\nOutput: \"c\"\nExplanation:\nFirst, remove \"ab\" from \"ababcab\", resulting in \"abcab\".\nRemove \"ab\" again from \"abcab\", resulting in \"cab\".\nFinally, remove \"ab\" from \"cab\", leaving \"c\".\nExample 2:\n\nInput: s = \"abcd\", part = \"xyz\"\nOutput: \"abcd\"\nExplanation: Since \"xyz\" is not present in \"abcd\", the string remains unchanged.\nThe objective is to remove the specified part from the original string until it can no longer be found.\n\nComplete the function to achieve this by efficiently removing the specified substring repeatedly.\n\nExample 1:\n\nInput:\n\ns='daabcbaabcbc', part='abc'\n\nOutput:\n\ndab\nExplanation:Removing 'abc' gives 'dabaabcbc', then removing 'abc' again gives 'dab'.\n\nExample 2:\n\nInput:\n\ns='axxxxyyyyb', part='xy'\n\nOutput:\n\nab\nExplanation:Removing 'xy' repeatedly results in 'ab'.\n\nExample 3:\n\nInput:\n\ns='mississippi', part='issip'\n\nOutput:\n\nmisspi\nExplanation:Removing 'issip' from 'mississippi' results in 'mispi'.\n\n*/\n\nclass Solution\n{\npublic:\n    string removeOccurrences(string s, string part)\n    {\n        // jab tak maiin string k andar part string\n        // milti rahegi, tab tak main use remove krta rahunga\n        //  tab ruk jaunga\n\n        while (s.find(part) != -1)\n        {\n            s.erase(s.find(part), part.length());\n        }\n        return s;\n    }\n};",
      "output": "Explanation:\nFirst, remove \"ab\" from \"ababcab\", resulting in \"abcab\".\nRemove \"ab\" again from \"abcab\", resulting in \"cab\".\nFinally, remove \"ab\" from \"cab\", leaving \"c\".\nExplanation: Since \"xyz\" is not present in \"abcd\", the string remains unchanged.\nThe objective is to remove the specified part from the original string until it can no longer be found.\nComplete the function to achieve this by efficiently removing the specified substring repeatedly.\ndab\nExplanation:Removing 'abc' gives 'dabaabcbc', then removing 'abc' again gives 'dab'.\nab\nExplanation:Removing 'xy' repeatedly results in 'ab'.\nmisspi\nExplanation:Removing 'issip' from 'mississippi' results in 'mispi'.",
      "language": "cpp"
    },
    {
      "fileName": "Remove all adjacent duplicate string.cpp",
      "name": "Remove all adjacent duplicate string",
      "code": "#include <iostream>\nusing namespace std;\n\n    //leet code 1047\n\n/*\n\n\nExample 1:\n\nInput: s = \"abbaca\"\nOutput: \"ca\"\nExplanation:\nFor example, in \"abbaca\" we could remove \"bb\" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is \"aaca\", of which only \"aa\" is possible, so the final string is \"ca\".\nExample 2:\n\nInput: s = \"azxxzy\"\nOutput: \"ay\"\n\n*/\n\nclass Solution\n{\npublic:\n    string removeDuplicates(string s)\n    {\n        string ans = \"\";\n\n        for (int i = 0; i < s.length(); i++)\n        {\n            char ch = s[i];\n            // 2 option\n            // 1) insert kardo ->ch and rightmost different hoga or ans empty hoga\n            if (ans.empty())\n            {\n                ans.push_back(ch);\n            }\n            else if (ch != ans.back())\n            {\n                ans.push_back(ch);\n            }\n            else\n            {\n                // ch and rightmost character in ans is same\n                // remove the rightmost character\n                ans.pop_back();\n            }\n            // donot insert and remove rightmost from and-ch and rightmost hoga\n        }\n        return ans;\n    }\n};",
      "output": "Explanation:\nFor example, in \"abbaca\" we could remove \"bb\" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is \"aaca\", of which only \"aa\" is possible, so the final string is \"ca\".",
      "language": "cpp"
    },
    {
      "fileName": "Replace a Character in a String.cpp",
      "name": "Replace a Character in a String",
      "code": "#include<iostream>\nusing namespace std;\n\n/*\n\nExample:\nInput:\n\ns = \"hello\"\nc1 = 'l'\nc2 = 'x'\nOutput:\n\nhexxo\nExplanation:\nThe original string is hello.\nEach occurrence of the character l is replaced with x.\nThus, the resulting string is hexxo.\nNote:\nEnsure that the case of c1 and c2 are preserved as given in the input, meaning only those exact occurrences of c1 will be replaced with c2.\nExample 1:\n\nInput:\n\nInput: s = \"hello\", c1 = 'l', c2 = 'x'\n\nOutput:\n\nhexxo\nExplanation:All occurrences of 'l' are replaced with 'x'.\n\nExample 2:\n\nInput:\n\nInput: s = \"apple\", c1 = 'p', c2 = 'q'\n\nOutput:\n\naqqle\nExplanation:All occurrences of 'p' are replaced with 'q'.\n\nExample 3:\n\nInput:\n\nInput: s = \"mississippi\", c1 = 's', c2 = 'z'\n\nOutput:\n\nmizzizzippi\nExplanation:All occurrences of 's' are replaced with 'z'.\n\n*/\n\nstring replaceCharacter(string s, char c1, char c2) {\n  for (int i = 0; i < s.length(); i++) {\n    if (s[i] == c1) {\n      s[i] = c2;\n    }\n  }\n  return s;\n}",
      "output": "hexxo\nExplanation:\nThe original string is hello.\nEach occurrence of the character l is replaced with x.\nThus, the resulting string is hexxo.\nNote:\nEnsure that the case of c1 and c2 are preserved as given in the input, meaning only those exact occurrences of c1 will be replaced with c2.\nhexxo\nExplanation:All occurrences of 'l' are replaced with 'x'.\naqqle\nExplanation:All occurrences of 'p' are replaced with 'q'.\nmizzizzippi\nExplanation:All occurrences of 's' are replaced with 'z'.",
      "language": "cpp"
    },
    {
      "fileName": "Reverse Only Letters.cpp",
      "name": "Reverse Only Letters",
      "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n/*\n\nExample\nInput:\ns = \"a-bC-dEf-ghIj\"\n\nOutput:\n\"j-Ih-gfE-dCba\"\n\nExplanation\nIn the example above, letters a, b, C, d, E, f, g, h, I, and j are reversed to become j, I, h, g, f, E, d, C, b, and a, respectively. Meanwhile, the dashes remain in their original position.\n\nExample 1:\n\nInput:\n\nInput: s = 'ab-cd'\n\nOutput:\n\ndc-ba\nExplanation:Only letters 'a', 'b', 'c', 'd' are reversed.\n\nExample 2:\n\nInput:\n\nInput: s = 'a-bC-dEf-ghIj'\n\nOutput:\n\nj-Ih-gfE-dCba\nExplanation:Only letters are reversed; non-letter characters remain in place.\n\nExample 3:\n\nInput:\n\nInput: s = 'Test1ng-Leet=code-Q!'\n\nOutput:\n\nQedo1ct-eeLg=ntse-T!\nExplanation:Only letters are reversed; digits and symbols remain in place.\n\n*/\n\nclass Solution\n{\npublic:\n    string reverseOnlyLetters(string &s)\n    {\n        int l = 0;\n        int h = s.size() - 1;\n        while (l < h)\n        {\n            if (((s[l] >= 'A' && s[l] <= 'Z') || (s[l] >= 'a' && s[l] <= 'z')) &&\n                ((s[h] >= 'A' && s[h] <= 'Z') || (s[h] >= 'a' && s[h] <= 'z')))\n            {\n                swap(s[l], s[h]);\n                l++;\n                h--;\n            }\n            else if (!((s[l] >= 'A' && s[l] <= 'Z') ||\n                       (s[l] >= 'a' && s[l] <= 'z')))\n            {\n                l++;\n            }\n            else\n            {\n                // s[h]-> non alpha\n                h--;\n            }\n        }\n        return s;\n    }\n};\n\n// second solution both solution are best\n\nclass Solution\n{\npublic:\n    string reverseOnlyLetters(string &s)\n    {\n        int l = 0;\n        int h = s.size() - 1;\n        while (l < h)\n        {\n            if (isalpha(s[l]) && isalpha(s[h]))\n            {\n                swap(s[l], s[h]);\n                l++;\n                h--;\n            }\n            else if (!isalpha(s[l]))\n            {\n                l++;\n            }\n            else\n            {\n                // s[h]-> non alpha\n                h--;\n            }\n        }\n        return s;\n    }\n};",
      "output": "\"j-Ih-gfE-dCba\"\nExplanation\nIn the example above, letters a, b, C, d, E, f, g, h, I, and j are reversed to become j, I, h, g, f, E, d, C, b, and a, respectively. Meanwhile, the dashes remain in their original position.\ndc-ba\nExplanation:Only letters 'a', 'b', 'c', 'd' are reversed.\nj-Ih-gfE-dCba\nExplanation:Only letters are reversed; non-letter characters remain in place.\nQedo1ct-eeLg=ntse-T!\nExplanation:Only letters are reversed; digits and symbols remain in place.",
      "language": "cpp"
    },
    {
      "fileName": "Reverse Vowels of a String.cpp",
      "name": "Reverse Vowels of a String",
      "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n/*\n\nExample\nInput\n\ns = \"hello\"\nOutput\n\n\"holle\"\nExplanation\nThe vowels in \"hello\" are 'e' and 'o'. When these are reversed, their positions swap, resulting in \"holle\".\n\nInput\n\ns = \"leetcode\"\nOutput\n\n\"leotcede\"\nExplanation\nIn \"leetcode\", the vowels 'e', 'e', and 'o' are reversed, leading to the string \"leotcede\".\n\nExample 1:\n\nInput:\n\ns = 'IceCreAm'\n\nOutput:\n\nAceCreIm\nExplanation:Vowels ['I', 'e', 'e', 'A'] reversed result in 'AceCreIm'.\n\nExample 2:\n\nInput:\n\ns = 'hello'\n\nOutput:\n\nholle\nExplanation:Vowels ['e', 'o'] reversed result in 'holle'.\n\nExample 3:\n\nInput:\n\ns = 'abcdef'\n\nOutput:\n\nebcdaf\nExplanation:Vowels ['a', 'e'] reversed result in 'abcdef'.\n\n*/\nclass Solution\n{\npublic:\n    bool isVowel(char ch)\n    {\n        ch = tolower(ch);\n        return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u';\n    }\n\n    string reverseVowels(string &s)\n    {\n        int l = 0, h = s.size() - 1;\n\n        while (l < h)\n        {\n            if (isVowel(s[l]) && isVowel(s[h]))\n            {\n                swap(s[l], s[h]);\n                l++;\n                h--;\n            }\n            else if (isVowel(s[l]) == 0)\n            {\n                l++;\n            }\n            else\n            {\n                h--;\n            }\n        }\n        return s;\n    }\n};",
      "output": "AceCreIm\nExplanation:Vowels ['I', 'e', 'e', 'A'] reversed result in 'AceCreIm'.\nholle\nExplanation:Vowels ['e', 'o'] reversed result in 'holle'.\nebcdaf\nExplanation:Vowels ['a', 'e'] reversed result in 'abcdef'.",
      "language": "cpp"
    },
    {
      "fileName": "Reverse a Character Array.cpp",
      "name": "Reverse a Character Array",
      "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n/*\n\nExample:\nExample 1:\nInput: ['h', 'e', 'l', 'l', 'o']\nOutput: ['o', 'l', 'l', 'e', 'h']\nExample 2:\nInput: ['A', 'B', 'C', 'D']\nOutput: ['D', 'C', 'B', 'A']\nNote:\n\nThe array can contain both uppercase and lowercase characters.\nIt's important to swap elements within the array to reverse it without using additional space.\nExample 1:\n\nInput:\n\nInput: ['a', 'b', 'c', 'd', 'e']\n\nOutput:\n\ne,d,c,b,a\nExplanation:Reversing ['a', 'b', 'c', 'd', 'e'] results in ['e', 'd', 'c', 'b', 'a'].\n\nExample 2:\n\nInput:\n\nInput: ['x', 'y', 'z']\n\nOutput:\n\nz,y,x\nExplanation:Reversing ['x', 'y', 'z'] results in ['z', 'y', 'x'].\n\nExample 3:\n\nInput:\n\nInput: ['1', '2', '3', '4', '5', '6']\n\nOutput:\n\n6,5,4,3,2,1\nExplanation:Reversing ['1', '2', '3', '4', '5', '6'] results in ['6', '5', '4', '3', '2', '1'].\n\n*/\n\nclass Solution {\npublic:\n  void reverseCharArray(vector<char> &arr) {\n     reverse(arr.begin(), arr.end()); \n     }\n};",
      "output": "Note:\nThe array can contain both uppercase and lowercase characters.\nIt's important to swap elements within the array to reverse it without using additional space.\ne,d,c,b,a\nExplanation:Reversing ['a', 'b', 'c', 'd', 'e'] results in ['e', 'd', 'c', 'b', 'a'].\nz,y,x\nExplanation:Reversing ['x', 'y', 'z'] results in ['z', 'y', 'x'].\n6,5,4,3,2,1\nExplanation:Reversing ['1', '2', '3', '4', '5', '6'] results in ['6', '5', '4', '3', '2', '1'].",
      "language": "cpp"
    },
    {
      "fileName": "Valid Anagram.cpp",
      "name": "Valid Anagram",
      "code": "\n\n//  method-1\n\n#include <iostream>\nusing namespace std;\n\n/*\n\nExample\nInput\n\ns = \"anagram\"\n\nt = \"nagaram\"\nOutput\n\ntrue\nExplanation:\n\nBoth strings contain the letters a, g, m, n, r in the same frequencies. Thus, t is an anagram of s.\n\nAdditional Example\nInput\n\ns = \"rat\"\n\nt = \"car\"\nOutput\n\nfalse\nExplanation:\n\nThe strings do not contain the same frequencies of letters. Therefore, t is not an anagram of s.\n\nExample 1:\n\nInput:\n\ns = 'anagram', t = 'nagaram'\n\nOutput:\n\ntrue\nExplanation:'nagaram' is an anagram of 'anagram'.\n\nExample 2:\n\nInput:\n\ns = 'rat', t = 'car'\n\nOutput:\n\nfalse\nExplanation:'car' is not an anagram of 'rat'.\n\nExample 3:\n\nInput:\n\ns = 'hello', t = 'lloeh'\n\nOutput:\n\ntrue\nExplanation:'lloeh' is an anagram of 'hello'.\n\n\n\n*/\n\nclass Solution\n{\npublic:\n    bool isAnagram(const string &s, const string &t)\n    {\n        int arr[1000] = {0};\n        // for string s lets ad up counts\n        for (int i = 0; i < s.length(); i++)\n        {\n            char ch = s[i];\n            arr[ch]++;\n        }\n\n        // for string t, decrease the count\n        for (int i = 0; i < t.length(); i++)\n        {\n            char ch = t[i];\n            arr[ch]--;\n        }\n        // check all occurence are o only\n        for (int i = 0; i < 1000; i++)\n        {\n            if (arr[i] != 0)\n            {\n                return false;\n            }\n        }\n        // agar main yaha agya\n        // iska mtlb kahin pr bhi 0 nhi mila array  me\n        return true;\n    }\n};",
      "output": "true\nExplanation:'nagaram' is an anagram of 'anagram'.\nfalse\nExplanation:'car' is not an anagram of 'rat'.\ntrue\nExplanation:'lloeh' is an anagram of 'hello'.",
      "language": "cpp"
    },
    {
      "fileName": "Valid Palindrome-2.cpp",
      "name": "Valid Palindrome-2",
      "code": "#include <iostream>\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\n/*\n\nExample 1:\nInput:\n\n\"A man, a plan, a canal: Panama\"\n\nOutput:\n\ntrue\n\nExplanation:\n\nAfter removing non-alphanumeric characters and converting to lowercase, the string becomes \"amanaplanacanalpanama\", which is a palindrome.\n\nExample 2:\nInput:\n\n\"race a car\"\n\nOutput:\n\nfalse\n\nExplanation:\n\nThe processed string becomes \"raceacar\", which is not a palindrome.\n\nWrite a function to return true if the given string is a valid palindrome, or false otherwise.\n\nExample 1:\n\nInput:\n\ns=\"A man, a plan, a canal: Panama\"\n\nOutput:\n\ntrue\nExplanation:Ignoring cases and non-alphanumeric characters, 'AmanaplanacanalPanama' is a palindrome.\n\nExample 2:\n\nInput:\n\ns=\"race a car\"\n\nOutput:\n\nfalse\nExplanation:After removing non-alphanumeric characters and ignoring cases, 'raceacar' is not a palindrome.\n\nExample 3:\n\nInput:\n\ns=\" \"\n\nOutput:\n\ntrue\nExplanation:An empty string is considered a valid palindrome.\n\n*/\n\nclass Solution\n{\npublic:\n  bool isAnagram(const string &s, const string &t)\n  {\n    unordered_map<char, int> count;\n\n    for (int i = 0; i < s.length(); i++)\n    {\n      char ch = s[i];\n      count[ch]++;\n    }\n\n    for (int j = 0; j < t.length(); j++)\n    {\n      char ch = t[j];\n      count[ch]--;\n    }\n    for (char ch = 'a'; ch <= 'z'; ch++)\n    {\n      if (count[ch] != 0)\n      {\n        return false;\n      }\n    }\n    return true;\n  }\n};",
      "output": "true\nExplanation:\nAfter removing non-alphanumeric characters and converting to lowercase, the string becomes \"amanaplanacanalpanama\", which is a palindrome.\nfalse\nExplanation:\nThe processed string becomes \"raceacar\", which is not a palindrome.\nWrite a function to return true if the given string is a valid palindrome, or false otherwise.\ntrue\nExplanation:Ignoring cases and non-alphanumeric characters, 'AmanaplanacanalPanama' is a palindrome.\nfalse\nExplanation:After removing non-alphanumeric characters and ignoring cases, 'raceacar' is not a palindrome.\ntrue\nExplanation:An empty string is considered a valid palindrome.",
      "language": "cpp"
    },
    {
      "fileName": "Valid Palindrome-removal one or not -2.cpp",
      "name": "Valid Palindrome-removal one or not -2",
      "code": "#include <iostream>\nusing namespace std;\n/*\n\nGiven a string s, return true if the s can be palindrome after deleting at most one character from it.\n\n\nExample 1:\n\nInput: s = \"aba\"\nOutput: true\nExample 2:\n\nInput: s = \"abca\"\nOutput: true\nExplanation: You could delete the character 'c'.\nExample 3:\n\nInput: s = \"abc\"\nOutput: false\n\n\n*/\n\nclass Solution\n{\npublic:\n    bool checkPalindrome(string s, int i, int j)\n    {\n        while (i <= j)\n        {\n            if (s[i] != s[j])\n            {\n                return false;\n            }\n            else\n            {\n                i++;\n                j--;\n            }\n        }\n        return true;\n    }\n\n    bool validPalindrome(string s)\n    {\n        int i = 0;\n        int j = s.length() - 1;\n\n        while (i <= j)\n        {\n            // match\n            if (s[i] == s[j])\n            {\n                i++;\n                j--;\n            }\n            else\n            {\n                // no match\n                bool caseOneAns = checkPalindrome(s, i, j - 1);\n                bool caseTwoAns = checkPalindrome(s, i + 1, j);\n                bool finalAns = caseOneAns || caseTwoAns;\n                return finalAns;\n            }\n        }\n        // agar aapne puri string travel kr li aur jaha tak aa gaye to iska matlb puri string me kahi per bhi nomatch nhi hua iska matlb 0 removal wala palindrome case tha ye\n        return true;\n    }\n};",
      "output": "Explanation: You could delete the character 'c'.",
      "language": "cpp"
    }
  ]
};